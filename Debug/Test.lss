
Test.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000064c  00800200  00006132  000061c6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00006132  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000012f4  0080084c  0080084c  00006812  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00006812  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00006870  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000640  00000000  00000000  000068b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000092c2  00000000  00000000  00006ef0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001a9e  00000000  00000000  000101b2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000052f5  00000000  00000000  00011c50  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000014c4  00000000  00000000  00016f48  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000277c  00000000  00000000  0001840c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00009848  00000000  00000000  0001ab88  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000007c0  00000000  00000000  000243d0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	28 c1       	rjmp	.+592    	; 0x252 <__ctors_end>
       2:	00 00       	nop
       4:	47 c1       	rjmp	.+654    	; 0x294 <__bad_interrupt>
       6:	00 00       	nop
       8:	45 c1       	rjmp	.+650    	; 0x294 <__bad_interrupt>
       a:	00 00       	nop
       c:	0c 94 70 12 	jmp	0x24e0	; 0x24e0 <__vector_3>
      10:	0c 94 5f 12 	jmp	0x24be	; 0x24be <__vector_4>
      14:	0c 94 81 12 	jmp	0x2502	; 0x2502 <__vector_5>
      18:	3d c1       	rjmp	.+634    	; 0x294 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	3b c1       	rjmp	.+630    	; 0x294 <__bad_interrupt>
      1e:	00 00       	nop
      20:	39 c1       	rjmp	.+626    	; 0x294 <__bad_interrupt>
      22:	00 00       	nop
      24:	37 c1       	rjmp	.+622    	; 0x294 <__bad_interrupt>
      26:	00 00       	nop
      28:	35 c1       	rjmp	.+618    	; 0x294 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	33 c1       	rjmp	.+614    	; 0x294 <__bad_interrupt>
      2e:	00 00       	nop
      30:	31 c1       	rjmp	.+610    	; 0x294 <__bad_interrupt>
      32:	00 00       	nop
      34:	2f c1       	rjmp	.+606    	; 0x294 <__bad_interrupt>
      36:	00 00       	nop
      38:	2d c1       	rjmp	.+602    	; 0x294 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	2b c1       	rjmp	.+598    	; 0x294 <__bad_interrupt>
      3e:	00 00       	nop
      40:	29 c1       	rjmp	.+594    	; 0x294 <__bad_interrupt>
      42:	00 00       	nop
      44:	27 c1       	rjmp	.+590    	; 0x294 <__bad_interrupt>
      46:	00 00       	nop
      48:	25 c1       	rjmp	.+586    	; 0x294 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	23 c1       	rjmp	.+582    	; 0x294 <__bad_interrupt>
      4e:	00 00       	nop
      50:	21 c1       	rjmp	.+578    	; 0x294 <__bad_interrupt>
      52:	00 00       	nop
      54:	1f c1       	rjmp	.+574    	; 0x294 <__bad_interrupt>
      56:	00 00       	nop
      58:	1d c1       	rjmp	.+570    	; 0x294 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	1b c1       	rjmp	.+566    	; 0x294 <__bad_interrupt>
      5e:	00 00       	nop
      60:	19 c1       	rjmp	.+562    	; 0x294 <__bad_interrupt>
      62:	00 00       	nop
      64:	17 c1       	rjmp	.+558    	; 0x294 <__bad_interrupt>
      66:	00 00       	nop
      68:	15 c1       	rjmp	.+554    	; 0x294 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	13 c1       	rjmp	.+550    	; 0x294 <__bad_interrupt>
      6e:	00 00       	nop
      70:	11 c1       	rjmp	.+546    	; 0x294 <__bad_interrupt>
      72:	00 00       	nop
      74:	0f c1       	rjmp	.+542    	; 0x294 <__bad_interrupt>
      76:	00 00       	nop
      78:	0d c1       	rjmp	.+538    	; 0x294 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	0b c1       	rjmp	.+534    	; 0x294 <__bad_interrupt>
      7e:	00 00       	nop
      80:	0c 94 f3 15 	jmp	0x2be6	; 0x2be6 <__vector_32>
      84:	07 c1       	rjmp	.+526    	; 0x294 <__bad_interrupt>
      86:	00 00       	nop
      88:	05 c1       	rjmp	.+522    	; 0x294 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	03 c1       	rjmp	.+518    	; 0x294 <__bad_interrupt>
      8e:	00 00       	nop
      90:	01 c1       	rjmp	.+514    	; 0x294 <__bad_interrupt>
      92:	00 00       	nop
      94:	ff c0       	rjmp	.+510    	; 0x294 <__bad_interrupt>
      96:	00 00       	nop
      98:	fd c0       	rjmp	.+506    	; 0x294 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	fb c0       	rjmp	.+502    	; 0x294 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	f9 c0       	rjmp	.+498    	; 0x294 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	f7 c0       	rjmp	.+494    	; 0x294 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	f5 c0       	rjmp	.+490    	; 0x294 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	f3 c0       	rjmp	.+486    	; 0x294 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	f1 c0       	rjmp	.+482    	; 0x294 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	ef c0       	rjmp	.+478    	; 0x294 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	ed c0       	rjmp	.+474    	; 0x294 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	eb c0       	rjmp	.+470    	; 0x294 <__bad_interrupt>
      be:	00 00       	nop
      c0:	e9 c0       	rjmp	.+466    	; 0x294 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	e7 c0       	rjmp	.+462    	; 0x294 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	e5 c0       	rjmp	.+458    	; 0x294 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 d2 12 	jmp	0x25a4	; 0x25a4 <__vector_51>
      d0:	e1 c0       	rjmp	.+450    	; 0x294 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	df c0       	rjmp	.+446    	; 0x294 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	dd c0       	rjmp	.+442    	; 0x294 <__bad_interrupt>
      da:	00 00       	nop
      dc:	db c0       	rjmp	.+438    	; 0x294 <__bad_interrupt>
      de:	00 00       	nop
      e0:	d9 c0       	rjmp	.+434    	; 0x294 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	ad 13       	cpse	r26, r29
      e6:	c4 13       	cpse	r28, r20
      e8:	db 13       	cpse	r29, r27
      ea:	f5 13       	cpse	r31, r21
      ec:	14 14       	cp	r1, r4
      ee:	0f 14       	cp	r0, r15
      f0:	1e 14       	cp	r1, r14
      f2:	19 14       	cp	r1, r9
      f4:	08 4a       	sbci	r16, 0xA8	; 168
      f6:	d7 3b       	cpi	r29, 0xB7	; 183
      f8:	3b ce       	rjmp	.-906    	; 0xfffffd70 <__eeprom_end+0xff7efd70>
      fa:	01 6e       	ori	r16, 0xE1	; 225
      fc:	84 bc       	out	0x24, r8	; 36
      fe:	bf fd       	.word	0xfdbf	; ????
     100:	c1 2f       	mov	r28, r17
     102:	3d 6c       	ori	r19, 0xCD	; 205
     104:	74 31       	cpi	r23, 0x14	; 20
     106:	9a bd       	out	0x2a, r25	; 42
     108:	56 83       	std	Z+6, r21	; 0x06
     10a:	3d da       	rcall	.-2950   	; 0xfffff586 <__eeprom_end+0xff7ef586>
     10c:	3d 00       	.word	0x003d	; ????
     10e:	c7 7f       	andi	r28, 0xF7	; 247
     110:	11 be       	out	0x31, r1	; 49
     112:	d9 e4       	ldi	r29, 0x49	; 73
     114:	bb 4c       	sbci	r27, 0xCB	; 203
     116:	3e 91       	ld	r19, -X
     118:	6b aa       	std	Y+51, r6	; 0x33
     11a:	aa be       	out	0x3a, r10	; 58
     11c:	00 00       	nop
     11e:	00 80       	ld	r0, Z
     120:	3f 05       	cpc	r19, r15
     122:	a8 4c       	sbci	r26, 0xC8	; 200
     124:	cd b2       	in	r12, 0x1d	; 29
     126:	d4 4e       	sbci	r29, 0xE4	; 228
     128:	b9 38       	cpi	r27, 0x89	; 137
     12a:	36 a9       	ldd	r19, Z+54	; 0x36
     12c:	02 0c       	add	r0, r2
     12e:	50 b9       	out	0x00, r21	; 0
     130:	91 86       	std	Z+9, r9	; 0x09
     132:	88 08       	sbc	r8, r8
     134:	3c a6       	std	Y+44, r3	; 0x2c
     136:	aa aa       	std	Y+50, r10	; 0x32
     138:	2a be       	out	0x3a, r2	; 58
     13a:	00 00       	nop
     13c:	00 80       	ld	r0, Z
     13e:	3f 00       	.word	0x003f	; ????

00000140 <__trampolines_end>:
     140:	6e 61       	ori	r22, 0x1E	; 30
     142:	6e 00       	.word	0x006e	; ????

00000144 <__c.2240>:
     144:	69 6e 66 00 00 40 7a 10 f3 5a 00 a0 72 4e 18 09     inf..@z..Z..rN..
     154:	00 10 a5 d4 e8 00 00 e8 76 48 17 00 00 e4 0b 54     ........vH.....T
     164:	02 00 00 ca 9a 3b 00 00 00 e1 f5 05 00 00 80 96     .....;..........
     174:	98 00 00 00 40 42 0f 00 00 00 a0 86 01 00 00 00     ....@B..........
     184:	10 27 00 00 00 00 e8 03 00 00 00 00 64 00 00 00     .'..........d...
     194:	00 00 0a 00 00 00 00 00 01 00 00 00 00 00 2c 76     ..............,v
     1a4:	d8 88 dc 67 4f 08 23 df c1 df ae 59 e1 b1 b7 96     ...gO.#....Y....
     1b4:	e5 e3 e4 53 c6 3a e6 51 99 76 96 e8 e6 c2 84 26     ...S.:.Q.v.....&
     1c4:	eb 89 8c 9b 62 ed 40 7c 6f fc ef bc 9c 9f 40 f2     ....b.@|o.....@.
     1d4:	ba a5 6f a5 f4 90 05 5a 2a f7 5c 93 6b 6c f9 67     ..o....Z*.\.kl.g
     1e4:	6d c1 1b fc e0 e4 0d 47 fe f5 20 e6 b5 00 d0 ed     m......G.. .....
     1f4:	90 2e 03 00 94 35 77 05 00 80 84 1e 08 00 00 20     .....5w........ 
     204:	4e 0a 00 00 00 c8 0c 33 33 33 33 0f 98 6e 12 83     N......3333..n..
     214:	11 41 ef 8d 21 14 89 3b e6 55 16 cf fe e6 db 18     .A..!..;.U......
     224:	d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb e4 24 20 32     ..K8..|......$ 2
     234:	84 72 5e 22 81 00 c9 f1 24 ec a1 e5 3d 27           .r^"....$...='

00000242 <prvIdleTask>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
     242:	cf eb       	ldi	r28, 0xBF	; 191
     244:	da e1       	ldi	r29, 0x1A	; 26
     246:	88 81       	ld	r24, Y
     248:	82 30       	cpi	r24, 0x02	; 2
     24a:	f0 f3       	brcs	.-4      	; 0x248 <prvIdleTask+0x6>
     24c:	0e 94 1a 15 	call	0x2a34	; 0x2a34 <vPortYield>
     250:	fa cf       	rjmp	.-12     	; 0x246 <prvIdleTask+0x4>

00000252 <__ctors_end>:
     252:	11 24       	eor	r1, r1
     254:	1f be       	out	0x3f, r1	; 63
     256:	cf ef       	ldi	r28, 0xFF	; 255
     258:	d1 e2       	ldi	r29, 0x21	; 33
     25a:	de bf       	out	0x3e, r29	; 62
     25c:	cd bf       	out	0x3d, r28	; 61
     25e:	00 e0       	ldi	r16, 0x00	; 0
     260:	0c bf       	out	0x3c, r16	; 60

00000262 <__do_copy_data>:
     262:	18 e0       	ldi	r17, 0x08	; 8
     264:	a0 e0       	ldi	r26, 0x00	; 0
     266:	b2 e0       	ldi	r27, 0x02	; 2
     268:	e2 e3       	ldi	r30, 0x32	; 50
     26a:	f1 e6       	ldi	r31, 0x61	; 97
     26c:	00 e0       	ldi	r16, 0x00	; 0
     26e:	0b bf       	out	0x3b, r16	; 59
     270:	02 c0       	rjmp	.+4      	; 0x276 <__do_copy_data+0x14>
     272:	07 90       	elpm	r0, Z+
     274:	0d 92       	st	X+, r0
     276:	ac 34       	cpi	r26, 0x4C	; 76
     278:	b1 07       	cpc	r27, r17
     27a:	d9 f7       	brne	.-10     	; 0x272 <__do_copy_data+0x10>

0000027c <__do_clear_bss>:
     27c:	2b e1       	ldi	r18, 0x1B	; 27
     27e:	ac e4       	ldi	r26, 0x4C	; 76
     280:	b8 e0       	ldi	r27, 0x08	; 8
     282:	01 c0       	rjmp	.+2      	; 0x286 <.do_clear_bss_start>

00000284 <.do_clear_bss_loop>:
     284:	1d 92       	st	X+, r1

00000286 <.do_clear_bss_start>:
     286:	a0 34       	cpi	r26, 0x40	; 64
     288:	b2 07       	cpc	r27, r18
     28a:	e1 f7       	brne	.-8      	; 0x284 <.do_clear_bss_loop>
     28c:	0e 94 96 11 	call	0x232c	; 0x232c <main>
     290:	0c 94 97 30 	jmp	0x612e	; 0x612e <_exit>

00000294 <__bad_interrupt>:
     294:	b5 ce       	rjmp	.-662    	; 0x0 <__vectors>

00000296 <vCOM_init>:
#define HMC5883L_WRITE 0x3C
#define HMC5883L_READ 0x3D


void vCOM_init(void){
    vTWI_init();
     296:	0e 94 65 26 	call	0x4cca	; 0x4cca <vTWI_init>
    ui8TWI_start(HMC5883L_WRITE);
     29a:	8c e3       	ldi	r24, 0x3C	; 60
     29c:	0e 94 69 26 	call	0x4cd2	; 0x4cd2 <ui8TWI_start>
    ui8TWI_write(0x00); // set pointer to CRA
     2a0:	80 e0       	ldi	r24, 0x00	; 0
     2a2:	0e 94 8e 26 	call	0x4d1c	; 0x4d1c <ui8TWI_write>
    ui8TWI_write(0x70); // write 0x70 to CRA
     2a6:	80 e7       	ldi	r24, 0x70	; 112
     2a8:	0e 94 8e 26 	call	0x4d1c	; 0x4d1c <ui8TWI_write>
    vTWI_stop();
     2ac:	0e 94 b6 26 	call	0x4d6c	; 0x4d6c <vTWI_stop>

    ui8TWI_start(HMC5883L_WRITE);
     2b0:	8c e3       	ldi	r24, 0x3C	; 60
     2b2:	0e 94 69 26 	call	0x4cd2	; 0x4cd2 <ui8TWI_start>
    ui8TWI_write(0x01); // set pointer to CRB
     2b6:	81 e0       	ldi	r24, 0x01	; 1
     2b8:	0e 94 8e 26 	call	0x4d1c	; 0x4d1c <ui8TWI_write>
    ui8TWI_write(0xA0); // Set bit 7 and 5 (GN2, GN0)
     2bc:	80 ea       	ldi	r24, 0xA0	; 160
     2be:	0e 94 8e 26 	call	0x4d1c	; 0x4d1c <ui8TWI_write>
    vTWI_stop();
     2c2:	0e 94 b6 26 	call	0x4d6c	; 0x4d6c <vTWI_stop>

    ui8TWI_start(HMC5883L_WRITE);
     2c6:	8c e3       	ldi	r24, 0x3C	; 60
     2c8:	0e 94 69 26 	call	0x4cd2	; 0x4cd2 <ui8TWI_start>
    ui8TWI_write(0x02); // set pointer to measurement mode
     2cc:	82 e0       	ldi	r24, 0x02	; 2
     2ce:	0e 94 8e 26 	call	0x4d1c	; 0x4d1c <ui8TWI_write>
    ui8TWI_write(0x00); // continous measurement
     2d2:	80 e0       	ldi	r24, 0x00	; 0
     2d4:	0e 94 8e 26 	call	0x4d1c	; 0x4d1c <ui8TWI_write>
    vTWI_stop();
     2d8:	0c 94 b6 26 	jmp	0x4d6c	; 0x4d6c <vTWI_stop>
     2dc:	08 95       	ret

000002de <vCOM_getData>:
}

void vCOM_getData(int16_t *xCom, int16_t *yCom, int16_t *zCom){
     2de:	ef 92       	push	r14
     2e0:	ff 92       	push	r15
     2e2:	0f 93       	push	r16
     2e4:	1f 93       	push	r17
     2e6:	cf 93       	push	r28
     2e8:	df 93       	push	r29
     2ea:	7c 01       	movw	r14, r24
     2ec:	eb 01       	movw	r28, r22
     2ee:	8a 01       	movw	r16, r20
    ui8TWI_start(HMC5883L_WRITE);
     2f0:	8c e3       	ldi	r24, 0x3C	; 60
     2f2:	0e 94 69 26 	call	0x4cd2	; 0x4cd2 <ui8TWI_start>
    ui8TWI_write(0x03); // set pointer to X axis MSB
     2f6:	83 e0       	ldi	r24, 0x03	; 3
     2f8:	0e 94 8e 26 	call	0x4d1c	; 0x4d1c <ui8TWI_write>
    vTWI_stop();
     2fc:	0e 94 b6 26 	call	0x4d6c	; 0x4d6c <vTWI_stop>
    ui8TWI_start(HMC5883L_READ);
     300:	8d e3       	ldi	r24, 0x3D	; 61
     302:	0e 94 69 26 	call	0x4cd2	; 0x4cd2 <ui8TWI_start>
    *xCom = ((uint8_t)ui8TWI_read_ack())<<8;
     306:	0e 94 a0 26 	call	0x4d40	; 0x4d40 <ui8TWI_read_ack>
     30a:	f7 01       	movw	r30, r14
     30c:	10 82       	st	Z, r1
     30e:	81 83       	std	Z+1, r24	; 0x01
    *xCom |= ui8TWI_read_ack();
     310:	0e 94 a0 26 	call	0x4d40	; 0x4d40 <ui8TWI_read_ack>
     314:	f7 01       	movw	r30, r14
     316:	20 81       	ld	r18, Z
     318:	31 81       	ldd	r19, Z+1	; 0x01
     31a:	28 2b       	or	r18, r24
     31c:	31 83       	std	Z+1, r19	; 0x01
     31e:	20 83       	st	Z, r18
    *zCom = ((uint8_t)ui8TWI_read_ack())<<8;
     320:	0e 94 a0 26 	call	0x4d40	; 0x4d40 <ui8TWI_read_ack>
     324:	f8 01       	movw	r30, r16
     326:	10 82       	st	Z, r1
     328:	81 83       	std	Z+1, r24	; 0x01
    *zCom |= ui8TWI_read_ack();
     32a:	0e 94 a0 26 	call	0x4d40	; 0x4d40 <ui8TWI_read_ack>
     32e:	f8 01       	movw	r30, r16
     330:	20 81       	ld	r18, Z
     332:	31 81       	ldd	r19, Z+1	; 0x01
     334:	28 2b       	or	r18, r24
     336:	31 83       	std	Z+1, r19	; 0x01
     338:	20 83       	st	Z, r18
    *yCom = ((uint8_t)ui8TWI_read_ack())<<8;
     33a:	0e 94 a0 26 	call	0x4d40	; 0x4d40 <ui8TWI_read_ack>
     33e:	18 82       	st	Y, r1
     340:	89 83       	std	Y+1, r24	; 0x01
    *yCom |= ui8TWI_read_nack();
     342:	0e 94 ab 26 	call	0x4d56	; 0x4d56 <ui8TWI_read_nack>
     346:	28 81       	ld	r18, Y
     348:	39 81       	ldd	r19, Y+1	; 0x01
     34a:	28 2b       	or	r18, r24
     34c:	39 83       	std	Y+1, r19	; 0x01
     34e:	28 83       	st	Y, r18
    vTWI_stop();
     350:	0e 94 b6 26 	call	0x4d6c	; 0x4d6c <vTWI_stop>
}
     354:	df 91       	pop	r29
     356:	cf 91       	pop	r28
     358:	1f 91       	pop	r17
     35a:	0f 91       	pop	r16
     35c:	ff 90       	pop	r15
     35e:	ef 90       	pop	r14
     360:	08 95       	ret

00000362 <vDistSens_init>:
};

/* Initialize distance sensors and ADC */
void vDistSens_init(){
    /* Initialize sensor pins as input */
    distSensReg &= ~((1<<distSensFwd) & (1<<distSensLeft) & (1<<distSensRear) & (1<<distSensRight));
     362:	80 b3       	in	r24, 0x10	; 16
     364:	80 bb       	out	0x10, r24	; 16
    
    /* Internal 2.56V VREG with external capacitor at AREF pin */
    /* Datasheet p281 table 26-3 */
    ADMUX |= (1<<REFS1) | (1<<REFS0);
     366:	ec e7       	ldi	r30, 0x7C	; 124
     368:	f0 e0       	ldi	r31, 0x00	; 0
     36a:	80 81       	ld	r24, Z
     36c:	80 6c       	ori	r24, 0xC0	; 192
     36e:	80 83       	st	Z, r24
    
    /* ADC enable */
    ADCSRA |= (1<<ADEN);
     370:	ea e7       	ldi	r30, 0x7A	; 122
     372:	f0 e0       	ldi	r31, 0x00	; 0
     374:	80 81       	ld	r24, Z
     376:	80 68       	ori	r24, 0x80	; 128
     378:	80 83       	st	Z, r24
    
    /* ADC prescaler setting (div. factor = 16) */
    /* Datasheet p257 table 21-5 */
    ADCSRA |= (1<<ADPS2) | (0<<ADPS1) | (0<<ADPS0);
     37a:	80 81       	ld	r24, Z
     37c:	84 60       	ori	r24, 0x04	; 4
     37e:	80 83       	st	Z, r24
     380:	08 95       	ret

00000382 <ui8DistSens_readCM>:
uint8_t ui8DistSens_readCM(uint8_t sensorDirection){
    
    uint8_t ui8_analogValue;
    
    /* Choose channel */
    ADMUX = sensorDirection;
     382:	ec e7       	ldi	r30, 0x7C	; 124
     384:	f0 e0       	ldi	r31, 0x00	; 0
     386:	80 83       	st	Z, r24
    
    /* Enable internal 2,54V AREF */
    ADMUX |= (1<<REFS1) | (1<<REFS0);
     388:	90 81       	ld	r25, Z
     38a:	90 6c       	ori	r25, 0xC0	; 192
     38c:	90 83       	st	Z, r25
    
    /* Start conversion */
    ADCSRA |= (1<<ADSC);
     38e:	ea e7       	ldi	r30, 0x7A	; 122
     390:	f0 e0       	ldi	r31, 0x00	; 0
     392:	90 81       	ld	r25, Z
     394:	90 64       	ori	r25, 0x40	; 64
     396:	90 83       	st	Z, r25
    loop_until_bit_is_clear(ADCSRA, ADSC); // Macro from <avr/io.h>, wait until bit bit in IO register is set.
     398:	90 81       	ld	r25, Z
     39a:	96 fd       	sbrc	r25, 6
     39c:	fd cf       	rjmp	.-6      	; 0x398 <ui8DistSens_readCM+0x16>

    /* Return the 8 most significant bits from the 10 bit register */
    ui8_analogValue = (ADCL >> 2) | (ADCH << 6);
     39e:	20 91 78 00 	lds	r18, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
     3a2:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
    
    // Returns corresponding distance in CM
    return ui8_analogToCM[sensorDirection-1][ui8_analogValue];
     3a6:	e8 2f       	mov	r30, r24
     3a8:	f0 e0       	ldi	r31, 0x00	; 0
     3aa:	31 97       	sbiw	r30, 0x01	; 1
    /* Start conversion */
    ADCSRA |= (1<<ADSC);
    loop_until_bit_is_clear(ADCSRA, ADSC); // Macro from <avr/io.h>, wait until bit bit in IO register is set.

    /* Return the 8 most significant bits from the 10 bit register */
    ui8_analogValue = (ADCL >> 2) | (ADCH << 6);
     3ac:	30 e4       	ldi	r19, 0x40	; 64
     3ae:	93 9f       	mul	r25, r19
     3b0:	c0 01       	movw	r24, r0
     3b2:	11 24       	eor	r1, r1
     3b4:	92 2f       	mov	r25, r18
     3b6:	96 95       	lsr	r25
     3b8:	96 95       	lsr	r25
     3ba:	89 2b       	or	r24, r25
    
    // Returns corresponding distance in CM
    return ui8_analogToCM[sensorDirection-1][ui8_analogValue];
     3bc:	fe 2f       	mov	r31, r30
     3be:	ee 27       	eor	r30, r30
     3c0:	e8 0f       	add	r30, r24
     3c2:	f1 1d       	adc	r31, r1
     3c4:	e0 50       	subi	r30, 0x00	; 0
     3c6:	fe 4f       	sbci	r31, 0xFE	; 254
}
     3c8:	80 81       	ld	r24, Z
     3ca:	08 95       	ret

000003cc <vFunc_Inf2pi>:
#include <string.h>
#include <math.h>
#include <stdlib.h>

/* Take any angle and put it inside -pi,pi */
void vFunc_Inf2pi(float *angle_in_radians){
     3cc:	cf 92       	push	r12
     3ce:	df 92       	push	r13
     3d0:	ef 92       	push	r14
     3d2:	ff 92       	push	r15
     3d4:	cf 93       	push	r28
     3d6:	df 93       	push	r29
     3d8:	ec 01       	movw	r28, r24
    do{
        if (*angle_in_radians > M_PI) *angle_in_radians -= 2*M_PI;
     3da:	c8 80       	ld	r12, Y
     3dc:	d9 80       	ldd	r13, Y+1	; 0x01
     3de:	ea 80       	ldd	r14, Y+2	; 0x02
     3e0:	fb 80       	ldd	r15, Y+3	; 0x03
     3e2:	2b ed       	ldi	r18, 0xDB	; 219
     3e4:	3f e0       	ldi	r19, 0x0F	; 15
     3e6:	49 e4       	ldi	r20, 0x49	; 73
     3e8:	50 e4       	ldi	r21, 0x40	; 64
     3ea:	c7 01       	movw	r24, r14
     3ec:	b6 01       	movw	r22, r12
     3ee:	0e 94 86 29 	call	0x530c	; 0x530c <__gesf2>
     3f2:	18 16       	cp	r1, r24
     3f4:	6c f4       	brge	.+26     	; 0x410 <__FUSE_REGION_LENGTH__+0x10>
     3f6:	2b ed       	ldi	r18, 0xDB	; 219
     3f8:	3f e0       	ldi	r19, 0x0F	; 15
     3fa:	49 ec       	ldi	r20, 0xC9	; 201
     3fc:	50 e4       	ldi	r21, 0x40	; 64
     3fe:	c7 01       	movw	r24, r14
     400:	b6 01       	movw	r22, r12
     402:	0e 94 0f 27 	call	0x4e1e	; 0x4e1e <__subsf3>
     406:	68 83       	st	Y, r22
     408:	79 83       	std	Y+1, r23	; 0x01
     40a:	8a 83       	std	Y+2, r24	; 0x02
     40c:	9b 83       	std	Y+3, r25	; 0x03
     40e:	16 c0       	rjmp	.+44     	; 0x43c <__FUSE_REGION_LENGTH__+0x3c>
        else if (*angle_in_radians < -M_PI) *angle_in_radians += 2*M_PI;
     410:	2b ed       	ldi	r18, 0xDB	; 219
     412:	3f e0       	ldi	r19, 0x0F	; 15
     414:	49 e4       	ldi	r20, 0x49	; 73
     416:	50 ec       	ldi	r21, 0xC0	; 192
     418:	c7 01       	movw	r24, r14
     41a:	b6 01       	movw	r22, r12
     41c:	0e 94 d6 27 	call	0x4fac	; 0x4fac <__cmpsf2>
     420:	88 23       	and	r24, r24
     422:	64 f4       	brge	.+24     	; 0x43c <__FUSE_REGION_LENGTH__+0x3c>
     424:	2b ed       	ldi	r18, 0xDB	; 219
     426:	3f e0       	ldi	r19, 0x0F	; 15
     428:	49 ec       	ldi	r20, 0xC9	; 201
     42a:	50 e4       	ldi	r21, 0x40	; 64
     42c:	c7 01       	movw	r24, r14
     42e:	b6 01       	movw	r22, r12
     430:	0e 94 10 27 	call	0x4e20	; 0x4e20 <__addsf3>
     434:	68 83       	st	Y, r22
     436:	79 83       	std	Y+1, r23	; 0x01
     438:	8a 83       	std	Y+2, r24	; 0x02
     43a:	9b 83       	std	Y+3, r25	; 0x03
    } while (fabs(*angle_in_radians) > M_PI);
     43c:	88 81       	ld	r24, Y
     43e:	99 81       	ldd	r25, Y+1	; 0x01
     440:	aa 81       	ldd	r26, Y+2	; 0x02
     442:	bb 81       	ldd	r27, Y+3	; 0x03
     444:	bc 01       	movw	r22, r24
     446:	cd 01       	movw	r24, r26
     448:	9f 77       	andi	r25, 0x7F	; 127
     44a:	2b ed       	ldi	r18, 0xDB	; 219
     44c:	3f e0       	ldi	r19, 0x0F	; 15
     44e:	49 e4       	ldi	r20, 0x49	; 73
     450:	50 e4       	ldi	r21, 0x40	; 64
     452:	0e 94 86 29 	call	0x530c	; 0x530c <__gesf2>
     456:	18 16       	cp	r1, r24
     458:	0c f4       	brge	.+2      	; 0x45c <__FUSE_REGION_LENGTH__+0x5c>
     45a:	bf cf       	rjmp	.-130    	; 0x3da <vFunc_Inf2pi+0xe>
}
     45c:	df 91       	pop	r29
     45e:	cf 91       	pop	r28
     460:	ff 90       	pop	r15
     462:	ef 90       	pop	r14
     464:	df 90       	pop	r13
     466:	cf 90       	pop	r12
     468:	08 95       	ret

0000046a <vFunc_ParseUpdate>:

// parse the update message from uart
void vFunc_ParseUpdate(char *cin, float *theta, int16_t *radius){
     46a:	cf 92       	push	r12
     46c:	df 92       	push	r13
     46e:	ef 92       	push	r14
     470:	ff 92       	push	r15
     472:	0f 93       	push	r16
     474:	1f 93       	push	r17
     476:	cf 93       	push	r28
     478:	df 93       	push	r29
     47a:	00 d0       	rcall	.+0      	; 0x47c <vFunc_ParseUpdate+0x12>
     47c:	00 d0       	rcall	.+0      	; 0x47e <vFunc_ParseUpdate+0x14>
     47e:	cd b7       	in	r28, 0x3d	; 61
     480:	de b7       	in	r29, 0x3e	; 62
     482:	7b 01       	movw	r14, r22
     484:	6a 01       	movw	r12, r20
    char *token;
    const char delimiters[] = "{U,}\n";
     486:	26 e0       	ldi	r18, 0x06	; 6
     488:	ee e0       	ldi	r30, 0x0E	; 14
     48a:	f6 e0       	ldi	r31, 0x06	; 6
     48c:	de 01       	movw	r26, r28
     48e:	11 96       	adiw	r26, 0x01	; 1
     490:	01 90       	ld	r0, Z+
     492:	0d 92       	st	X+, r0
     494:	2a 95       	dec	r18
     496:	e1 f7       	brne	.-8      	; 0x490 <vFunc_ParseUpdate+0x26>
    token = strtok(cin, delimiters);
     498:	be 01       	movw	r22, r28
     49a:	6f 5f       	subi	r22, 0xFF	; 255
     49c:	7f 4f       	sbci	r23, 0xFF	; 255
     49e:	0e 94 2b 2f 	call	0x5e56	; 0x5e56 <strtok>
    uint8_t i = 0;
    while (token != NULL){
     4a2:	00 97       	sbiw	r24, 0x00	; 0
     4a4:	69 f1       	breq	.+90     	; 0x500 <vFunc_ParseUpdate+0x96>
     4a6:	10 e0       	ldi	r17, 0x00	; 0
                *theta = atoi(token);
            break;
            
            case 1:{
                *radius = atoi(token);
            break;}
     4a8:	01 e0       	ldi	r16, 0x01	; 1
    char *token;
    const char delimiters[] = "{U,}\n";
    token = strtok(cin, delimiters);
    uint8_t i = 0;
    while (token != NULL){
        switch (i)
     4aa:	11 23       	and	r17, r17
     4ac:	19 f0       	breq	.+6      	; 0x4b4 <vFunc_ParseUpdate+0x4a>
     4ae:	11 30       	cpi	r17, 0x01	; 1
     4b0:	b9 f0       	breq	.+46     	; 0x4e0 <vFunc_ParseUpdate+0x76>
     4b2:	1c c0       	rjmp	.+56     	; 0x4ec <vFunc_ParseUpdate+0x82>
        {
            case 0:
                *theta = atoi(token);
     4b4:	0e 94 2b 2e 	call	0x5c56	; 0x5c56 <atoi>
     4b8:	bc 01       	movw	r22, r24
     4ba:	99 0f       	add	r25, r25
     4bc:	88 0b       	sbc	r24, r24
     4be:	99 0b       	sbc	r25, r25
     4c0:	0e 94 78 28 	call	0x50f0	; 0x50f0 <__floatsisf>
     4c4:	f7 01       	movw	r30, r14
     4c6:	60 83       	st	Z, r22
     4c8:	71 83       	std	Z+1, r23	; 0x01
     4ca:	82 83       	std	Z+2, r24	; 0x02
     4cc:	93 83       	std	Z+3, r25	; 0x03
            break;}
            
            default:
            break;
        }
        token = strtok(NULL, delimiters);
     4ce:	be 01       	movw	r22, r28
     4d0:	6f 5f       	subi	r22, 0xFF	; 255
     4d2:	7f 4f       	sbci	r23, 0xFF	; 255
     4d4:	80 e0       	ldi	r24, 0x00	; 0
     4d6:	90 e0       	ldi	r25, 0x00	; 0
     4d8:	0e 94 2b 2f 	call	0x5e56	; 0x5e56 <strtok>
void vFunc_ParseUpdate(char *cin, float *theta, int16_t *radius){
    char *token;
    const char delimiters[] = "{U,}\n";
    token = strtok(cin, delimiters);
    uint8_t i = 0;
    while (token != NULL){
     4dc:	00 97       	sbiw	r24, 0x00	; 0
     4de:	81 f0       	breq	.+32     	; 0x500 <vFunc_ParseUpdate+0x96>
            case 0:
                *theta = atoi(token);
            break;
            
            case 1:{
                *radius = atoi(token);
     4e0:	0e 94 2b 2e 	call	0x5c56	; 0x5c56 <atoi>
     4e4:	f6 01       	movw	r30, r12
     4e6:	91 83       	std	Z+1, r25	; 0x01
     4e8:	80 83       	st	Z, r24
            break;}
     4ea:	10 2f       	mov	r17, r16
            
            default:
            break;
        }
        token = strtok(NULL, delimiters);
     4ec:	be 01       	movw	r22, r28
     4ee:	6f 5f       	subi	r22, 0xFF	; 255
     4f0:	7f 4f       	sbci	r23, 0xFF	; 255
     4f2:	80 e0       	ldi	r24, 0x00	; 0
     4f4:	90 e0       	ldi	r25, 0x00	; 0
     4f6:	0e 94 2b 2f 	call	0x5e56	; 0x5e56 <strtok>
        i++;
     4fa:	1f 5f       	subi	r17, 0xFF	; 255
void vFunc_ParseUpdate(char *cin, float *theta, int16_t *radius){
    char *token;
    const char delimiters[] = "{U,}\n";
    token = strtok(cin, delimiters);
    uint8_t i = 0;
    while (token != NULL){
     4fc:	00 97       	sbiw	r24, 0x00	; 0
     4fe:	a9 f6       	brne	.-86     	; 0x4aa <vFunc_ParseUpdate+0x40>
            break;
        }
        token = strtok(NULL, delimiters);
        i++;
    }
}
     500:	26 96       	adiw	r28, 0x06	; 6
     502:	0f b6       	in	r0, 0x3f	; 63
     504:	f8 94       	cli
     506:	de bf       	out	0x3e, r29	; 62
     508:	0f be       	out	0x3f, r0	; 63
     50a:	cd bf       	out	0x3d, r28	; 61
     50c:	df 91       	pop	r29
     50e:	cf 91       	pop	r28
     510:	1f 91       	pop	r17
     512:	0f 91       	pop	r16
     514:	ff 90       	pop	r15
     516:	ef 90       	pop	r14
     518:	df 90       	pop	r13
     51a:	cf 90       	pop	r12
     51c:	08 95       	ret

0000051e <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     51e:	cf 93       	push	r28
     520:	df 93       	push	r29
     522:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     524:	0e 94 2f 22 	call	0x445e	; 0x445e <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     528:	80 91 4e 08 	lds	r24, 0x084E	; 0x80084e <pucAlignedHeap.1904>
     52c:	90 91 4f 08 	lds	r25, 0x084F	; 0x80084f <pucAlignedHeap.1904+0x1>
     530:	89 2b       	or	r24, r25
     532:	31 f4       	brne	.+12     	; 0x540 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     534:	83 e5       	ldi	r24, 0x53	; 83
     536:	98 e0       	ldi	r25, 0x08	; 8
     538:	90 93 4f 08 	sts	0x084F, r25	; 0x80084f <pucAlignedHeap.1904+0x1>
     53c:	80 93 4e 08 	sts	0x084E, r24	; 0x80084e <pucAlignedHeap.1904>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     540:	20 91 50 08 	lds	r18, 0x0850	; 0x800850 <xNextFreeByte>
     544:	30 91 51 08 	lds	r19, 0x0851	; 0x800851 <xNextFreeByte+0x1>
     548:	ce 01       	movw	r24, r28
     54a:	82 0f       	add	r24, r18
     54c:	93 1f       	adc	r25, r19
     54e:	8f 3f       	cpi	r24, 0xFF	; 255
     550:	41 e1       	ldi	r20, 0x11	; 17
     552:	94 07       	cpc	r25, r20
     554:	70 f4       	brcc	.+28     	; 0x572 <pvPortMalloc+0x54>
     556:	28 17       	cp	r18, r24
     558:	39 07       	cpc	r19, r25
     55a:	70 f4       	brcc	.+28     	; 0x578 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     55c:	c0 91 4e 08 	lds	r28, 0x084E	; 0x80084e <pucAlignedHeap.1904>
     560:	d0 91 4f 08 	lds	r29, 0x084F	; 0x80084f <pucAlignedHeap.1904+0x1>
     564:	c2 0f       	add	r28, r18
     566:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     568:	90 93 51 08 	sts	0x0851, r25	; 0x800851 <xNextFreeByte+0x1>
     56c:	80 93 50 08 	sts	0x0850, r24	; 0x800850 <xNextFreeByte>
     570:	05 c0       	rjmp	.+10     	; 0x57c <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     572:	c0 e0       	ldi	r28, 0x00	; 0
     574:	d0 e0       	ldi	r29, 0x00	; 0
     576:	02 c0       	rjmp	.+4      	; 0x57c <pvPortMalloc+0x5e>
     578:	c0 e0       	ldi	r28, 0x00	; 0
     57a:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     57c:	0e 94 35 22 	call	0x446a	; 0x446a <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     580:	ce 01       	movw	r24, r28
     582:	df 91       	pop	r29
     584:	cf 91       	pop	r28
     586:	08 95       	ret

00000588 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     588:	08 95       	ret

0000058a <sIMU_readRegisterRegion>:
}
float fIMU_readFloatGyroY( void ){
    
    float output = fIMU_calcGyro(i16IMU_readRawGyroY());
    return output;
}
     58a:	ef 92       	push	r14
     58c:	ff 92       	push	r15
     58e:	0f 93       	push	r16
     590:	1f 93       	push	r17
     592:	cf 93       	push	r28
     594:	df 93       	push	r29
     596:	ec 01       	movw	r28, r24
     598:	e4 2e       	mov	r14, r20
     59a:	28 98       	cbi	0x05, 0	; 5
     59c:	86 2f       	mov	r24, r22
     59e:	80 68       	ori	r24, 0x80	; 128
     5a0:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <ui8SPI_MasterTransmit>
     5a4:	ee 20       	and	r14, r14
     5a6:	b1 f0       	breq	.+44     	; 0x5d4 <sIMU_readRegisterRegion+0x4a>
     5a8:	0f ef       	ldi	r16, 0xFF	; 255
     5aa:	0e 0d       	add	r16, r14
     5ac:	10 e0       	ldi	r17, 0x00	; 0
     5ae:	0f 5f       	subi	r16, 0xFF	; 255
     5b0:	1f 4f       	sbci	r17, 0xFF	; 255
     5b2:	0c 0f       	add	r16, r28
     5b4:	1d 1f       	adc	r17, r29
     5b6:	f1 2c       	mov	r15, r1
     5b8:	80 e0       	ldi	r24, 0x00	; 0
     5ba:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <ui8SPI_MasterTransmit>
     5be:	8f 3f       	cpi	r24, 0xFF	; 255
     5c0:	09 f4       	brne	.+2      	; 0x5c4 <sIMU_readRegisterRegion+0x3a>
     5c2:	f3 94       	inc	r15
     5c4:	89 93       	st	Y+, r24
     5c6:	c0 17       	cp	r28, r16
     5c8:	d1 07       	cpc	r29, r17
     5ca:	b1 f7       	brne	.-20     	; 0x5b8 <sIMU_readRegisterRegion+0x2e>
     5cc:	ef 10       	cpse	r14, r15
     5ce:	04 c0       	rjmp	.+8      	; 0x5d8 <sIMU_readRegisterRegion+0x4e>
     5d0:	85 e0       	ldi	r24, 0x05	; 5
     5d2:	03 c0       	rjmp	.+6      	; 0x5da <sIMU_readRegisterRegion+0x50>
     5d4:	85 e0       	ldi	r24, 0x05	; 5
     5d6:	01 c0       	rjmp	.+2      	; 0x5da <sIMU_readRegisterRegion+0x50>
     5d8:	80 e0       	ldi	r24, 0x00	; 0
     5da:	28 9a       	sbi	0x05, 0	; 5
     5dc:	df 91       	pop	r29
     5de:	cf 91       	pop	r28
     5e0:	1f 91       	pop	r17
     5e2:	0f 91       	pop	r16
     5e4:	ff 90       	pop	r15
     5e6:	ef 90       	pop	r14
     5e8:	08 95       	ret

000005ea <sIMU_readRegister>:
     5ea:	cf 93       	push	r28
     5ec:	df 93       	push	r29
     5ee:	ec 01       	movw	r28, r24
     5f0:	28 98       	cbi	0x05, 0	; 5
     5f2:	86 2f       	mov	r24, r22
     5f4:	80 68       	ori	r24, 0x80	; 128
     5f6:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <ui8SPI_MasterTransmit>
     5fa:	80 e0       	ldi	r24, 0x00	; 0
     5fc:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <ui8SPI_MasterTransmit>
     600:	98 2f       	mov	r25, r24
     602:	28 9a       	sbi	0x05, 0	; 5
     604:	8f 3f       	cpi	r24, 0xFF	; 255
     606:	11 f4       	brne	.+4      	; 0x60c <sIMU_readRegister+0x22>
     608:	85 e0       	ldi	r24, 0x05	; 5
     60a:	01 c0       	rjmp	.+2      	; 0x60e <sIMU_readRegister+0x24>
     60c:	80 e0       	ldi	r24, 0x00	; 0
     60e:	98 83       	st	Y, r25
     610:	df 91       	pop	r29
     612:	cf 91       	pop	r28
     614:	08 95       	ret

00000616 <sIMU_Init>:
     616:	cf 93       	push	r28
     618:	df 93       	push	r29
     61a:	1f 92       	push	r1
     61c:	1f 92       	push	r1
     61e:	cd b7       	in	r28, 0x3d	; 61
     620:	de b7       	in	r29, 0x3e	; 62
     622:	e7 ef       	ldi	r30, 0xF7	; 247
     624:	fa e1       	ldi	r31, 0x1A	; 26
     626:	81 e0       	ldi	r24, 0x01	; 1
     628:	80 83       	st	Z, r24
     62a:	24 ef       	ldi	r18, 0xF4	; 244
     62c:	31 e0       	ldi	r19, 0x01	; 1
     62e:	32 83       	std	Z+2, r19	; 0x02
     630:	21 83       	std	Z+1, r18	; 0x01
     632:	22 e8       	ldi	r18, 0x82	; 130
     634:	36 e0       	ldi	r19, 0x06	; 6
     636:	34 83       	std	Z+4, r19	; 0x04
     638:	23 83       	std	Z+3, r18	; 0x03
     63a:	20 e9       	ldi	r18, 0x90	; 144
     63c:	31 e0       	ldi	r19, 0x01	; 1
     63e:	36 83       	std	Z+6, r19	; 0x06
     640:	25 83       	std	Z+5, r18	; 0x05
     642:	17 82       	std	Z+7, r1	; 0x07
     644:	10 86       	std	Z+8, r1	; 0x08
     646:	81 87       	std	Z+9, r24	; 0x09
     648:	82 87       	std	Z+10, r24	; 0x0a
     64a:	20 e1       	ldi	r18, 0x10	; 16
     64c:	30 e0       	ldi	r19, 0x00	; 0
     64e:	34 87       	std	Z+12, r19	; 0x0c
     650:	23 87       	std	Z+11, r18	; 0x0b
     652:	2d e0       	ldi	r18, 0x0D	; 13
     654:	30 e0       	ldi	r19, 0x00	; 0
     656:	36 87       	std	Z+14, r19	; 0x0e
     658:	25 87       	std	Z+13, r18	; 0x0d
     65a:	22 e3       	ldi	r18, 0x32	; 50
     65c:	30 e0       	ldi	r19, 0x00	; 0
     65e:	30 8b       	std	Z+16, r19	; 0x10
     660:	27 87       	std	Z+15, r18	; 0x0f
     662:	11 8a       	std	Z+17, r1	; 0x11
     664:	12 8a       	std	Z+18, r1	; 0x12
     666:	83 8b       	std	Z+19, r24	; 0x13
     668:	84 8b       	std	Z+20, r24	; 0x14
     66a:	88 eb       	ldi	r24, 0xB8	; 184
     66c:	9b e0       	ldi	r25, 0x0B	; 11
     66e:	96 8b       	std	Z+22, r25	; 0x16
     670:	85 8b       	std	Z+21, r24	; 0x15
     672:	8a e0       	ldi	r24, 0x0A	; 10
     674:	90 e0       	ldi	r25, 0x00	; 0
     676:	90 8f       	std	Z+24, r25	; 0x18
     678:	87 8b       	std	Z+23, r24	; 0x17
     67a:	11 8e       	std	Z+25, r1	; 0x19
     67c:	10 92 12 1b 	sts	0x1B12, r1	; 0x801b12 <allOnesCounter+0x1>
     680:	10 92 11 1b 	sts	0x1B11, r1	; 0x801b11 <allOnesCounter>
     684:	10 92 14 1b 	sts	0x1B14, r1	; 0x801b14 <nonSuccessCounter+0x1>
     688:	10 92 13 1b 	sts	0x1B13, r1	; 0x801b13 <nonSuccessCounter>
     68c:	0e 94 fa 1c 	call	0x39f4	; 0x39f4 <vSPI_MasterInit>
     690:	20 9a       	sbi	0x04, 0	; 4
     692:	28 9a       	sbi	0x05, 0	; 5
     694:	19 82       	std	Y+1, r1	; 0x01
     696:	20 e1       	ldi	r18, 0x10	; 16
     698:	37 e2       	ldi	r19, 0x27	; 39
     69a:	89 81       	ldd	r24, Y+1	; 0x01
     69c:	8f 5f       	subi	r24, 0xFF	; 255
     69e:	89 83       	std	Y+1, r24	; 0x01
     6a0:	21 50       	subi	r18, 0x01	; 1
     6a2:	31 09       	sbc	r19, r1
     6a4:	d1 f7       	brne	.-12     	; 0x69a <sIMU_Init+0x84>
     6a6:	6f e0       	ldi	r22, 0x0F	; 15
     6a8:	ce 01       	movw	r24, r28
     6aa:	02 96       	adiw	r24, 0x02	; 2
     6ac:	9e df       	rcall	.-196    	; 0x5ea <sIMU_readRegister>
     6ae:	8a 81       	ldd	r24, Y+2	; 0x02
     6b0:	89 36       	cpi	r24, 0x69	; 105
     6b2:	c9 f7       	brne	.-14     	; 0x6a6 <sIMU_Init+0x90>
     6b4:	80 e0       	ldi	r24, 0x00	; 0
     6b6:	0f 90       	pop	r0
     6b8:	0f 90       	pop	r0
     6ba:	df 91       	pop	r29
     6bc:	cf 91       	pop	r28
     6be:	08 95       	ret

000006c0 <sIMU_readRegisterInt16>:
     6c0:	0f 93       	push	r16
     6c2:	1f 93       	push	r17
     6c4:	cf 93       	push	r28
     6c6:	df 93       	push	r29
     6c8:	1f 92       	push	r1
     6ca:	1f 92       	push	r1
     6cc:	cd b7       	in	r28, 0x3d	; 61
     6ce:	de b7       	in	r29, 0x3e	; 62
     6d0:	8c 01       	movw	r16, r24
     6d2:	42 e0       	ldi	r20, 0x02	; 2
     6d4:	ce 01       	movw	r24, r28
     6d6:	01 96       	adiw	r24, 0x01	; 1
     6d8:	58 df       	rcall	.-336    	; 0x58a <sIMU_readRegisterRegion>
     6da:	2a 81       	ldd	r18, Y+2	; 0x02
     6dc:	30 e0       	ldi	r19, 0x00	; 0
     6de:	32 2f       	mov	r19, r18
     6e0:	22 27       	eor	r18, r18
     6e2:	99 81       	ldd	r25, Y+1	; 0x01
     6e4:	29 2b       	or	r18, r25
     6e6:	f8 01       	movw	r30, r16
     6e8:	31 83       	std	Z+1, r19	; 0x01
     6ea:	20 83       	st	Z, r18
     6ec:	0f 90       	pop	r0
     6ee:	0f 90       	pop	r0
     6f0:	df 91       	pop	r29
     6f2:	cf 91       	pop	r28
     6f4:	1f 91       	pop	r17
     6f6:	0f 91       	pop	r16
     6f8:	08 95       	ret

000006fa <sIMU_writeRegister>:
     6fa:	cf 93       	push	r28
     6fc:	c6 2f       	mov	r28, r22
     6fe:	28 98       	cbi	0x05, 0	; 5
     700:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <ui8SPI_MasterTransmit>
     704:	8c 2f       	mov	r24, r28
     706:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <ui8SPI_MasterTransmit>
     70a:	28 9a       	sbi	0x05, 0	; 5
     70c:	80 e0       	ldi	r24, 0x00	; 0
     70e:	cf 91       	pop	r28
     710:	08 95       	ret

00000712 <sIMU_begin>:
     712:	1f 93       	push	r17
     714:	cf 93       	push	r28
     716:	df 93       	push	r29
     718:	1f 92       	push	r1
     71a:	1f 92       	push	r1
     71c:	cd b7       	in	r28, 0x3d	; 61
     71e:	de b7       	in	r29, 0x3e	; 62
     720:	19 82       	std	Y+1, r1	; 0x01
     722:	79 df       	rcall	.-270    	; 0x616 <sIMU_Init>
     724:	18 2f       	mov	r17, r24
     726:	19 82       	std	Y+1, r1	; 0x01
     728:	80 91 00 1b 	lds	r24, 0x1B00	; 0x801b00 <settings+0x9>
     72c:	81 30       	cpi	r24, 0x01	; 1
     72e:	09 f0       	breq	.+2      	; 0x732 <sIMU_begin+0x20>
     730:	83 c0       	rjmp	.+262    	; 0x838 <sIMU_begin+0x126>
     732:	80 91 06 1b 	lds	r24, 0x1B06	; 0x801b06 <settings+0xf>
     736:	90 91 07 1b 	lds	r25, 0x1B07	; 0x801b07 <settings+0x10>
     73a:	84 36       	cpi	r24, 0x64	; 100
     73c:	91 05       	cpc	r25, r1
     73e:	41 f0       	breq	.+16     	; 0x750 <sIMU_begin+0x3e>
     740:	88 3c       	cpi	r24, 0xC8	; 200
     742:	91 05       	cpc	r25, r1
     744:	41 f0       	breq	.+16     	; 0x756 <sIMU_begin+0x44>
     746:	c2 97       	sbiw	r24, 0x32	; 50
     748:	41 f4       	brne	.+16     	; 0x75a <sIMU_begin+0x48>
     74a:	83 e0       	ldi	r24, 0x03	; 3
     74c:	89 83       	std	Y+1, r24	; 0x01
     74e:	05 c0       	rjmp	.+10     	; 0x75a <sIMU_begin+0x48>
     750:	82 e0       	ldi	r24, 0x02	; 2
     752:	89 83       	std	Y+1, r24	; 0x01
     754:	02 c0       	rjmp	.+4      	; 0x75a <sIMU_begin+0x48>
     756:	81 e0       	ldi	r24, 0x01	; 1
     758:	89 83       	std	Y+1, r24	; 0x01
     75a:	80 91 02 1b 	lds	r24, 0x1B02	; 0x801b02 <settings+0xb>
     75e:	90 91 03 1b 	lds	r25, 0x1B03	; 0x801b03 <settings+0xc>
     762:	84 30       	cpi	r24, 0x04	; 4
     764:	91 05       	cpc	r25, r1
     766:	31 f0       	breq	.+12     	; 0x774 <sIMU_begin+0x62>
     768:	88 30       	cpi	r24, 0x08	; 8
     76a:	91 05       	cpc	r25, r1
     76c:	39 f0       	breq	.+14     	; 0x77c <sIMU_begin+0x6a>
     76e:	02 97       	sbiw	r24, 0x02	; 2
     770:	49 f4       	brne	.+18     	; 0x784 <sIMU_begin+0x72>
     772:	0b c0       	rjmp	.+22     	; 0x78a <sIMU_begin+0x78>
     774:	89 81       	ldd	r24, Y+1	; 0x01
     776:	88 60       	ori	r24, 0x08	; 8
     778:	89 83       	std	Y+1, r24	; 0x01
     77a:	07 c0       	rjmp	.+14     	; 0x78a <sIMU_begin+0x78>
     77c:	89 81       	ldd	r24, Y+1	; 0x01
     77e:	8c 60       	ori	r24, 0x0C	; 12
     780:	89 83       	std	Y+1, r24	; 0x01
     782:	03 c0       	rjmp	.+6      	; 0x78a <sIMU_begin+0x78>
     784:	89 81       	ldd	r24, Y+1	; 0x01
     786:	84 60       	ori	r24, 0x04	; 4
     788:	89 83       	std	Y+1, r24	; 0x01
     78a:	80 91 04 1b 	lds	r24, 0x1B04	; 0x801b04 <settings+0xd>
     78e:	90 91 05 1b 	lds	r25, 0x1B05	; 0x801b05 <settings+0xe>
     792:	80 3a       	cpi	r24, 0xA0	; 160
     794:	21 e0       	ldi	r18, 0x01	; 1
     796:	92 07       	cpc	r25, r18
     798:	c1 f1       	breq	.+112    	; 0x80a <sIMU_begin+0xf8>
     79a:	70 f4       	brcc	.+28     	; 0x7b8 <sIMU_begin+0xa6>
     79c:	8a 31       	cpi	r24, 0x1A	; 26
     79e:	91 05       	cpc	r25, r1
     7a0:	21 f1       	breq	.+72     	; 0x7ea <sIMU_begin+0xd8>
     7a2:	18 f4       	brcc	.+6      	; 0x7aa <sIMU_begin+0x98>
     7a4:	0d 97       	sbiw	r24, 0x0d	; 13
     7a6:	e9 f0       	breq	.+58     	; 0x7e2 <sIMU_begin+0xd0>
     7a8:	28 c0       	rjmp	.+80     	; 0x7fa <sIMU_begin+0xe8>
     7aa:	84 33       	cpi	r24, 0x34	; 52
     7ac:	91 05       	cpc	r25, r1
     7ae:	09 f1       	breq	.+66     	; 0x7f2 <sIMU_begin+0xe0>
     7b0:	80 3d       	cpi	r24, 0xD0	; 208
     7b2:	91 05       	cpc	r25, r1
     7b4:	31 f1       	breq	.+76     	; 0x802 <sIMU_begin+0xf0>
     7b6:	21 c0       	rjmp	.+66     	; 0x7fa <sIMU_begin+0xe8>
     7b8:	82 30       	cpi	r24, 0x02	; 2
     7ba:	2d e0       	ldi	r18, 0x0D	; 13
     7bc:	92 07       	cpc	r25, r18
     7be:	89 f1       	breq	.+98     	; 0x822 <sIMU_begin+0x110>
     7c0:	40 f4       	brcc	.+16     	; 0x7d2 <sIMU_begin+0xc0>
     7c2:	81 34       	cpi	r24, 0x41	; 65
     7c4:	23 e0       	ldi	r18, 0x03	; 3
     7c6:	92 07       	cpc	r25, r18
     7c8:	21 f1       	breq	.+72     	; 0x812 <sIMU_begin+0x100>
     7ca:	8c 37       	cpi	r24, 0x7C	; 124
     7cc:	96 40       	sbci	r25, 0x06	; 6
     7ce:	29 f1       	breq	.+74     	; 0x81a <sIMU_begin+0x108>
     7d0:	14 c0       	rjmp	.+40     	; 0x7fa <sIMU_begin+0xe8>
     7d2:	84 30       	cpi	r24, 0x04	; 4
     7d4:	2a e1       	ldi	r18, 0x1A	; 26
     7d6:	92 07       	cpc	r25, r18
     7d8:	41 f1       	breq	.+80     	; 0x82a <sIMU_begin+0x118>
     7da:	82 31       	cpi	r24, 0x12	; 18
     7dc:	94 43       	sbci	r25, 0x34	; 52
     7de:	49 f1       	breq	.+82     	; 0x832 <sIMU_begin+0x120>
     7e0:	0c c0       	rjmp	.+24     	; 0x7fa <sIMU_begin+0xe8>
     7e2:	89 81       	ldd	r24, Y+1	; 0x01
     7e4:	80 61       	ori	r24, 0x10	; 16
     7e6:	89 83       	std	Y+1, r24	; 0x01
     7e8:	27 c0       	rjmp	.+78     	; 0x838 <sIMU_begin+0x126>
     7ea:	89 81       	ldd	r24, Y+1	; 0x01
     7ec:	80 62       	ori	r24, 0x20	; 32
     7ee:	89 83       	std	Y+1, r24	; 0x01
     7f0:	23 c0       	rjmp	.+70     	; 0x838 <sIMU_begin+0x126>
     7f2:	89 81       	ldd	r24, Y+1	; 0x01
     7f4:	80 63       	ori	r24, 0x30	; 48
     7f6:	89 83       	std	Y+1, r24	; 0x01
     7f8:	1f c0       	rjmp	.+62     	; 0x838 <sIMU_begin+0x126>
     7fa:	89 81       	ldd	r24, Y+1	; 0x01
     7fc:	80 64       	ori	r24, 0x40	; 64
     7fe:	89 83       	std	Y+1, r24	; 0x01
     800:	1b c0       	rjmp	.+54     	; 0x838 <sIMU_begin+0x126>
     802:	89 81       	ldd	r24, Y+1	; 0x01
     804:	80 65       	ori	r24, 0x50	; 80
     806:	89 83       	std	Y+1, r24	; 0x01
     808:	17 c0       	rjmp	.+46     	; 0x838 <sIMU_begin+0x126>
     80a:	89 81       	ldd	r24, Y+1	; 0x01
     80c:	80 66       	ori	r24, 0x60	; 96
     80e:	89 83       	std	Y+1, r24	; 0x01
     810:	13 c0       	rjmp	.+38     	; 0x838 <sIMU_begin+0x126>
     812:	89 81       	ldd	r24, Y+1	; 0x01
     814:	80 67       	ori	r24, 0x70	; 112
     816:	89 83       	std	Y+1, r24	; 0x01
     818:	0f c0       	rjmp	.+30     	; 0x838 <sIMU_begin+0x126>
     81a:	89 81       	ldd	r24, Y+1	; 0x01
     81c:	80 68       	ori	r24, 0x80	; 128
     81e:	89 83       	std	Y+1, r24	; 0x01
     820:	0b c0       	rjmp	.+22     	; 0x838 <sIMU_begin+0x126>
     822:	89 81       	ldd	r24, Y+1	; 0x01
     824:	80 69       	ori	r24, 0x90	; 144
     826:	89 83       	std	Y+1, r24	; 0x01
     828:	07 c0       	rjmp	.+14     	; 0x838 <sIMU_begin+0x126>
     82a:	89 81       	ldd	r24, Y+1	; 0x01
     82c:	80 6a       	ori	r24, 0xA0	; 160
     82e:	89 83       	std	Y+1, r24	; 0x01
     830:	03 c0       	rjmp	.+6      	; 0x838 <sIMU_begin+0x126>
     832:	89 81       	ldd	r24, Y+1	; 0x01
     834:	80 6b       	ori	r24, 0xB0	; 176
     836:	89 83       	std	Y+1, r24	; 0x01
     838:	69 81       	ldd	r22, Y+1	; 0x01
     83a:	80 e1       	ldi	r24, 0x10	; 16
     83c:	5e df       	rcall	.-324    	; 0x6fa <sIMU_writeRegister>
     83e:	63 e1       	ldi	r22, 0x13	; 19
     840:	ce 01       	movw	r24, r28
     842:	01 96       	adiw	r24, 0x01	; 1
     844:	d2 de       	rcall	.-604    	; 0x5ea <sIMU_readRegister>
     846:	99 81       	ldd	r25, Y+1	; 0x01
     848:	9f 77       	andi	r25, 0x7F	; 127
     84a:	99 83       	std	Y+1, r25	; 0x01
     84c:	80 91 01 1b 	lds	r24, 0x1B01	; 0x801b01 <settings+0xa>
     850:	81 30       	cpi	r24, 0x01	; 1
     852:	11 f4       	brne	.+4      	; 0x858 <sIMU_begin+0x146>
     854:	90 68       	ori	r25, 0x80	; 128
     856:	99 83       	std	Y+1, r25	; 0x01
     858:	69 81       	ldd	r22, Y+1	; 0x01
     85a:	83 e1       	ldi	r24, 0x13	; 19
     85c:	4e df       	rcall	.-356    	; 0x6fa <sIMU_writeRegister>
     85e:	19 82       	std	Y+1, r1	; 0x01
     860:	80 91 f7 1a 	lds	r24, 0x1AF7	; 0x801af7 <settings>
     864:	81 30       	cpi	r24, 0x01	; 1
     866:	09 f0       	breq	.+2      	; 0x86a <sIMU_begin+0x158>
     868:	5b c0       	rjmp	.+182    	; 0x920 <sIMU_begin+0x20e>
     86a:	80 91 f8 1a 	lds	r24, 0x1AF8	; 0x801af8 <settings+0x1>
     86e:	90 91 f9 1a 	lds	r25, 0x1AF9	; 0x801af9 <settings+0x2>
     872:	85 3f       	cpi	r24, 0xF5	; 245
     874:	91 05       	cpc	r25, r1
     876:	c1 f0       	breq	.+48     	; 0x8a8 <sIMU_begin+0x196>
     878:	20 f4       	brcc	.+8      	; 0x882 <sIMU_begin+0x170>
     87a:	8d 37       	cpi	r24, 0x7D	; 125
     87c:	91 05       	cpc	r25, r1
     87e:	49 f0       	breq	.+18     	; 0x892 <sIMU_begin+0x180>
     880:	11 c0       	rjmp	.+34     	; 0x8a4 <sIMU_begin+0x192>
     882:	84 3f       	cpi	r24, 0xF4	; 244
     884:	21 e0       	ldi	r18, 0x01	; 1
     886:	92 07       	cpc	r25, r18
     888:	39 f0       	breq	.+14     	; 0x898 <sIMU_begin+0x186>
     88a:	88 3e       	cpi	r24, 0xE8	; 232
     88c:	93 40       	sbci	r25, 0x03	; 3
     88e:	39 f0       	breq	.+14     	; 0x89e <sIMU_begin+0x18c>
     890:	09 c0       	rjmp	.+18     	; 0x8a4 <sIMU_begin+0x192>
     892:	82 e0       	ldi	r24, 0x02	; 2
     894:	89 83       	std	Y+1, r24	; 0x01
     896:	08 c0       	rjmp	.+16     	; 0x8a8 <sIMU_begin+0x196>
     898:	84 e0       	ldi	r24, 0x04	; 4
     89a:	89 83       	std	Y+1, r24	; 0x01
     89c:	05 c0       	rjmp	.+10     	; 0x8a8 <sIMU_begin+0x196>
     89e:	88 e0       	ldi	r24, 0x08	; 8
     8a0:	89 83       	std	Y+1, r24	; 0x01
     8a2:	02 c0       	rjmp	.+4      	; 0x8a8 <sIMU_begin+0x196>
     8a4:	8c e0       	ldi	r24, 0x0C	; 12
     8a6:	89 83       	std	Y+1, r24	; 0x01
     8a8:	80 91 fa 1a 	lds	r24, 0x1AFA	; 0x801afa <settings+0x3>
     8ac:	90 91 fb 1a 	lds	r25, 0x1AFB	; 0x801afb <settings+0x4>
     8b0:	80 3d       	cpi	r24, 0xD0	; 208
     8b2:	91 05       	cpc	r25, r1
     8b4:	31 f1       	breq	.+76     	; 0x902 <sIMU_begin+0x1f0>
     8b6:	48 f4       	brcc	.+18     	; 0x8ca <sIMU_begin+0x1b8>
     8b8:	8a 31       	cpi	r24, 0x1A	; 26
     8ba:	91 05       	cpc	r25, r1
     8bc:	b1 f0       	breq	.+44     	; 0x8ea <sIMU_begin+0x1d8>
     8be:	84 33       	cpi	r24, 0x34	; 52
     8c0:	91 05       	cpc	r25, r1
     8c2:	b9 f0       	breq	.+46     	; 0x8f2 <sIMU_begin+0x1e0>
     8c4:	0d 97       	sbiw	r24, 0x0d	; 13
     8c6:	c9 f4       	brne	.+50     	; 0x8fa <sIMU_begin+0x1e8>
     8c8:	0c c0       	rjmp	.+24     	; 0x8e2 <sIMU_begin+0x1d0>
     8ca:	81 34       	cpi	r24, 0x41	; 65
     8cc:	23 e0       	ldi	r18, 0x03	; 3
     8ce:	92 07       	cpc	r25, r18
     8d0:	01 f1       	breq	.+64     	; 0x912 <sIMU_begin+0x200>
     8d2:	8c 37       	cpi	r24, 0x7C	; 124
     8d4:	26 e0       	ldi	r18, 0x06	; 6
     8d6:	92 07       	cpc	r25, r18
     8d8:	01 f1       	breq	.+64     	; 0x91a <sIMU_begin+0x208>
     8da:	80 3a       	cpi	r24, 0xA0	; 160
     8dc:	91 40       	sbci	r25, 0x01	; 1
     8de:	69 f4       	brne	.+26     	; 0x8fa <sIMU_begin+0x1e8>
     8e0:	14 c0       	rjmp	.+40     	; 0x90a <sIMU_begin+0x1f8>
     8e2:	89 81       	ldd	r24, Y+1	; 0x01
     8e4:	80 61       	ori	r24, 0x10	; 16
     8e6:	89 83       	std	Y+1, r24	; 0x01
     8e8:	1b c0       	rjmp	.+54     	; 0x920 <sIMU_begin+0x20e>
     8ea:	89 81       	ldd	r24, Y+1	; 0x01
     8ec:	80 62       	ori	r24, 0x20	; 32
     8ee:	89 83       	std	Y+1, r24	; 0x01
     8f0:	17 c0       	rjmp	.+46     	; 0x920 <sIMU_begin+0x20e>
     8f2:	89 81       	ldd	r24, Y+1	; 0x01
     8f4:	80 63       	ori	r24, 0x30	; 48
     8f6:	89 83       	std	Y+1, r24	; 0x01
     8f8:	13 c0       	rjmp	.+38     	; 0x920 <sIMU_begin+0x20e>
     8fa:	89 81       	ldd	r24, Y+1	; 0x01
     8fc:	80 64       	ori	r24, 0x40	; 64
     8fe:	89 83       	std	Y+1, r24	; 0x01
     900:	0f c0       	rjmp	.+30     	; 0x920 <sIMU_begin+0x20e>
     902:	89 81       	ldd	r24, Y+1	; 0x01
     904:	80 65       	ori	r24, 0x50	; 80
     906:	89 83       	std	Y+1, r24	; 0x01
     908:	0b c0       	rjmp	.+22     	; 0x920 <sIMU_begin+0x20e>
     90a:	89 81       	ldd	r24, Y+1	; 0x01
     90c:	80 66       	ori	r24, 0x60	; 96
     90e:	89 83       	std	Y+1, r24	; 0x01
     910:	07 c0       	rjmp	.+14     	; 0x920 <sIMU_begin+0x20e>
     912:	89 81       	ldd	r24, Y+1	; 0x01
     914:	80 67       	ori	r24, 0x70	; 112
     916:	89 83       	std	Y+1, r24	; 0x01
     918:	03 c0       	rjmp	.+6      	; 0x920 <sIMU_begin+0x20e>
     91a:	89 81       	ldd	r24, Y+1	; 0x01
     91c:	80 68       	ori	r24, 0x80	; 128
     91e:	89 83       	std	Y+1, r24	; 0x01
     920:	69 81       	ldd	r22, Y+1	; 0x01
     922:	81 e1       	ldi	r24, 0x11	; 17
     924:	ea de       	rcall	.-556    	; 0x6fa <sIMU_writeRegister>
     926:	6f e0       	ldi	r22, 0x0F	; 15
     928:	ce 01       	movw	r24, r28
     92a:	02 96       	adiw	r24, 0x02	; 2
     92c:	5e de       	rcall	.-836    	; 0x5ea <sIMU_readRegister>
     92e:	81 2f       	mov	r24, r17
     930:	0f 90       	pop	r0
     932:	0f 90       	pop	r0
     934:	df 91       	pop	r29
     936:	cf 91       	pop	r28
     938:	1f 91       	pop	r17
     93a:	08 95       	ret

0000093c <i16IMU_readRawAccelY>:
     93c:	cf 93       	push	r28
     93e:	df 93       	push	r29
     940:	1f 92       	push	r1
     942:	1f 92       	push	r1
     944:	cd b7       	in	r28, 0x3d	; 61
     946:	de b7       	in	r29, 0x3e	; 62
     948:	6a e2       	ldi	r22, 0x2A	; 42
     94a:	ce 01       	movw	r24, r28
     94c:	01 96       	adiw	r24, 0x01	; 1
     94e:	b8 de       	rcall	.-656    	; 0x6c0 <sIMU_readRegisterInt16>
     950:	88 23       	and	r24, r24
     952:	a9 f0       	breq	.+42     	; 0x97e <i16IMU_readRawAccelY+0x42>
     954:	85 30       	cpi	r24, 0x05	; 5
     956:	51 f4       	brne	.+20     	; 0x96c <i16IMU_readRawAccelY+0x30>
     958:	80 91 11 1b 	lds	r24, 0x1B11	; 0x801b11 <allOnesCounter>
     95c:	90 91 12 1b 	lds	r25, 0x1B12	; 0x801b12 <allOnesCounter+0x1>
     960:	01 96       	adiw	r24, 0x01	; 1
     962:	90 93 12 1b 	sts	0x1B12, r25	; 0x801b12 <allOnesCounter+0x1>
     966:	80 93 11 1b 	sts	0x1B11, r24	; 0x801b11 <allOnesCounter>
     96a:	09 c0       	rjmp	.+18     	; 0x97e <i16IMU_readRawAccelY+0x42>
     96c:	80 91 13 1b 	lds	r24, 0x1B13	; 0x801b13 <nonSuccessCounter>
     970:	90 91 14 1b 	lds	r25, 0x1B14	; 0x801b14 <nonSuccessCounter+0x1>
     974:	01 96       	adiw	r24, 0x01	; 1
     976:	90 93 14 1b 	sts	0x1B14, r25	; 0x801b14 <nonSuccessCounter+0x1>
     97a:	80 93 13 1b 	sts	0x1B13, r24	; 0x801b13 <nonSuccessCounter>
     97e:	89 81       	ldd	r24, Y+1	; 0x01
     980:	9a 81       	ldd	r25, Y+2	; 0x02
     982:	0f 90       	pop	r0
     984:	0f 90       	pop	r0
     986:	df 91       	pop	r29
     988:	cf 91       	pop	r28
     98a:	08 95       	ret

0000098c <fIMU_calcAccel>:
     98c:	cf 92       	push	r12
     98e:	df 92       	push	r13
     990:	ef 92       	push	r14
     992:	ff 92       	push	r15
     994:	bc 01       	movw	r22, r24
     996:	99 0f       	add	r25, r25
     998:	88 0b       	sbc	r24, r24
     99a:	99 0b       	sbc	r25, r25
     99c:	0e 94 78 28 	call	0x50f0	; 0x50f0 <__floatsisf>
     9a0:	23 e2       	ldi	r18, 0x23	; 35
     9a2:	3b ed       	ldi	r19, 0xDB	; 219
     9a4:	49 e7       	ldi	r20, 0x79	; 121
     9a6:	5d e3       	ldi	r21, 0x3D	; 61
     9a8:	0e 94 91 29 	call	0x5322	; 0x5322 <__mulsf3>
     9ac:	6b 01       	movw	r12, r22
     9ae:	7c 01       	movw	r14, r24
     9b0:	80 91 02 1b 	lds	r24, 0x1B02	; 0x801b02 <settings+0xb>
     9b4:	90 91 03 1b 	lds	r25, 0x1B03	; 0x801b03 <settings+0xc>
     9b8:	96 95       	lsr	r25
     9ba:	87 95       	ror	r24
     9bc:	bc 01       	movw	r22, r24
     9be:	80 e0       	ldi	r24, 0x00	; 0
     9c0:	90 e0       	ldi	r25, 0x00	; 0
     9c2:	0e 94 76 28 	call	0x50ec	; 0x50ec <__floatunsisf>
     9c6:	9b 01       	movw	r18, r22
     9c8:	ac 01       	movw	r20, r24
     9ca:	c7 01       	movw	r24, r14
     9cc:	b6 01       	movw	r22, r12
     9ce:	0e 94 91 29 	call	0x5322	; 0x5322 <__mulsf3>
     9d2:	20 e0       	ldi	r18, 0x00	; 0
     9d4:	30 e0       	ldi	r19, 0x00	; 0
     9d6:	4a e7       	ldi	r20, 0x7A	; 122
     9d8:	54 e4       	ldi	r21, 0x44	; 68
     9da:	0e 94 dd 27 	call	0x4fba	; 0x4fba <__divsf3>
     9de:	ff 90       	pop	r15
     9e0:	ef 90       	pop	r14
     9e2:	df 90       	pop	r13
     9e4:	cf 90       	pop	r12
     9e6:	08 95       	ret

000009e8 <fIMU_readFloatAccelY>:
     9e8:	a9 df       	rcall	.-174    	; 0x93c <i16IMU_readRawAccelY>
     9ea:	d0 cf       	rjmp	.-96     	; 0x98c <fIMU_calcAccel>
     9ec:	08 95       	ret

000009ee <i16IMU_readRawGyroX>:
     9ee:	cf 93       	push	r28
     9f0:	df 93       	push	r29
     9f2:	1f 92       	push	r1
     9f4:	1f 92       	push	r1
     9f6:	cd b7       	in	r28, 0x3d	; 61
     9f8:	de b7       	in	r29, 0x3e	; 62
     9fa:	62 e2       	ldi	r22, 0x22	; 34
     9fc:	ce 01       	movw	r24, r28
     9fe:	01 96       	adiw	r24, 0x01	; 1
     a00:	5f de       	rcall	.-834    	; 0x6c0 <sIMU_readRegisterInt16>
     a02:	88 23       	and	r24, r24
     a04:	a9 f0       	breq	.+42     	; 0xa30 <i16IMU_readRawGyroX+0x42>
     a06:	85 30       	cpi	r24, 0x05	; 5
     a08:	51 f4       	brne	.+20     	; 0xa1e <i16IMU_readRawGyroX+0x30>
     a0a:	80 91 11 1b 	lds	r24, 0x1B11	; 0x801b11 <allOnesCounter>
     a0e:	90 91 12 1b 	lds	r25, 0x1B12	; 0x801b12 <allOnesCounter+0x1>
     a12:	01 96       	adiw	r24, 0x01	; 1
     a14:	90 93 12 1b 	sts	0x1B12, r25	; 0x801b12 <allOnesCounter+0x1>
     a18:	80 93 11 1b 	sts	0x1B11, r24	; 0x801b11 <allOnesCounter>
     a1c:	09 c0       	rjmp	.+18     	; 0xa30 <i16IMU_readRawGyroX+0x42>
     a1e:	80 91 13 1b 	lds	r24, 0x1B13	; 0x801b13 <nonSuccessCounter>
     a22:	90 91 14 1b 	lds	r25, 0x1B14	; 0x801b14 <nonSuccessCounter+0x1>
     a26:	01 96       	adiw	r24, 0x01	; 1
     a28:	90 93 14 1b 	sts	0x1B14, r25	; 0x801b14 <nonSuccessCounter+0x1>
     a2c:	80 93 13 1b 	sts	0x1B13, r24	; 0x801b13 <nonSuccessCounter>
     a30:	89 81       	ldd	r24, Y+1	; 0x01
     a32:	9a 81       	ldd	r25, Y+2	; 0x02
     a34:	0f 90       	pop	r0
     a36:	0f 90       	pop	r0
     a38:	df 91       	pop	r29
     a3a:	cf 91       	pop	r28
     a3c:	08 95       	ret

00000a3e <i16IMU_readRawGyroZ>:
     a3e:	cf 93       	push	r28
     a40:	df 93       	push	r29
     a42:	1f 92       	push	r1
     a44:	1f 92       	push	r1
     a46:	cd b7       	in	r28, 0x3d	; 61
     a48:	de b7       	in	r29, 0x3e	; 62
     a4a:	66 e2       	ldi	r22, 0x26	; 38
     a4c:	ce 01       	movw	r24, r28
     a4e:	01 96       	adiw	r24, 0x01	; 1
     a50:	37 de       	rcall	.-914    	; 0x6c0 <sIMU_readRegisterInt16>
     a52:	88 23       	and	r24, r24
     a54:	a9 f0       	breq	.+42     	; 0xa80 <i16IMU_readRawGyroZ+0x42>
     a56:	85 30       	cpi	r24, 0x05	; 5
     a58:	51 f4       	brne	.+20     	; 0xa6e <i16IMU_readRawGyroZ+0x30>
     a5a:	80 91 11 1b 	lds	r24, 0x1B11	; 0x801b11 <allOnesCounter>
     a5e:	90 91 12 1b 	lds	r25, 0x1B12	; 0x801b12 <allOnesCounter+0x1>
     a62:	01 96       	adiw	r24, 0x01	; 1
     a64:	90 93 12 1b 	sts	0x1B12, r25	; 0x801b12 <allOnesCounter+0x1>
     a68:	80 93 11 1b 	sts	0x1B11, r24	; 0x801b11 <allOnesCounter>
     a6c:	09 c0       	rjmp	.+18     	; 0xa80 <i16IMU_readRawGyroZ+0x42>
     a6e:	80 91 13 1b 	lds	r24, 0x1B13	; 0x801b13 <nonSuccessCounter>
     a72:	90 91 14 1b 	lds	r25, 0x1B14	; 0x801b14 <nonSuccessCounter+0x1>
     a76:	01 96       	adiw	r24, 0x01	; 1
     a78:	90 93 14 1b 	sts	0x1B14, r25	; 0x801b14 <nonSuccessCounter+0x1>
     a7c:	80 93 13 1b 	sts	0x1B13, r24	; 0x801b13 <nonSuccessCounter>
     a80:	89 81       	ldd	r24, Y+1	; 0x01
     a82:	9a 81       	ldd	r25, Y+2	; 0x02
     a84:	0f 90       	pop	r0
     a86:	0f 90       	pop	r0
     a88:	df 91       	pop	r29
     a8a:	cf 91       	pop	r28
     a8c:	08 95       	ret

00000a8e <fIMU_calcGyro>:
     a8e:	cf 92       	push	r12
     a90:	df 92       	push	r13
     a92:	ef 92       	push	r14
     a94:	ff 92       	push	r15
     a96:	cf 93       	push	r28
     a98:	fc 01       	movw	r30, r24
     a9a:	40 91 f8 1a 	lds	r20, 0x1AF8	; 0x801af8 <settings+0x1>
     a9e:	50 91 f9 1a 	lds	r21, 0x1AF9	; 0x801af9 <settings+0x2>
     aa2:	45 3f       	cpi	r20, 0xF5	; 245
     aa4:	51 05       	cpc	r21, r1
     aa6:	b1 f0       	breq	.+44     	; 0xad4 <fIMU_calcGyro+0x46>
     aa8:	9a 01       	movw	r18, r20
     aaa:	a5 e2       	ldi	r26, 0x25	; 37
     aac:	b6 e0       	ldi	r27, 0x06	; 6
     aae:	0e 94 08 2e 	call	0x5c10	; 0x5c10 <__umulhisi3>
     ab2:	48 1b       	sub	r20, r24
     ab4:	59 0b       	sbc	r21, r25
     ab6:	56 95       	lsr	r21
     ab8:	47 95       	ror	r20
     aba:	48 0f       	add	r20, r24
     abc:	59 1f       	adc	r21, r25
     abe:	00 24       	eor	r0, r0
     ac0:	44 0f       	add	r20, r20
     ac2:	55 1f       	adc	r21, r21
     ac4:	00 1c       	adc	r0, r0
     ac6:	44 0f       	add	r20, r20
     ac8:	55 1f       	adc	r21, r21
     aca:	00 1c       	adc	r0, r0
     acc:	45 2f       	mov	r20, r21
     ace:	50 2d       	mov	r21, r0
     ad0:	c4 2f       	mov	r28, r20
     ad2:	01 c0       	rjmp	.+2      	; 0xad6 <fIMU_calcGyro+0x48>
     ad4:	c2 e0       	ldi	r28, 0x02	; 2
     ad6:	bf 01       	movw	r22, r30
     ad8:	ff 0f       	add	r31, r31
     ada:	88 0b       	sbc	r24, r24
     adc:	99 0b       	sbc	r25, r25
     ade:	0e 94 78 28 	call	0x50f0	; 0x50f0 <__floatsisf>
     ae2:	20 e0       	ldi	r18, 0x00	; 0
     ae4:	30 e0       	ldi	r19, 0x00	; 0
     ae6:	4c e8       	ldi	r20, 0x8C	; 140
     ae8:	50 e4       	ldi	r21, 0x40	; 64
     aea:	0e 94 91 29 	call	0x5322	; 0x5322 <__mulsf3>
     aee:	6b 01       	movw	r12, r22
     af0:	7c 01       	movw	r14, r24
     af2:	6c 2f       	mov	r22, r28
     af4:	70 e0       	ldi	r23, 0x00	; 0
     af6:	80 e0       	ldi	r24, 0x00	; 0
     af8:	90 e0       	ldi	r25, 0x00	; 0
     afa:	0e 94 78 28 	call	0x50f0	; 0x50f0 <__floatsisf>
     afe:	9b 01       	movw	r18, r22
     b00:	ac 01       	movw	r20, r24
     b02:	c7 01       	movw	r24, r14
     b04:	b6 01       	movw	r22, r12
     b06:	0e 94 91 29 	call	0x5322	; 0x5322 <__mulsf3>
     b0a:	20 e0       	ldi	r18, 0x00	; 0
     b0c:	30 e0       	ldi	r19, 0x00	; 0
     b0e:	4a e7       	ldi	r20, 0x7A	; 122
     b10:	54 e4       	ldi	r21, 0x44	; 68
     b12:	0e 94 dd 27 	call	0x4fba	; 0x4fba <__divsf3>
     b16:	cf 91       	pop	r28
     b18:	ff 90       	pop	r15
     b1a:	ef 90       	pop	r14
     b1c:	df 90       	pop	r13
     b1e:	cf 90       	pop	r12
     b20:	08 95       	ret

00000b22 <fIMU_readFloatGyroX>:
     b22:	65 df       	rcall	.-310    	; 0x9ee <i16IMU_readRawGyroX>
     b24:	b4 cf       	rjmp	.-152    	; 0xa8e <fIMU_calcGyro>
     b26:	08 95       	ret

00000b28 <fIMU_readFloatGyroZ>:
    }
    
    return output;
}
float fIMU_readFloatGyroZ(){
    float output = fIMU_calcGyro(i16IMU_readRawGyroZ());
     b28:	8a df       	rcall	.-236    	; 0xa3e <i16IMU_readRawGyroZ>
     b2a:	b1 cf       	rjmp	.-158    	; 0xa8e <fIMU_calcGyro>
    
    return output;
}
     b2c:	08 95       	ret

00000b2e <vLED_init>:
/*  Custom includes    */
#include "LED.h"

/* Initialize LEDport pins as output */
void vLED_init(){
	ledReg |= (1<<ledGREEN) | (1<<ledYELLOW) | (1<<ledRED);
     b2e:	ea e0       	ldi	r30, 0x0A	; 10
     b30:	f1 e0       	ldi	r31, 0x01	; 1
     b32:	80 81       	ld	r24, Z
     b34:	87 60       	ori	r24, 0x07	; 7
     b36:	80 83       	st	Z, r24
     b38:	08 95       	ret

00000b3a <vLED_singleHigh>:
}

/* Set a specific, single LED high */
void vLED_singleHigh(int ledCOLOR){
	if (ledCOLOR == ledGREEN)			ledPORT |= (1<<ledGREEN);
     b3a:	82 30       	cpi	r24, 0x02	; 2
     b3c:	91 05       	cpc	r25, r1
     b3e:	31 f4       	brne	.+12     	; 0xb4c <vLED_singleHigh+0x12>
     b40:	eb e0       	ldi	r30, 0x0B	; 11
     b42:	f1 e0       	ldi	r31, 0x01	; 1
     b44:	80 81       	ld	r24, Z
     b46:	84 60       	ori	r24, 0x04	; 4
     b48:	80 83       	st	Z, r24
     b4a:	08 95       	ret
	else if (ledCOLOR == ledYELLOW)		ledPORT |= (1<<ledYELLOW);
     b4c:	81 30       	cpi	r24, 0x01	; 1
     b4e:	91 05       	cpc	r25, r1
     b50:	31 f4       	brne	.+12     	; 0xb5e <vLED_singleHigh+0x24>
     b52:	eb e0       	ldi	r30, 0x0B	; 11
     b54:	f1 e0       	ldi	r31, 0x01	; 1
     b56:	80 81       	ld	r24, Z
     b58:	82 60       	ori	r24, 0x02	; 2
     b5a:	80 83       	st	Z, r24
     b5c:	08 95       	ret
	else if (ledCOLOR == ledRED)		ledPORT |= (1<<ledRED);
     b5e:	89 2b       	or	r24, r25
     b60:	29 f4       	brne	.+10     	; 0xb6c <vLED_singleHigh+0x32>
     b62:	eb e0       	ldi	r30, 0x0B	; 11
     b64:	f1 e0       	ldi	r31, 0x01	; 1
     b66:	80 81       	ld	r24, Z
     b68:	81 60       	ori	r24, 0x01	; 1
     b6a:	80 83       	st	Z, r24
     b6c:	08 95       	ret

00000b6e <vLED_singleLow>:
}

/* Set a specific, single LED low */
void vLED_singleLow(int ledCOLOR){
    if (ledCOLOR == ledGREEN)			ledPORT &= ~(1<<ledGREEN);
     b6e:	82 30       	cpi	r24, 0x02	; 2
     b70:	91 05       	cpc	r25, r1
     b72:	31 f4       	brne	.+12     	; 0xb80 <vLED_singleLow+0x12>
     b74:	eb e0       	ldi	r30, 0x0B	; 11
     b76:	f1 e0       	ldi	r31, 0x01	; 1
     b78:	80 81       	ld	r24, Z
     b7a:	8b 7f       	andi	r24, 0xFB	; 251
     b7c:	80 83       	st	Z, r24
     b7e:	08 95       	ret
    else if (ledCOLOR == ledYELLOW)		ledPORT &= ~(1<<ledYELLOW);
     b80:	81 30       	cpi	r24, 0x01	; 1
     b82:	91 05       	cpc	r25, r1
     b84:	31 f4       	brne	.+12     	; 0xb92 <vLED_singleLow+0x24>
     b86:	eb e0       	ldi	r30, 0x0B	; 11
     b88:	f1 e0       	ldi	r31, 0x01	; 1
     b8a:	80 81       	ld	r24, Z
     b8c:	8d 7f       	andi	r24, 0xFD	; 253
     b8e:	80 83       	st	Z, r24
     b90:	08 95       	ret
    else if (ledCOLOR == ledRED)		ledPORT &= ~(1<<ledRED);
     b92:	89 2b       	or	r24, r25
     b94:	29 f4       	brne	.+10     	; 0xba0 <vLED_singleLow+0x32>
     b96:	eb e0       	ldi	r30, 0x0B	; 11
     b98:	f1 e0       	ldi	r31, 0x01	; 1
     b9a:	80 81       	ld	r24, Z
     b9c:	8e 7f       	andi	r24, 0xFE	; 254
     b9e:	80 83       	st	Z, r24
     ba0:	08 95       	ret

00000ba2 <vLED_toggle>:
}

/* Toggle a single LED */
void vLED_toggle(int ledCOLOR){
	if (ledCOLOR == ledGREEN)		ledPORT ^= (1<<ledGREEN);
     ba2:	82 30       	cpi	r24, 0x02	; 2
     ba4:	91 05       	cpc	r25, r1
     ba6:	39 f4       	brne	.+14     	; 0xbb6 <vLED_toggle+0x14>
     ba8:	eb e0       	ldi	r30, 0x0B	; 11
     baa:	f1 e0       	ldi	r31, 0x01	; 1
     bac:	90 81       	ld	r25, Z
     bae:	84 e0       	ldi	r24, 0x04	; 4
     bb0:	89 27       	eor	r24, r25
     bb2:	80 83       	st	Z, r24
     bb4:	08 95       	ret
	else if (ledCOLOR == ledYELLOW)	ledPORT ^= (1<<ledYELLOW);
     bb6:	81 30       	cpi	r24, 0x01	; 1
     bb8:	91 05       	cpc	r25, r1
     bba:	39 f4       	brne	.+14     	; 0xbca <vLED_toggle+0x28>
     bbc:	eb e0       	ldi	r30, 0x0B	; 11
     bbe:	f1 e0       	ldi	r31, 0x01	; 1
     bc0:	90 81       	ld	r25, Z
     bc2:	82 e0       	ldi	r24, 0x02	; 2
     bc4:	89 27       	eor	r24, r25
     bc6:	80 83       	st	Z, r24
     bc8:	08 95       	ret
	else if (ledCOLOR == ledRED)		ledPORT ^= (1<<ledRED);
     bca:	89 2b       	or	r24, r25
     bcc:	31 f4       	brne	.+12     	; 0xbda <vLED_toggle+0x38>
     bce:	eb e0       	ldi	r30, 0x0B	; 11
     bd0:	f1 e0       	ldi	r31, 0x01	; 1
     bd2:	90 81       	ld	r25, Z
     bd4:	81 e0       	ldi	r24, 0x01	; 1
     bd6:	89 27       	eor	r24, r25
     bd8:	80 83       	st	Z, r24
     bda:	08 95       	ret

00000bdc <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     bdc:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     bde:	03 96       	adiw	r24, 0x03	; 3
     be0:	92 83       	std	Z+2, r25	; 0x02
     be2:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     be4:	2f ef       	ldi	r18, 0xFF	; 255
     be6:	3f ef       	ldi	r19, 0xFF	; 255
     be8:	34 83       	std	Z+4, r19	; 0x04
     bea:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     bec:	96 83       	std	Z+6, r25	; 0x06
     bee:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     bf0:	90 87       	std	Z+8, r25	; 0x08
     bf2:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     bf4:	10 82       	st	Z, r1
     bf6:	08 95       	ret

00000bf8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     bf8:	fc 01       	movw	r30, r24
     bfa:	11 86       	std	Z+9, r1	; 0x09
     bfc:	10 86       	std	Z+8, r1	; 0x08
     bfe:	08 95       	ret

00000c00 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     c00:	cf 93       	push	r28
     c02:	df 93       	push	r29
     c04:	9c 01       	movw	r18, r24
     c06:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     c08:	dc 01       	movw	r26, r24
     c0a:	11 96       	adiw	r26, 0x01	; 1
     c0c:	cd 91       	ld	r28, X+
     c0e:	dc 91       	ld	r29, X
     c10:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     c12:	d3 83       	std	Z+3, r29	; 0x03
     c14:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     c16:	8c 81       	ldd	r24, Y+4	; 0x04
     c18:	9d 81       	ldd	r25, Y+5	; 0x05
     c1a:	95 83       	std	Z+5, r25	; 0x05
     c1c:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     c1e:	8c 81       	ldd	r24, Y+4	; 0x04
     c20:	9d 81       	ldd	r25, Y+5	; 0x05
     c22:	dc 01       	movw	r26, r24
     c24:	13 96       	adiw	r26, 0x03	; 3
     c26:	7c 93       	st	X, r23
     c28:	6e 93       	st	-X, r22
     c2a:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     c2c:	7d 83       	std	Y+5, r23	; 0x05
     c2e:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     c30:	31 87       	std	Z+9, r19	; 0x09
     c32:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     c34:	f9 01       	movw	r30, r18
     c36:	80 81       	ld	r24, Z
     c38:	8f 5f       	subi	r24, 0xFF	; 255
     c3a:	80 83       	st	Z, r24
}
     c3c:	df 91       	pop	r29
     c3e:	cf 91       	pop	r28
     c40:	08 95       	ret

00000c42 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     c42:	cf 93       	push	r28
     c44:	df 93       	push	r29
     c46:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     c48:	48 81       	ld	r20, Y
     c4a:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     c4c:	4f 3f       	cpi	r20, 0xFF	; 255
     c4e:	2f ef       	ldi	r18, 0xFF	; 255
     c50:	52 07       	cpc	r21, r18
     c52:	21 f4       	brne	.+8      	; 0xc5c <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     c54:	fc 01       	movw	r30, r24
     c56:	a7 81       	ldd	r26, Z+7	; 0x07
     c58:	b0 85       	ldd	r27, Z+8	; 0x08
     c5a:	0d c0       	rjmp	.+26     	; 0xc76 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     c5c:	dc 01       	movw	r26, r24
     c5e:	13 96       	adiw	r26, 0x03	; 3
     c60:	01 c0       	rjmp	.+2      	; 0xc64 <vListInsert+0x22>
     c62:	df 01       	movw	r26, r30
     c64:	12 96       	adiw	r26, 0x02	; 2
     c66:	ed 91       	ld	r30, X+
     c68:	fc 91       	ld	r31, X
     c6a:	13 97       	sbiw	r26, 0x03	; 3
     c6c:	20 81       	ld	r18, Z
     c6e:	31 81       	ldd	r19, Z+1	; 0x01
     c70:	42 17       	cp	r20, r18
     c72:	53 07       	cpc	r21, r19
     c74:	b0 f7       	brcc	.-20     	; 0xc62 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     c76:	12 96       	adiw	r26, 0x02	; 2
     c78:	ed 91       	ld	r30, X+
     c7a:	fc 91       	ld	r31, X
     c7c:	13 97       	sbiw	r26, 0x03	; 3
     c7e:	fb 83       	std	Y+3, r31	; 0x03
     c80:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     c82:	d5 83       	std	Z+5, r29	; 0x05
     c84:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     c86:	bd 83       	std	Y+5, r27	; 0x05
     c88:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     c8a:	13 96       	adiw	r26, 0x03	; 3
     c8c:	dc 93       	st	X, r29
     c8e:	ce 93       	st	-X, r28
     c90:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     c92:	99 87       	std	Y+9, r25	; 0x09
     c94:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     c96:	fc 01       	movw	r30, r24
     c98:	20 81       	ld	r18, Z
     c9a:	2f 5f       	subi	r18, 0xFF	; 255
     c9c:	20 83       	st	Z, r18
}
     c9e:	df 91       	pop	r29
     ca0:	cf 91       	pop	r28
     ca2:	08 95       	ret

00000ca4 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     ca4:	cf 93       	push	r28
     ca6:	df 93       	push	r29
     ca8:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     caa:	a0 85       	ldd	r26, Z+8	; 0x08
     cac:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     cae:	c2 81       	ldd	r28, Z+2	; 0x02
     cb0:	d3 81       	ldd	r29, Z+3	; 0x03
     cb2:	84 81       	ldd	r24, Z+4	; 0x04
     cb4:	95 81       	ldd	r25, Z+5	; 0x05
     cb6:	9d 83       	std	Y+5, r25	; 0x05
     cb8:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     cba:	c4 81       	ldd	r28, Z+4	; 0x04
     cbc:	d5 81       	ldd	r29, Z+5	; 0x05
     cbe:	82 81       	ldd	r24, Z+2	; 0x02
     cc0:	93 81       	ldd	r25, Z+3	; 0x03
     cc2:	9b 83       	std	Y+3, r25	; 0x03
     cc4:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     cc6:	11 96       	adiw	r26, 0x01	; 1
     cc8:	cd 91       	ld	r28, X+
     cca:	dc 91       	ld	r29, X
     ccc:	12 97       	sbiw	r26, 0x02	; 2
     cce:	ce 17       	cp	r28, r30
     cd0:	df 07       	cpc	r29, r31
     cd2:	31 f4       	brne	.+12     	; 0xce0 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     cd4:	8c 81       	ldd	r24, Y+4	; 0x04
     cd6:	9d 81       	ldd	r25, Y+5	; 0x05
     cd8:	12 96       	adiw	r26, 0x02	; 2
     cda:	9c 93       	st	X, r25
     cdc:	8e 93       	st	-X, r24
     cde:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     ce0:	11 86       	std	Z+9, r1	; 0x09
     ce2:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     ce4:	8c 91       	ld	r24, X
     ce6:	81 50       	subi	r24, 0x01	; 1
     ce8:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     cea:	df 91       	pop	r29
     cec:	cf 91       	pop	r28
     cee:	08 95       	ret

00000cf0 <vMainCommunicationTask>:
    #define tic PORTH |= (1<<PINH5)
    #define toc PORTH &= ~(1<<PINH5)
#endif

/*  Communication task */
void vMainCommunicationTask( void *pvParameters ){
     cf0:	cf 93       	push	r28
     cf2:	df 93       	push	r29
     cf4:	cd b7       	in	r28, 0x3d	; 61
     cf6:	de b7       	in	r29, 0x3e	; 62
     cf8:	6a 97       	sbiw	r28, 0x1a	; 26
     cfa:	0f b6       	in	r0, 0x3f	; 63
     cfc:	f8 94       	cli
     cfe:	de bf       	out	0x3e, r29	; 62
     d00:	0f be       	out	0x3f, r0	; 63
     d02:	cd bf       	out	0x3d, r28	; 61
    // Setup for the communication task
    struct sPolar Setpoint = {0}; // Struct for setpoints from server
     d04:	fe 01       	movw	r30, r28
     d06:	31 96       	adiw	r30, 0x01	; 1
     d08:	86 e0       	ldi	r24, 0x06	; 6
     d0a:	df 01       	movw	r26, r30
     d0c:	1d 92       	st	X+, r1
     d0e:	8a 95       	dec	r24
     d10:	e9 f7       	brne	.-6      	; 0xd0c <vMainCommunicationTask+0x1c>
    uint16_t handShakeCounter = 0;
    char command_in[20]; // Buffer for recieved messages
    if (nRFconnected){
     d12:	64 99       	sbic	0x0c, 4	; 12
     d14:	06 c0       	rjmp	.+12     	; 0xd22 <vMainCommunicationTask+0x32>
        // indicate we are connected at initalization
        vLED_singleHigh(ledGREEN);
     d16:	82 e0       	ldi	r24, 0x02	; 2
     d18:	90 e0       	ldi	r25, 0x00	; 0
     d1a:	0f df       	rcall	.-482    	; 0xb3a <vLED_singleHigh>
        // And not handshook
        vLED_singleHigh(ledYELLOW);
     d1c:	81 e0       	ldi	r24, 0x01	; 1
     d1e:	90 e0       	ldi	r25, 0x00	; 0
     d20:	0c df       	rcall	.-488    	; 0xb3a <vLED_singleHigh>
    }
    #ifdef DEBUG
    printf("Communication OK\n");
     d22:	84 e1       	ldi	r24, 0x14	; 20
     d24:	96 e0       	ldi	r25, 0x06	; 6
     d26:	0e 94 f9 2f 	call	0x5ff2	; 0x5ff2 <puts>

/*  Communication task */
void vMainCommunicationTask( void *pvParameters ){
    // Setup for the communication task
    struct sPolar Setpoint = {0}; // Struct for setpoints from server
    uint16_t handShakeCounter = 0;
     d2a:	00 e0       	ldi	r16, 0x00	; 0
     d2c:	10 e0       	ldi	r17, 0x00	; 0
        if (xSemaphoreTake(xCommandReadyBSem, 0) == pdTRUE){
            // We have a new command from the server, copy it to the memory
            vTaskSuspendAll ();       // Temporarily disable context switching
            ATOMIC_BLOCK(ATOMIC_FORCEON){
                // Copy contents of data_in into command_in
                memcpy(command_in, &gData_in, sizeof(gData_in));
     d2e:	0f 2e       	mov	r0, r31
     d30:	f4 e1       	ldi	r31, 0x14	; 20
     d32:	bf 2e       	mov	r11, r31
     d34:	f0 2d       	mov	r31, r0
            if(strstr(command_in, STATUS_CONFIRM)){
                // Handshake is verified!
                #ifdef DEBUG
                printf("{S,CON}\n");
                #endif
                gHandshook = TRUE; // Set start flag true
     d36:	aa 24       	eor	r10, r10
     d38:	a3 94       	inc	r10
                // Ensure max values are not exceeded
                if (Setpoint.distance > 320){
                    Setpoint.distance = 320;
                }
                else if (Setpoint.distance < -320){
                    Setpoint.distance = -320;
     d3a:	0f 2e       	mov	r0, r31
     d3c:	f0 ec       	ldi	r31, 0xC0	; 192
     d3e:	cf 2e       	mov	r12, r31
     d40:	fe ef       	ldi	r31, 0xFE	; 254
     d42:	df 2e       	mov	r13, r31
     d44:	f0 2d       	mov	r31, r0
            if (strstr(command_in, UPDATE)){
                // Update command
                vFunc_ParseUpdate(command_in, &Setpoint.heading, &Setpoint.distance);
                // Ensure max values are not exceeded
                if (Setpoint.distance > 320){
                    Setpoint.distance = 320;
     d46:	68 94       	set
     d48:	ee 24       	eor	r14, r14
     d4a:	e6 f8       	bld	r14, 6
     d4c:	ff 24       	eor	r15, r15
     d4e:	f3 94       	inc	r15
    #ifdef DEBUG
    printf("Communication OK\n");
    #endif

    while(1){
        if(gHandshook){
     d50:	80 91 80 1a 	lds	r24, 0x1A80	; 0x801a80 <gHandshook>
     d54:	88 23       	and	r24, r24
     d56:	09 f4       	brne	.+2      	; 0xd5a <vMainCommunicationTask+0x6a>
     d58:	a0 c0       	rjmp	.+320    	; 0xe9a <vMainCommunicationTask+0x1aa>
            if (xSemaphoreTake(xCommandReadyBSem, portMAX_DELAY) == pdTRUE){
     d5a:	20 e0       	ldi	r18, 0x00	; 0
     d5c:	4f ef       	ldi	r20, 0xFF	; 255
     d5e:	5f ef       	ldi	r21, 0xFF	; 255
     d60:	60 e0       	ldi	r22, 0x00	; 0
     d62:	70 e0       	ldi	r23, 0x00	; 0
     d64:	80 91 1e 1b 	lds	r24, 0x1B1E	; 0x801b1e <xCommandReadyBSem>
     d68:	90 91 1f 1b 	lds	r25, 0x1B1F	; 0x801b1f <xCommandReadyBSem+0x1>
     d6c:	0e 94 34 1b 	call	0x3668	; 0x3668 <xQueueGenericReceive>
     d70:	81 30       	cpi	r24, 0x01	; 1
     d72:	71 f7       	brne	.-36     	; 0xd50 <vMainCommunicationTask+0x60>
                // We have a new command from the server, copy it to the memory
                vTaskSuspendAll ();       // Temporarily disable context switching
     d74:	0e 94 2f 22 	call	0x445e	; 0x445e <vTaskSuspendAll>
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     d78:	f8 94       	cli
                ATOMIC_BLOCK(ATOMIC_FORCEON){
                    // Copy contents of data_in into command_in
                    memcpy(command_in, &gData_in, sizeof(gData_in));
     d7a:	e0 e2       	ldi	r30, 0x20	; 32
     d7c:	fb e1       	ldi	r31, 0x1B	; 27
     d7e:	de 01       	movw	r26, r28
     d80:	17 96       	adiw	r26, 0x07	; 7
     d82:	8b 2d       	mov	r24, r11
     d84:	01 90       	ld	r0, Z+
     d86:	0d 92       	st	X+, r0
     d88:	8a 95       	dec	r24
     d8a:	e1 f7       	brne	.-8      	; 0xd84 <vMainCommunicationTask+0x94>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
     d8c:	78 94       	sei
                }
                xTaskResumeAll ();      // Enable context switching
     d8e:	0e 94 35 22 	call	0x446a	; 0x446a <xTaskResumeAll>

                // Process recieved USART commands
                if (strstr(command_in, "{}")){
     d92:	65 e2       	ldi	r22, 0x25	; 37
     d94:	76 e0       	ldi	r23, 0x06	; 6
     d96:	ce 01       	movw	r24, r28
     d98:	07 96       	adiw	r24, 0x07	; 7
     d9a:	0e 94 42 2f 	call	0x5e84	; 0x5e84 <strstr>
     d9e:	89 2b       	or	r24, r25
     da0:	21 f0       	breq	.+8      	; 0xdaa <vMainCommunicationTask+0xba>
                vUSART_sendS("\t\n");
     da2:	88 e2       	ldi	r24, 0x28	; 40
     da4:	96 e0       	ldi	r25, 0x06	; 6
     da6:	0e 94 fc 26 	call	0x4df8	; 0x4df8 <vUSART_sendS>
            }
            if (strstr(command_in, UPDATE)){
     daa:	6b e2       	ldi	r22, 0x2B	; 43
     dac:	76 e0       	ldi	r23, 0x06	; 6
     dae:	ce 01       	movw	r24, r28
     db0:	07 96       	adiw	r24, 0x07	; 7
     db2:	0e 94 42 2f 	call	0x5e84	; 0x5e84 <strstr>
     db6:	89 2b       	or	r24, r25
     db8:	c9 f1       	breq	.+114    	; 0xe2c <vMainCommunicationTask+0x13c>
                // Update command
                vFunc_ParseUpdate(command_in, &Setpoint.heading, &Setpoint.distance);
     dba:	ae 01       	movw	r20, r28
     dbc:	4b 5f       	subi	r20, 0xFB	; 251
     dbe:	5f 4f       	sbci	r21, 0xFF	; 255
     dc0:	be 01       	movw	r22, r28
     dc2:	6f 5f       	subi	r22, 0xFF	; 255
     dc4:	7f 4f       	sbci	r23, 0xFF	; 255
     dc6:	ce 01       	movw	r24, r28
     dc8:	07 96       	adiw	r24, 0x07	; 7
     dca:	4f db       	rcall	.-2402   	; 0x46a <vFunc_ParseUpdate>
                // Ensure max values are not exceeded
                if (Setpoint.distance > 320){
     dcc:	8d 81       	ldd	r24, Y+5	; 0x05
     dce:	9e 81       	ldd	r25, Y+6	; 0x06
     dd0:	81 34       	cpi	r24, 0x41	; 65
     dd2:	b1 e0       	ldi	r27, 0x01	; 1
     dd4:	9b 07       	cpc	r25, r27
     dd6:	1c f0       	brlt	.+6      	; 0xdde <vMainCommunicationTask+0xee>
                    Setpoint.distance = 320;
     dd8:	fe 82       	std	Y+6, r15	; 0x06
     dda:	ed 82       	std	Y+5, r14	; 0x05
     ddc:	05 c0       	rjmp	.+10     	; 0xde8 <vMainCommunicationTask+0xf8>
                }
                else if (Setpoint.distance < -320){
     dde:	80 3c       	cpi	r24, 0xC0	; 192
     de0:	9e 4f       	sbci	r25, 0xFE	; 254
     de2:	14 f4       	brge	.+4      	; 0xde8 <vMainCommunicationTask+0xf8>
                    Setpoint.distance = -320;
     de4:	de 82       	std	Y+6, r13	; 0x06
     de6:	cd 82       	std	Y+5, r12	; 0x05
                }
                Setpoint.heading *= DEG2RAD; // Convert received set point to radians
     de8:	25 e3       	ldi	r18, 0x35	; 53
     dea:	3a ef       	ldi	r19, 0xFA	; 250
     dec:	4e e8       	ldi	r20, 0x8E	; 142
     dee:	5c e3       	ldi	r21, 0x3C	; 60
     df0:	69 81       	ldd	r22, Y+1	; 0x01
     df2:	7a 81       	ldd	r23, Y+2	; 0x02
     df4:	8b 81       	ldd	r24, Y+3	; 0x03
     df6:	9c 81       	ldd	r25, Y+4	; 0x04
     df8:	0e 94 91 29 	call	0x5322	; 0x5322 <__mulsf3>
     dfc:	69 83       	std	Y+1, r22	; 0x01
     dfe:	7a 83       	std	Y+2, r23	; 0x02
     e00:	8b 83       	std	Y+3, r24	; 0x03
     e02:	9c 83       	std	Y+4, r25	; 0x04
                vFunc_Inf2pi(&Setpoint.heading);
     e04:	ce 01       	movw	r24, r28
     e06:	01 96       	adiw	r24, 0x01	; 1
     e08:	e1 da       	rcall	.-2622   	; 0x3cc <vFunc_Inf2pi>
                
                /* Relay new coordinates to position controller*/
                /* Wait 500 ms to allow compass to converge if necessary (Experimental) */
                 vTaskDelay(500 / portTICK_PERIOD_MS); // Commented back in due to fixed encoder
     e0a:	84 ef       	ldi	r24, 0xF4	; 244
     e0c:	91 e0       	ldi	r25, 0x01	; 1
     e0e:	0e 94 c6 1f 	call	0x3f8c	; 0x3f8c <vTaskDelay>
                
                xQueueSend(poseControllerQ, &Setpoint, 100);
     e12:	20 e0       	ldi	r18, 0x00	; 0
     e14:	44 e6       	ldi	r20, 0x64	; 100
     e16:	50 e0       	ldi	r21, 0x00	; 0
     e18:	be 01       	movw	r22, r28
     e1a:	6f 5f       	subi	r22, 0xFF	; 255
     e1c:	7f 4f       	sbci	r23, 0xFF	; 255
     e1e:	80 91 87 1a 	lds	r24, 0x1A87	; 0x801a87 <poseControllerQ>
     e22:	90 91 88 1a 	lds	r25, 0x1A88	; 0x801a88 <poseControllerQ+0x1>
     e26:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <xQueueGenericSend>
     e2a:	92 cf       	rjmp	.-220    	; 0xd50 <vMainCommunicationTask+0x60>
            }
            else if(strstr(command_in, STATUS_PAUSE)){
     e2c:	6f e2       	ldi	r22, 0x2F	; 47
     e2e:	76 e0       	ldi	r23, 0x06	; 6
     e30:	ce 01       	movw	r24, r28
     e32:	07 96       	adiw	r24, 0x07	; 7
     e34:	0e 94 42 2f 	call	0x5e84	; 0x5e84 <strstr>
     e38:	89 2b       	or	r24, r25
     e3a:	e1 f0       	breq	.+56     	; 0xe74 <vMainCommunicationTask+0x184>
                // Stop sending update messages
                #ifdef DEBUG
                    printf("Robot paused!\n");
     e3c:	87 e3       	ldi	r24, 0x37	; 55
     e3e:	96 e0       	ldi	r25, 0x06	; 6
     e40:	0e 94 f9 2f 	call	0x5ff2	; 0x5ff2 <puts>
                #endif
                gPaused = TRUE;
     e44:	a0 92 7f 1a 	sts	0x1A7F, r10	; 0x801a7f <gPaused>
                vLED_singleHigh(ledYELLOW);
     e48:	81 e0       	ldi	r24, 0x01	; 1
     e4a:	90 e0       	ldi	r25, 0x00	; 0
     e4c:	76 de       	rcall	.-788    	; 0xb3a <vLED_singleHigh>
                // Stop controller
                Setpoint.distance = 0;
     e4e:	1e 82       	std	Y+6, r1	; 0x06
     e50:	1d 82       	std	Y+5, r1	; 0x05
                Setpoint.heading = 0;
     e52:	19 82       	std	Y+1, r1	; 0x01
     e54:	1a 82       	std	Y+2, r1	; 0x02
     e56:	1b 82       	std	Y+3, r1	; 0x03
     e58:	1c 82       	std	Y+4, r1	; 0x04
                xQueueSend(poseControllerQ, &Setpoint, 100);
     e5a:	20 e0       	ldi	r18, 0x00	; 0
     e5c:	44 e6       	ldi	r20, 0x64	; 100
     e5e:	50 e0       	ldi	r21, 0x00	; 0
     e60:	be 01       	movw	r22, r28
     e62:	6f 5f       	subi	r22, 0xFF	; 255
     e64:	7f 4f       	sbci	r23, 0xFF	; 255
     e66:	80 91 87 1a 	lds	r24, 0x1A87	; 0x801a87 <poseControllerQ>
     e6a:	90 91 88 1a 	lds	r25, 0x1A88	; 0x801a88 <poseControllerQ+0x1>
     e6e:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <xQueueGenericSend>
     e72:	6e cf       	rjmp	.-292    	; 0xd50 <vMainCommunicationTask+0x60>
            }
            else if(strstr(command_in, STATUS_UNPAUSE)){
     e74:	65 e4       	ldi	r22, 0x45	; 69
     e76:	76 e0       	ldi	r23, 0x06	; 6
     e78:	ce 01       	movw	r24, r28
     e7a:	07 96       	adiw	r24, 0x07	; 7
     e7c:	0e 94 42 2f 	call	0x5e84	; 0x5e84 <strstr>
     e80:	89 2b       	or	r24, r25
     e82:	09 f4       	brne	.+2      	; 0xe86 <vMainCommunicationTask+0x196>
     e84:	65 cf       	rjmp	.-310    	; 0xd50 <vMainCommunicationTask+0x60>
                // Robot is finished
                #ifdef DEBUG
                    printf("Robot unpaused!\n");
     e86:	8d e4       	ldi	r24, 0x4D	; 77
     e88:	96 e0       	ldi	r25, 0x06	; 6
     e8a:	0e 94 f9 2f 	call	0x5ff2	; 0x5ff2 <puts>
                #endif
                vLED_singleLow(ledYELLOW);
     e8e:	81 e0       	ldi	r24, 0x01	; 1
     e90:	90 e0       	ldi	r25, 0x00	; 0
     e92:	6d de       	rcall	.-806    	; 0xb6e <vLED_singleLow>
                gPaused = FALSE;
     e94:	10 92 7f 1a 	sts	0x1A7F, r1	; 0x801a7f <gPaused>
     e98:	5b cf       	rjmp	.-330    	; 0xd50 <vMainCommunicationTask+0x60>
                // Stop sending update messages
            }
        // Command is processed
        } // if (gCommand_ready) end
    }// if(ghandshook) end
    else if ((nRFconnected == TRUE) && (gHandshook == FALSE)){
     e9a:	64 99       	sbic	0x0c, 4	; 12
     e9c:	50 c0       	rjmp	.+160    	; 0xf3e <vMainCommunicationTask+0x24e>
     e9e:	80 91 80 1a 	lds	r24, 0x1A80	; 0x801a80 <gHandshook>
     ea2:	81 11       	cpse	r24, r1
     ea4:	4c c0       	rjmp	.+152    	; 0xf3e <vMainCommunicationTask+0x24e>
        if (xSemaphoreTake(xCommandReadyBSem, 0) == pdTRUE){
     ea6:	20 e0       	ldi	r18, 0x00	; 0
     ea8:	40 e0       	ldi	r20, 0x00	; 0
     eaa:	50 e0       	ldi	r21, 0x00	; 0
     eac:	60 e0       	ldi	r22, 0x00	; 0
     eae:	70 e0       	ldi	r23, 0x00	; 0
     eb0:	80 91 1e 1b 	lds	r24, 0x1B1E	; 0x801b1e <xCommandReadyBSem>
     eb4:	90 91 1f 1b 	lds	r25, 0x1B1F	; 0x801b1f <xCommandReadyBSem+0x1>
     eb8:	0e 94 34 1b 	call	0x3668	; 0x3668 <xQueueGenericReceive>
     ebc:	81 30       	cpi	r24, 0x01	; 1
     ebe:	01 f5       	brne	.+64     	; 0xf00 <vMainCommunicationTask+0x210>
            // We have a new command from the server, copy it to the memory
            vTaskSuspendAll ();       // Temporarily disable context switching
     ec0:	0e 94 2f 22 	call	0x445e	; 0x445e <vTaskSuspendAll>
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     ec4:	f8 94       	cli
            ATOMIC_BLOCK(ATOMIC_FORCEON){
                // Copy contents of data_in into command_in
                memcpy(command_in, &gData_in, sizeof(gData_in));
     ec6:	e0 e2       	ldi	r30, 0x20	; 32
     ec8:	fb e1       	ldi	r31, 0x1B	; 27
     eca:	de 01       	movw	r26, r28
     ecc:	17 96       	adiw	r26, 0x07	; 7
     ece:	8b 2d       	mov	r24, r11
     ed0:	01 90       	ld	r0, Z+
     ed2:	0d 92       	st	X+, r0
     ed4:	8a 95       	dec	r24
     ed6:	e1 f7       	brne	.-8      	; 0xed0 <vMainCommunicationTask+0x1e0>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
     ed8:	78 94       	sei
            }
            xTaskResumeAll ();      // Enable context switching
     eda:	0e 94 35 22 	call	0x446a	; 0x446a <xTaskResumeAll>
            if(strstr(command_in, STATUS_CONFIRM)){
     ede:	6d e5       	ldi	r22, 0x5D	; 93
     ee0:	76 e0       	ldi	r23, 0x06	; 6
     ee2:	ce 01       	movw	r24, r28
     ee4:	07 96       	adiw	r24, 0x07	; 7
     ee6:	0e 94 42 2f 	call	0x5e84	; 0x5e84 <strstr>
     eea:	89 2b       	or	r24, r25
     eec:	49 f0       	breq	.+18     	; 0xf00 <vMainCommunicationTask+0x210>
                // Handshake is verified!
                #ifdef DEBUG
                printf("{S,CON}\n");
     eee:	8d e5       	ldi	r24, 0x5D	; 93
     ef0:	96 e0       	ldi	r25, 0x06	; 6
     ef2:	0e 94 f9 2f 	call	0x5ff2	; 0x5ff2 <puts>
                #endif
                gHandshook = TRUE; // Set start flag true
     ef6:	a0 92 80 1a 	sts	0x1A80, r10	; 0x801a80 <gHandshook>
                vLED_singleLow(ledYELLOW);
     efa:	81 e0       	ldi	r24, 0x01	; 1
     efc:	90 e0       	ldi	r25, 0x00	; 0
     efe:	37 de       	rcall	.-914    	; 0xb6e <vLED_singleLow>
            }
        }
        // Send a handshake every 1 sec:
        vLED_singleHigh(ledYELLOW);
     f00:	81 e0       	ldi	r24, 0x01	; 1
     f02:	90 e0       	ldi	r25, 0x00	; 0
     f04:	1a de       	rcall	.-972    	; 0xb3a <vLED_singleHigh>
            
        if (handShakeCounter >= 50){
     f06:	02 33       	cpi	r16, 0x32	; 50
     f08:	11 05       	cpc	r17, r1
     f0a:	18 f0       	brcs	.+6      	; 0xf12 <vMainCommunicationTask+0x222>
            vLED_toggle(ledYELLOW);
     f0c:	81 e0       	ldi	r24, 0x01	; 1
     f0e:	90 e0       	ldi	r25, 0x00	; 0
     f10:	48 de       	rcall	.-880    	; 0xba2 <vLED_toggle>
        }
        if (handShakeCounter >= 1000){
     f12:	08 3e       	cpi	r16, 0xE8	; 232
     f14:	83 e0       	ldi	r24, 0x03	; 3
     f16:	18 07       	cpc	r17, r24
     f18:	58 f0       	brcs	.+22     	; 0xf30 <vMainCommunicationTask+0x240>
            vLED_singleHigh(ledGREEN);
     f1a:	82 e0       	ldi	r24, 0x02	; 2
     f1c:	90 e0       	ldi	r25, 0x00	; 0
     f1e:	0d de       	rcall	.-998    	; 0xb3a <vLED_singleHigh>
            vUSART_sendHandshake();
     f20:	0e 94 0a 27 	call	0x4e14	; 0x4e14 <vUSART_sendHandshake>
            vLED_toggle(ledYELLOW);
     f24:	81 e0       	ldi	r24, 0x01	; 1
     f26:	90 e0       	ldi	r25, 0x00	; 0
     f28:	3c de       	rcall	.-904    	; 0xba2 <vLED_toggle>
            handShakeCounter = 0;
     f2a:	00 e0       	ldi	r16, 0x00	; 0
     f2c:	10 e0       	ldi	r17, 0x00	; 0
     f2e:	10 cf       	rjmp	.-480    	; 0xd50 <vMainCommunicationTask+0x60>
        }
        else{
            handShakeCounter++;
     f30:	0f 5f       	subi	r16, 0xFF	; 255
     f32:	1f 4f       	sbci	r17, 0xFF	; 255
            vTaskDelay(1 / portTICK_PERIOD_MS);
     f34:	81 e0       	ldi	r24, 0x01	; 1
     f36:	90 e0       	ldi	r25, 0x00	; 0
     f38:	0e 94 c6 1f 	call	0x3f8c	; 0x3f8c <vTaskDelay>
     f3c:	09 cf       	rjmp	.-494    	; 0xd50 <vMainCommunicationTask+0x60>
        }
    }
    else if (!(nRFconnected)){
     f3e:	64 9b       	sbis	0x0c, 4	; 12
     f40:	07 cf       	rjmp	.-498    	; 0xd50 <vMainCommunicationTask+0x60>
        // Show on leds that we are advertising
        vLED_singleHigh(ledGREEN);
     f42:	82 e0       	ldi	r24, 0x02	; 2
     f44:	90 e0       	ldi	r25, 0x00	; 0
     f46:	f9 dd       	rcall	.-1038   	; 0xb3a <vLED_singleHigh>
        vTaskDelay(200 / portTICK_PERIOD_MS);
     f48:	88 ec       	ldi	r24, 0xC8	; 200
     f4a:	90 e0       	ldi	r25, 0x00	; 0
     f4c:	0e 94 c6 1f 	call	0x3f8c	; 0x3f8c <vTaskDelay>
        vLED_singleLow(ledGREEN);
     f50:	82 e0       	ldi	r24, 0x02	; 2
     f52:	90 e0       	ldi	r25, 0x00	; 0
     f54:	0c de       	rcall	.-1000   	; 0xb6e <vLED_singleLow>
        vTaskDelay(1800 / portTICK_PERIOD_MS);
     f56:	88 e0       	ldi	r24, 0x08	; 8
     f58:	97 e0       	ldi	r25, 0x07	; 7
     f5a:	0e 94 c6 1f 	call	0x3f8c	; 0x3f8c <vTaskDelay>
     f5e:	f8 ce       	rjmp	.-528    	; 0xd50 <vMainCommunicationTask+0x60>

00000f60 <vMainSensorTowerTask>:
    }
    }// While(1) end
}// vMainComtask end

/*  Sensor tower task */
void vMainSensorTowerTask( void *pvParameters){
     f60:	cf 93       	push	r28
     f62:	df 93       	push	r29
     f64:	cd b7       	in	r28, 0x3d	; 61
     f66:	de b7       	in	r29, 0x3e	; 62
     f68:	29 97       	sbiw	r28, 0x09	; 9
     f6a:	0f b6       	in	r0, 0x3f	; 63
     f6c:	f8 94       	cli
     f6e:	de bf       	out	0x3e, r29	; 62
     f70:	0f be       	out	0x3f, r0	; 63
     f72:	cd bf       	out	0x3d, r28	; 61
    /* Task init */
    #ifdef DEBUG
        printf("Tower OK\n");
     f74:	85 e6       	ldi	r24, 0x65	; 101
     f76:	96 e0       	ldi	r25, 0x06	; 6
     f78:	0e 94 f9 2f 	call	0x5ff2	; 0x5ff2 <puts>
    int16_t yhat = 0;
    
    uint8_t rotationDirection = moveCounterClockwise;
    uint8_t servoStep = 0;
    uint8_t servoResolution = 1;
    uint8_t robotMovement = moveStop;
     f7c:	19 82       	std	Y+1, r1	; 0x01
    
    uint8_t idleCounter = 0;
     f7e:	00 e0       	ldi	r16, 0x00	; 0
    int16_t xhat = 0;
    int16_t yhat = 0;
    
    uint8_t rotationDirection = moveCounterClockwise;
    uint8_t servoStep = 0;
    uint8_t servoResolution = 1;
     f80:	bb 24       	eor	r11, r11
     f82:	b3 94       	inc	r11
    float thetahat = 0;
    int16_t xhat = 0;
    int16_t yhat = 0;
    
    uint8_t rotationDirection = moveCounterClockwise;
    uint8_t servoStep = 0;
     f84:	10 e0       	ldi	r17, 0x00	; 0
        
    float thetahat = 0;
    int16_t xhat = 0;
    int16_t yhat = 0;
    
    uint8_t rotationDirection = moveCounterClockwise;
     f86:	68 94       	set
     f88:	ff 24       	eor	r15, r15
     f8a:	f2 f8       	bld	r15, 2
            vTaskDelay(200 / portTICK_PERIOD_MS);
        */
        else{ // Disconnected or unconfirmed
            vServo_setAngle(0);
            // Reset servo incrementation
            rotationDirection = moveCounterClockwise;
     f8c:	68 94       	set
     f8e:	ee 24       	eor	r14, r14
     f90:	e2 f8       	bld	r14, 2
            else if ((servoStep*servoResolution > 0) && (rotationDirection == moveClockwise) && (robotMovement < moveClockwise)){
                servoStep --;
            }
            
            if ((servoStep*servoResolution >= 90) && (rotationDirection == moveCounterClockwise)){
                rotationDirection = moveClockwise;
     f92:	0f 2e       	mov	r0, r31
     f94:	f3 e0       	ldi	r31, 0x03	; 3
     f96:	7f 2e       	mov	r7, r31
     f98:	f0 2d       	mov	r31, r0
                        idleCounter = 1;
                    break;
                    case moveForward:
                    case moveBackward:
                        servoResolution = 5;
                        servoStep /= servoResolution;
     f9a:	0f 2e       	mov	r0, r31
     f9c:	fd ec       	ldi	r31, 0xCD	; 205
     f9e:	4f 2e       	mov	r4, r31
     fa0:	f0 2d       	mov	r31, r0
                        servoResolution = 1;
                        idleCounter = 1;
                    break;
                    case moveForward:
                    case moveBackward:
                        servoResolution = 5;
     fa2:	0f 2e       	mov	r0, r31
     fa4:	f5 e0       	ldi	r31, 0x05	; 5
     fa6:	5f 2e       	mov	r5, r31
     fa8:	f0 2d       	mov	r31, r0
     faa:	07 c0       	rjmp	.+14     	; 0xfba <vMainSensorTowerTask+0x5a>
            else if ((servoStep*servoResolution > 0) && (rotationDirection == moveClockwise) && (robotMovement < moveClockwise)){
                servoStep --;
            }
            
            if ((servoStep*servoResolution >= 90) && (rotationDirection == moveCounterClockwise)){
                rotationDirection = moveClockwise;
     fac:	f7 2c       	mov	r15, r7
     fae:	05 c0       	rjmp	.+10     	; 0xfba <vMainSensorTowerTask+0x5a>
     fb0:	f7 2c       	mov	r15, r7
     fb2:	03 c0       	rjmp	.+6      	; 0xfba <vMainSensorTowerTask+0x5a>
     fb4:	f7 2c       	mov	r15, r7
     fb6:	01 c0       	rjmp	.+2      	; 0xfba <vMainSensorTowerTask+0x5a>
     fb8:	f7 2c       	mov	r15, r7
    // Initialize the xLastWakeTime variable with the current time.
    TickType_t xLastWakeTime;
    
    while(1){
        // Loop
        if ((gHandshook == TRUE) && (gPaused == FALSE)){
     fba:	90 91 80 1a 	lds	r25, 0x1A80	; 0x801a80 <gHandshook>
     fbe:	91 30       	cpi	r25, 0x01	; 1
     fc0:	09 f0       	breq	.+2      	; 0xfc4 <vMainSensorTowerTask+0x64>
     fc2:	15 c1       	rjmp	.+554    	; 0x11ee <vMainSensorTowerTask+0x28e>
     fc4:	90 91 7f 1a 	lds	r25, 0x1A7F	; 0x801a7f <gPaused>
     fc8:	91 11       	cpse	r25, r1
     fca:	11 c1       	rjmp	.+546    	; 0x11ee <vMainSensorTowerTask+0x28e>
            // xLastWakeTime variable with the current time.
            xLastWakeTime = xTaskGetTickCount();
     fcc:	0e 94 70 23 	call	0x46e0	; 0x46e0 <xTaskGetTickCount>
     fd0:	9b 83       	std	Y+3, r25	; 0x03
     fd2:	8a 83       	std	Y+2, r24	; 0x02
            // Set scanning resolution depending on which movement the robot is executing.
            if (xQueueReceive(scanStatusQ, &robotMovement,150 / portTICK_PERIOD_MS) == pdTRUE){
     fd4:	20 e0       	ldi	r18, 0x00	; 0
     fd6:	46 e9       	ldi	r20, 0x96	; 150
     fd8:	50 e0       	ldi	r21, 0x00	; 0
     fda:	be 01       	movw	r22, r28
     fdc:	6f 5f       	subi	r22, 0xFF	; 255
     fde:	7f 4f       	sbci	r23, 0xFF	; 255
     fe0:	80 91 85 1a 	lds	r24, 0x1A85	; 0x801a85 <scanStatusQ>
     fe4:	90 91 86 1a 	lds	r25, 0x1A86	; 0x801a86 <scanStatusQ+0x1>
     fe8:	0e 94 34 1b 	call	0x3668	; 0x3668 <xQueueGenericReceive>
     fec:	81 30       	cpi	r24, 0x01	; 1
     fee:	09 f0       	breq	.+2      	; 0xff2 <vMainSensorTowerTask+0x92>
     ff0:	66 c0       	rjmp	.+204    	; 0x10be <vMainSensorTowerTask+0x15e>
                // Set servo step length according to movement, 
                // Note that the iterations are skipped while robot is rotating (see further downbelow)
                switch (robotMovement)
     ff2:	89 81       	ldd	r24, Y+1	; 0x01
     ff4:	88 23       	and	r24, r24
     ff6:	21 f0       	breq	.+8      	; 0x1000 <vMainSensorTowerTask+0xa0>
     ff8:	83 30       	cpi	r24, 0x03	; 3
     ffa:	08 f0       	brcs	.+2      	; 0xffe <vMainSensorTowerTask+0x9e>
     ffc:	5f c0       	rjmp	.+190    	; 0x10bc <vMainSensorTowerTask+0x15c>
     ffe:	2d c0       	rjmp	.+90     	; 0x105a <vMainSensorTowerTask+0xfa>
                {
                    case moveStop:
                        servoStep *= servoResolution;
    1000:	1b 9d       	mul	r17, r11
    1002:	10 2d       	mov	r17, r0
    1004:	11 24       	eor	r1, r1
                    default:
                        idleCounter = 0;
                    break;
                }
            }
            vServo_setAngle(servoStep*servoResolution);
    1006:	81 2f       	mov	r24, r17
    1008:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <vServo_setAngle>
            vTaskDelayUntil(&xLastWakeTime, 200 / portTICK_PERIOD_MS); // Wait total of 200 ms for servo to reach set point
    100c:	68 ec       	ldi	r22, 0xC8	; 200
    100e:	70 e0       	ldi	r23, 0x00	; 0
    1010:	ce 01       	movw	r24, r28
    1012:	02 96       	adiw	r24, 0x02	; 2
    1014:	0e 94 23 1e 	call	0x3c46	; 0x3c46 <vTaskDelayUntil>
            
            uint8_t forwardSensor = ui8DistSens_readCM(distSensFwd);
    1018:	81 e0       	ldi	r24, 0x01	; 1
    101a:	b3 d9       	rcall	.-3226   	; 0x382 <ui8DistSens_readCM>
    101c:	a8 2e       	mov	r10, r24
            uint8_t leftSensor = ui8DistSens_readCM(distSensLeft);
    101e:	80 e0       	ldi	r24, 0x00	; 0
    1020:	b0 d9       	rcall	.-3232   	; 0x382 <ui8DistSens_readCM>
            uint8_t rearSensor = ui8DistSens_readCM(distSensRear);
    1022:	87 2d       	mov	r24, r7
    1024:	ae d9       	rcall	.-3236   	; 0x382 <ui8DistSens_readCM>
            uint8_t rightSensor = ui8DistSens_readCM(distSensRight);
    1026:	82 e0       	ldi	r24, 0x02	; 2
    1028:	ac d9       	rcall	.-3240   	; 0x382 <ui8DistSens_readCM>
    102a:	68 2e       	mov	r6, r24
            
            xSemaphoreTake(xPoseMutex,40 / portTICK_PERIOD_MS);
    102c:	20 e0       	ldi	r18, 0x00	; 0
    102e:	48 e2       	ldi	r20, 0x28	; 40
    1030:	50 e0       	ldi	r21, 0x00	; 0
    1032:	60 e0       	ldi	r22, 0x00	; 0
    1034:	70 e0       	ldi	r23, 0x00	; 0
    1036:	80 91 34 1b 	lds	r24, 0x1B34	; 0x801b34 <xPoseMutex>
    103a:	90 91 35 1b 	lds	r25, 0x1B35	; 0x801b35 <xPoseMutex+0x1>
    103e:	0e 94 34 1b 	call	0x3668	; 0x3668 <xQueueGenericReceive>
                thetahat = gTheta_hat;
                xhat = gX_hat;
                yhat = gY_hat;
            xSemaphoreGive(xPoseMutex);
    1042:	60 e0       	ldi	r22, 0x00	; 0
    1044:	70 e0       	ldi	r23, 0x00	; 0
    1046:	80 91 34 1b 	lds	r24, 0x1B34	; 0x801b34 <xPoseMutex>
    104a:	90 91 35 1b 	lds	r25, 0x1B35	; 0x801b35 <xPoseMutex+0x1>
    104e:	0e 94 9a 19 	call	0x3334	; 0x3334 <xQueueGive>
                switch (robotMovement)
                {
                    case moveStop:
                        servoStep *= servoResolution;
                        servoResolution = 1;
                        idleCounter = 1;
    1052:	01 e0       	ldi	r16, 0x01	; 1
                // Note that the iterations are skipped while robot is rotating (see further downbelow)
                switch (robotMovement)
                {
                    case moveStop:
                        servoStep *= servoResolution;
                        servoResolution = 1;
    1054:	bb 24       	eor	r11, r11
    1056:	b3 94       	inc	r11
    1058:	67 c0       	rjmp	.+206    	; 0x1128 <vMainSensorTowerTask+0x1c8>
                        idleCounter = 1;
                    break;
                    case moveForward:
                    case moveBackward:
                        servoResolution = 5;
                        servoStep /= servoResolution;
    105a:	14 9d       	mul	r17, r4
    105c:	11 2d       	mov	r17, r1
    105e:	11 24       	eor	r1, r1
    1060:	16 95       	lsr	r17
    1062:	16 95       	lsr	r17
                    default:
                        idleCounter = 0;
                    break;
                }
            }
            vServo_setAngle(servoStep*servoResolution);
    1064:	81 2f       	mov	r24, r17
    1066:	88 0f       	add	r24, r24
    1068:	88 0f       	add	r24, r24
    106a:	81 0f       	add	r24, r17
    106c:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <vServo_setAngle>
            vTaskDelayUntil(&xLastWakeTime, 200 / portTICK_PERIOD_MS); // Wait total of 200 ms for servo to reach set point
    1070:	68 ec       	ldi	r22, 0xC8	; 200
    1072:	70 e0       	ldi	r23, 0x00	; 0
    1074:	ce 01       	movw	r24, r28
    1076:	02 96       	adiw	r24, 0x02	; 2
    1078:	0e 94 23 1e 	call	0x3c46	; 0x3c46 <vTaskDelayUntil>
            
            uint8_t forwardSensor = ui8DistSens_readCM(distSensFwd);
    107c:	81 e0       	ldi	r24, 0x01	; 1
    107e:	81 d9       	rcall	.-3326   	; 0x382 <ui8DistSens_readCM>
    1080:	a8 2e       	mov	r10, r24
            uint8_t leftSensor = ui8DistSens_readCM(distSensLeft);
    1082:	80 e0       	ldi	r24, 0x00	; 0
    1084:	7e d9       	rcall	.-3332   	; 0x382 <ui8DistSens_readCM>
            uint8_t rearSensor = ui8DistSens_readCM(distSensRear);
    1086:	87 2d       	mov	r24, r7
    1088:	7c d9       	rcall	.-3336   	; 0x382 <ui8DistSens_readCM>
            uint8_t rightSensor = ui8DistSens_readCM(distSensRight);
    108a:	82 e0       	ldi	r24, 0x02	; 2
    108c:	7a d9       	rcall	.-3340   	; 0x382 <ui8DistSens_readCM>
    108e:	68 2e       	mov	r6, r24
            
            xSemaphoreTake(xPoseMutex,40 / portTICK_PERIOD_MS);
    1090:	20 e0       	ldi	r18, 0x00	; 0
    1092:	48 e2       	ldi	r20, 0x28	; 40
    1094:	50 e0       	ldi	r21, 0x00	; 0
    1096:	60 e0       	ldi	r22, 0x00	; 0
    1098:	70 e0       	ldi	r23, 0x00	; 0
    109a:	80 91 34 1b 	lds	r24, 0x1B34	; 0x801b34 <xPoseMutex>
    109e:	90 91 35 1b 	lds	r25, 0x1B35	; 0x801b35 <xPoseMutex+0x1>
    10a2:	0e 94 34 1b 	call	0x3668	; 0x3668 <xQueueGenericReceive>
                thetahat = gTheta_hat;
                xhat = gX_hat;
                yhat = gY_hat;
            xSemaphoreGive(xPoseMutex);
    10a6:	60 e0       	ldi	r22, 0x00	; 0
    10a8:	70 e0       	ldi	r23, 0x00	; 0
    10aa:	80 91 34 1b 	lds	r24, 0x1B34	; 0x801b34 <xPoseMutex>
    10ae:	90 91 35 1b 	lds	r25, 0x1B35	; 0x801b35 <xPoseMutex+0x1>
    10b2:	0e 94 9a 19 	call	0x3334	; 0x3334 <xQueueGive>
                        servoResolution = 1;
                        idleCounter = 1;
                    break;
                    case moveForward:
                    case moveBackward:
                        servoResolution = 5;
    10b6:	b5 2c       	mov	r11, r5
            
            xSemaphoreTake(xPoseMutex,40 / portTICK_PERIOD_MS);
                thetahat = gTheta_hat;
                xhat = gX_hat;
                yhat = gY_hat;
            xSemaphoreGive(xPoseMutex);
    10b8:	00 e0       	ldi	r16, 0x00	; 0
    10ba:	3a c0       	rjmp	.+116    	; 0x1130 <vMainSensorTowerTask+0x1d0>
                        idleCounter = 0;
                    break;
                    case moveClockwise:
                    case moveCounterClockwise:
                        // Iterations are frozen while rotating, see further down
                        idleCounter = 0;
    10bc:	00 e0       	ldi	r16, 0x00	; 0
                    default:
                        idleCounter = 0;
                    break;
                }
            }
            vServo_setAngle(servoStep*servoResolution);
    10be:	b1 9e       	mul	r11, r17
    10c0:	80 2d       	mov	r24, r0
    10c2:	11 24       	eor	r1, r1
    10c4:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <vServo_setAngle>
            vTaskDelayUntil(&xLastWakeTime, 200 / portTICK_PERIOD_MS); // Wait total of 200 ms for servo to reach set point
    10c8:	68 ec       	ldi	r22, 0xC8	; 200
    10ca:	70 e0       	ldi	r23, 0x00	; 0
    10cc:	ce 01       	movw	r24, r28
    10ce:	02 96       	adiw	r24, 0x02	; 2
    10d0:	0e 94 23 1e 	call	0x3c46	; 0x3c46 <vTaskDelayUntil>
            
            uint8_t forwardSensor = ui8DistSens_readCM(distSensFwd);
    10d4:	81 e0       	ldi	r24, 0x01	; 1
    10d6:	55 d9       	rcall	.-3414   	; 0x382 <ui8DistSens_readCM>
    10d8:	a8 2e       	mov	r10, r24
            uint8_t leftSensor = ui8DistSens_readCM(distSensLeft);
    10da:	80 e0       	ldi	r24, 0x00	; 0
    10dc:	52 d9       	rcall	.-3420   	; 0x382 <ui8DistSens_readCM>
            uint8_t rearSensor = ui8DistSens_readCM(distSensRear);
    10de:	87 2d       	mov	r24, r7
    10e0:	50 d9       	rcall	.-3424   	; 0x382 <ui8DistSens_readCM>
            uint8_t rightSensor = ui8DistSens_readCM(distSensRight);
    10e2:	82 e0       	ldi	r24, 0x02	; 2
    10e4:	4e d9       	rcall	.-3428   	; 0x382 <ui8DistSens_readCM>
    10e6:	68 2e       	mov	r6, r24
            
            xSemaphoreTake(xPoseMutex,40 / portTICK_PERIOD_MS);
    10e8:	20 e0       	ldi	r18, 0x00	; 0
    10ea:	48 e2       	ldi	r20, 0x28	; 40
    10ec:	50 e0       	ldi	r21, 0x00	; 0
    10ee:	60 e0       	ldi	r22, 0x00	; 0
    10f0:	70 e0       	ldi	r23, 0x00	; 0
    10f2:	80 91 34 1b 	lds	r24, 0x1B34	; 0x801b34 <xPoseMutex>
    10f6:	90 91 35 1b 	lds	r25, 0x1B35	; 0x801b35 <xPoseMutex+0x1>
    10fa:	0e 94 34 1b 	call	0x3668	; 0x3668 <xQueueGenericReceive>
                thetahat = gTheta_hat;
                xhat = gX_hat;
                yhat = gY_hat;
            xSemaphoreGive(xPoseMutex);
    10fe:	60 e0       	ldi	r22, 0x00	; 0
    1100:	70 e0       	ldi	r23, 0x00	; 0
    1102:	80 91 34 1b 	lds	r24, 0x1B34	; 0x801b34 <xPoseMutex>
    1106:	90 91 35 1b 	lds	r25, 0x1B35	; 0x801b35 <xPoseMutex+0x1>
    110a:	0e 94 9a 19 	call	0x3334	; 0x3334 <xQueueGive>
            
            // Experimental
            if ((idleCounter > 10) && (robotMovement == moveStop)){
    110e:	0b 30       	cpi	r16, 0x0B	; 11
    1110:	48 f0       	brcs	.+18     	; 0x1124 <vMainSensorTowerTask+0x1c4>
    1112:	89 81       	ldd	r24, Y+1	; 0x01
    1114:	81 11       	cpse	r24, r1
    1116:	06 c0       	rjmp	.+12     	; 0x1124 <vMainSensorTowerTask+0x1c4>
                // If the robot stands idle for 1 second, send 'status:idle' in case the server missed it.
                printf(STATUS_IDLE"\n");
    1118:	8e e6       	ldi	r24, 0x6E	; 110
    111a:	96 e0       	ldi	r25, 0x06	; 6
    111c:	0e 94 f9 2f 	call	0x5ff2	; 0x5ff2 <puts>
                idleCounter = 1;
    1120:	01 e0       	ldi	r16, 0x01	; 1
    1122:	06 c0       	rjmp	.+12     	; 0x1130 <vMainSensorTowerTask+0x1d0>
            }
            else if ((idleCounter >= 1) && (robotMovement == moveStop)){
    1124:	00 23       	and	r16, r16
    1126:	21 f0       	breq	.+8      	; 0x1130 <vMainSensorTowerTask+0x1d0>
    1128:	89 81       	ldd	r24, Y+1	; 0x01
    112a:	81 11       	cpse	r24, r1
    112c:	01 c0       	rjmp	.+2      	; 0x1130 <vMainSensorTowerTask+0x1d0>
                idleCounter++;
    112e:	0f 5f       	subi	r16, 0xFF	; 255
            //vUSART_sendUpdate(xhat/10,yhat/10,thetahat*RAD2DEG,servoStep*servoResolution,forwardSensor,leftSensor,rearSensor,rightSensor);
            
            
            // Low level anti collision
            uint8_t objectX;
            if ((servoStep*servoResolution) <= 30) objectX = forwardSensor;// * cos(servoStep*5);
    1130:	8b 2c       	mov	r8, r11
    1132:	91 2c       	mov	r9, r1
    1134:	18 9d       	mul	r17, r8
    1136:	60 01       	movw	r12, r0
    1138:	19 9d       	mul	r17, r9
    113a:	d0 0c       	add	r13, r0
    113c:	11 24       	eor	r1, r1
    113e:	8f e1       	ldi	r24, 0x1F	; 31
    1140:	c8 16       	cp	r12, r24
    1142:	d1 04       	cpc	r13, r1
    1144:	2c f0       	brlt	.+10     	; 0x1150 <vMainSensorTowerTask+0x1f0>
            else if((servoStep*servoResolution) >= 60) objectX = rightSensor;// * cos(270 + servoStep*5);
    1146:	8c e3       	ldi	r24, 0x3C	; 60
    1148:	c8 16       	cp	r12, r24
    114a:	d1 04       	cpc	r13, r1
    114c:	b4 f0       	brlt	.+44     	; 0x117a <vMainSensorTowerTask+0x21a>
    114e:	a6 2c       	mov	r10, r6
            else objectX = 0;
            
            if ((objectX > 0) && (objectX < 2)){
    1150:	81 e0       	ldi	r24, 0x01	; 1
    1152:	a8 12       	cpse	r10, r24
    1154:	12 c0       	rjmp	.+36     	; 0x117a <vMainSensorTowerTask+0x21a>
                // Stop controller
                struct sPolar Setpoint = {0, 0};
    1156:	1c 82       	std	Y+4, r1	; 0x04
    1158:	1d 82       	std	Y+5, r1	; 0x05
    115a:	1e 82       	std	Y+6, r1	; 0x06
    115c:	1f 82       	std	Y+7, r1	; 0x07
    115e:	19 86       	std	Y+9, r1	; 0x09
    1160:	18 86       	std	Y+8, r1	; 0x08
                xQueueSend(poseControllerQ, &Setpoint, 100);
    1162:	20 e0       	ldi	r18, 0x00	; 0
    1164:	44 e6       	ldi	r20, 0x64	; 100
    1166:	50 e0       	ldi	r21, 0x00	; 0
    1168:	be 01       	movw	r22, r28
    116a:	6c 5f       	subi	r22, 0xFC	; 252
    116c:	7f 4f       	sbci	r23, 0xFF	; 255
    116e:	80 91 87 1a 	lds	r24, 0x1A87	; 0x801a87 <poseControllerQ>
    1172:	90 91 88 1a 	lds	r25, 0x1A88	; 0x801a88 <poseControllerQ+0x1>
    1176:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <xQueueGenericSend>
            }
            
            // Iterate in a increasing/decreasing manner and depending on the robots movement
            if ((servoStep*servoResolution <= 90) && (rotationDirection == moveCounterClockwise) && (robotMovement < moveClockwise)){
    117a:	8b e5       	ldi	r24, 0x5B	; 91
    117c:	c8 16       	cp	r12, r24
    117e:	d1 04       	cpc	r13, r1
    1180:	94 f4       	brge	.+36     	; 0x11a6 <vMainSensorTowerTask+0x246>
    1182:	84 e0       	ldi	r24, 0x04	; 4
    1184:	f8 12       	cpse	r15, r24
    1186:	0f c0       	rjmp	.+30     	; 0x11a6 <vMainSensorTowerTask+0x246>
    1188:	89 81       	ldd	r24, Y+1	; 0x01
    118a:	83 30       	cpi	r24, 0x03	; 3
    118c:	e8 f4       	brcc	.+58     	; 0x11c8 <vMainSensorTowerTask+0x268>
                servoStep++;
    118e:	1f 5f       	subi	r17, 0xFF	; 255
            }
            else if ((servoStep*servoResolution > 0) && (rotationDirection == moveClockwise) && (robotMovement < moveClockwise)){
                servoStep --;
            }
            
            if ((servoStep*servoResolution >= 90) && (rotationDirection == moveCounterClockwise)){
    1190:	18 9d       	mul	r17, r8
    1192:	60 01       	movw	r12, r0
    1194:	19 9d       	mul	r17, r9
    1196:	d0 0c       	add	r13, r0
    1198:	11 24       	eor	r1, r1
    119a:	8a e5       	ldi	r24, 0x5A	; 90
    119c:	c8 16       	cp	r12, r24
    119e:	d1 04       	cpc	r13, r1
    11a0:	0c f0       	brlt	.+2      	; 0x11a4 <vMainSensorTowerTask+0x244>
    11a2:	04 cf       	rjmp	.-504    	; 0xfac <vMainSensorTowerTask+0x4c>
    11a4:	1b c0       	rjmp	.+54     	; 0x11dc <vMainSensorTowerTask+0x27c>
            
            // Iterate in a increasing/decreasing manner and depending on the robots movement
            if ((servoStep*servoResolution <= 90) && (rotationDirection == moveCounterClockwise) && (robotMovement < moveClockwise)){
                servoStep++;
            }
            else if ((servoStep*servoResolution > 0) && (rotationDirection == moveClockwise) && (robotMovement < moveClockwise)){
    11a6:	1c 14       	cp	r1, r12
    11a8:	1d 04       	cpc	r1, r13
    11aa:	8c f5       	brge	.+98     	; 0x120e <vMainSensorTowerTask+0x2ae>
    11ac:	83 e0       	ldi	r24, 0x03	; 3
    11ae:	f8 12       	cpse	r15, r24
    11b0:	29 c0       	rjmp	.+82     	; 0x1204 <vMainSensorTowerTask+0x2a4>
    11b2:	89 81       	ldd	r24, Y+1	; 0x01
    11b4:	83 30       	cpi	r24, 0x03	; 3
    11b6:	08 f0       	brcs	.+2      	; 0x11ba <vMainSensorTowerTask+0x25a>
    11b8:	00 cf       	rjmp	.-512    	; 0xfba <vMainSensorTowerTask+0x5a>
                servoStep --;
    11ba:	11 50       	subi	r17, 0x01	; 1
            }
            
            if ((servoStep*servoResolution >= 90) && (rotationDirection == moveCounterClockwise)){
    11bc:	18 9d       	mul	r17, r8
    11be:	60 01       	movw	r12, r0
    11c0:	19 9d       	mul	r17, r9
    11c2:	d0 0c       	add	r13, r0
    11c4:	11 24       	eor	r1, r1
    11c6:	0a c0       	rjmp	.+20     	; 0x11dc <vMainSensorTowerTask+0x27c>
    11c8:	8a e5       	ldi	r24, 0x5A	; 90
    11ca:	c8 16       	cp	r12, r24
    11cc:	d1 04       	cpc	r13, r1
    11ce:	0c f0       	brlt	.+2      	; 0x11d2 <vMainSensorTowerTask+0x272>
    11d0:	ef ce       	rjmp	.-546    	; 0xfb0 <vMainSensorTowerTask+0x50>
    11d2:	04 c0       	rjmp	.+8      	; 0x11dc <vMainSensorTowerTask+0x27c>
    11d4:	84 e0       	ldi	r24, 0x04	; 4
    11d6:	f8 16       	cp	r15, r24
    11d8:	09 f4       	brne	.+2      	; 0x11dc <vMainSensorTowerTask+0x27c>
    11da:	ec ce       	rjmp	.-552    	; 0xfb4 <vMainSensorTowerTask+0x54>
                rotationDirection = moveClockwise;
            }
            else if ((servoStep*servoResolution <= 0) && (rotationDirection == moveClockwise)){
    11dc:	1c 14       	cp	r1, r12
    11de:	1d 04       	cpc	r1, r13
    11e0:	0c f4       	brge	.+2      	; 0x11e4 <vMainSensorTowerTask+0x284>
    11e2:	eb ce       	rjmp	.-554    	; 0xfba <vMainSensorTowerTask+0x5a>
    11e4:	83 e0       	ldi	r24, 0x03	; 3
    11e6:	f8 12       	cpse	r15, r24
    11e8:	e8 ce       	rjmp	.-560    	; 0xfba <vMainSensorTowerTask+0x5a>
                rotationDirection = moveCounterClockwise;
    11ea:	fe 2c       	mov	r15, r14
    11ec:	e6 ce       	rjmp	.-564    	; 0xfba <vMainSensorTowerTask+0x5a>
            }
            
            vTaskDelay(200 / portTICK_PERIOD_MS);
        */
        else{ // Disconnected or unconfirmed
            vServo_setAngle(0);
    11ee:	80 e0       	ldi	r24, 0x00	; 0
    11f0:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <vServo_setAngle>
            // Reset servo incrementation
            rotationDirection = moveCounterClockwise;
            servoStep = 0;
            idleCounter = 0;
            vTaskDelay(100/portTICK_PERIOD_MS);
    11f4:	84 e6       	ldi	r24, 0x64	; 100
    11f6:	90 e0       	ldi	r25, 0x00	; 0
    11f8:	0e 94 c6 1f 	call	0x3f8c	; 0x3f8c <vTaskDelay>
        else{ // Disconnected or unconfirmed
            vServo_setAngle(0);
            // Reset servo incrementation
            rotationDirection = moveCounterClockwise;
            servoStep = 0;
            idleCounter = 0;
    11fc:	00 e0       	ldi	r16, 0x00	; 0
        */
        else{ // Disconnected or unconfirmed
            vServo_setAngle(0);
            // Reset servo incrementation
            rotationDirection = moveCounterClockwise;
            servoStep = 0;
    11fe:	10 e0       	ldi	r17, 0x00	; 0
            vTaskDelay(200 / portTICK_PERIOD_MS);
        */
        else{ // Disconnected or unconfirmed
            vServo_setAngle(0);
            // Reset servo incrementation
            rotationDirection = moveCounterClockwise;
    1200:	fe 2c       	mov	r15, r14
    1202:	db ce       	rjmp	.-586    	; 0xfba <vMainSensorTowerTask+0x5a>
            }
            else if ((servoStep*servoResolution > 0) && (rotationDirection == moveClockwise) && (robotMovement < moveClockwise)){
                servoStep --;
            }
            
            if ((servoStep*servoResolution >= 90) && (rotationDirection == moveCounterClockwise)){
    1204:	8a e5       	ldi	r24, 0x5A	; 90
    1206:	c8 16       	cp	r12, r24
    1208:	d1 04       	cpc	r13, r1
    120a:	24 f7       	brge	.-56     	; 0x11d4 <vMainSensorTowerTask+0x274>
    120c:	d6 ce       	rjmp	.-596    	; 0xfba <vMainSensorTowerTask+0x5a>
    120e:	8a e5       	ldi	r24, 0x5A	; 90
    1210:	c8 16       	cp	r12, r24
    1212:	d1 04       	cpc	r13, r1
    1214:	3c f3       	brlt	.-50     	; 0x11e4 <vMainSensorTowerTask+0x284>
    1216:	84 e0       	ldi	r24, 0x04	; 4
    1218:	f8 12       	cpse	r15, r24
    121a:	e4 cf       	rjmp	.-56     	; 0x11e4 <vMainSensorTowerTask+0x284>
    121c:	cd ce       	rjmp	.-614    	; 0xfb8 <vMainSensorTowerTask+0x58>

0000121e <vMainPoseControllerTask>:
        }
    }// While end
}

/*  Calculates new settings for the movement task */
void vMainPoseControllerTask( void *pvParameters ){
    121e:	cf 93       	push	r28
    1220:	df 93       	push	r29
    1222:	cd b7       	in	r28, 0x3d	; 61
    1224:	de b7       	in	r29, 0x3e	; 62
    1226:	ae 97       	sbiw	r28, 0x2e	; 46
    1228:	0f b6       	in	r0, 0x3f	; 63
    122a:	f8 94       	cli
    122c:	de bf       	out	0x3e, r29	; 62
    122e:	0f be       	out	0x3f, r0	; 63
    1230:	cd bf       	out	0x3d, r28	; 61
    #ifdef DEBUG
        printf("PoseController OK\n");
    1232:	86 e7       	ldi	r24, 0x76	; 118
    1234:	96 e0       	ldi	r25, 0x06	; 6
    1236:	0e 94 f9 2f 	call	0x5ff2	; 0x5ff2 <puts>
        uint8_t tellar = 0;
    #endif
    /* Task init */    
    struct sPolar Setpoint = {0}; // Updates from server
    123a:	86 e0       	ldi	r24, 0x06	; 6
    123c:	fe 01       	movw	r30, r28
    123e:	31 96       	adiw	r30, 0x01	; 1
    1240:	df 01       	movw	r26, r30
    1242:	28 2f       	mov	r18, r24
    1244:	1d 92       	st	X+, r1
    1246:	2a 95       	dec	r18
    1248:	e9 f7       	brne	.-6      	; 0x1244 <vMainPoseControllerTask+0x26>
    struct sPolar Error = {0}; // Error values
    124a:	36 96       	adiw	r30, 0x06	; 6
    124c:	df 01       	movw	r26, r30
    124e:	1d 92       	st	X+, r1
    1250:	8a 95       	dec	r24
    1252:	e9 f7       	brne	.-6      	; 0x124e <vMainPoseControllerTask+0x30>
    struct sPolar oldVal = {0};
    struct sPolar referenceModel = {0};
      
    uint8_t correctHeading = TRUE;
    uint8_t correctDistance = TRUE;
    uint8_t rotDir = moveStop;
    1254:	1d 86       	std	Y+13, r1	; 0x0d
    uint8_t moveDir = moveStop;
    1256:	1e 86       	std	Y+14, r1	; 0x0e
    /* Task init */    
    struct sPolar Setpoint = {0}; // Updates from server
    struct sPolar Error = {0}; // Error values
    struct sPolar Epsilon = {0.05235,1}; // Acceptable error {rad,cm} 
    struct sPolar oldVal = {0};
    struct sPolar referenceModel = {0};
    1258:	18 a2       	std	Y+32, r1	; 0x20
    125a:	1f 8e       	std	Y+31, r1	; 0x1f
    125c:	19 a2       	std	Y+33, r1	; 0x21
    125e:	1a a2       	std	Y+34, r1	; 0x22
    1260:	1b a2       	std	Y+35, r1	; 0x23
    1262:	1c a2       	std	Y+36, r1	; 0x24
    #endif
    /* Task init */    
    struct sPolar Setpoint = {0}; // Updates from server
    struct sPolar Error = {0}; // Error values
    struct sPolar Epsilon = {0.05235,1}; // Acceptable error {rad,cm} 
    struct sPolar oldVal = {0};
    1264:	1e a2       	std	Y+38, r1	; 0x26
    1266:	1d a2       	std	Y+37, r1	; 0x25
    1268:	1b a6       	std	Y+43, r1	; 0x2b
    126a:	1c a6       	std	Y+44, r1	; 0x2c
    126c:	1d a6       	std	Y+45, r1	; 0x2d
    126e:	1e a6       	std	Y+46, r1	; 0x2e
    float thetahat = 0;
    float integrator = 0;
    int16_t xhat = 0;
    int16_t yhat = 0;
    int16_t xInit = 0;
    int16_t yInit = 0;
    1270:	1a a6       	std	Y+42, r1	; 0x2a
    1272:	19 a6       	std	Y+41, r1	; 0x29
    
    float thetahat = 0;
    float integrator = 0;
    int16_t xhat = 0;
    int16_t yhat = 0;
    int16_t xInit = 0;
    1274:	18 a6       	std	Y+40, r1	; 0x28
    1276:	1f a2       	std	Y+39, r1	; 0x27
    uint8_t correctDistance = TRUE;
    uint8_t rotDir = moveStop;
    uint8_t moveDir = moveStop;
    
    float thetahat = 0;
    float integrator = 0;
    1278:	1c 8e       	std	Y+28, r1	; 0x1c
    127a:	1d 8e       	std	Y+29, r1	; 0x1d
    127c:	1e 8e       	std	Y+30, r1	; 0x1e
    127e:	00 e0       	ldi	r16, 0x00	; 0
    struct sPolar Epsilon = {0.05235,1}; // Acceptable error {rad,cm} 
    struct sPolar oldVal = {0};
    struct sPolar referenceModel = {0};
      
    uint8_t correctHeading = TRUE;
    uint8_t correctDistance = TRUE;
    1280:	11 e0       	ldi	r17, 0x01	; 1
    struct sPolar Error = {0}; // Error values
    struct sPolar Epsilon = {0.05235,1}; // Acceptable error {rad,cm} 
    struct sPolar oldVal = {0};
    struct sPolar referenceModel = {0};
      
    uint8_t correctHeading = TRUE;
    1282:	22 24       	eor	r2, r2
    1284:	23 94       	inc	r2
            } // No semaphore available, task is blocking
        } //if(gHandshook) end
        else{
            // Reset controller
            correctHeading = TRUE;
            correctDistance = TRUE;
    1286:	33 24       	eor	r3, r3
    1288:	33 94       	inc	r3
    int16_t yInit = 0;
    
    
    while(1){
        // Checking if server is ready
        if (gHandshook){
    128a:	80 91 80 1a 	lds	r24, 0x1A80	; 0x801a80 <gHandshook>
    128e:	88 23       	and	r24, r24
    1290:	09 f4       	brne	.+2      	; 0x1294 <vMainPoseControllerTask+0x76>
    1292:	3a c3       	rjmp	.+1652   	; 0x1908 <vMainPoseControllerTask+0x6ea>
            if (xSemaphoreTake(xControllerBSem, portMAX_DELAY) == pdTRUE){    // Wait for synchronization from estimator
    1294:	20 e0       	ldi	r18, 0x00	; 0
    1296:	4f ef       	ldi	r20, 0xFF	; 255
    1298:	5f ef       	ldi	r21, 0xFF	; 255
    129a:	60 e0       	ldi	r22, 0x00	; 0
    129c:	70 e0       	ldi	r23, 0x00	; 0
    129e:	80 91 18 1b 	lds	r24, 0x1B18	; 0x801b18 <xControllerBSem>
    12a2:	90 91 19 1b 	lds	r25, 0x1B19	; 0x801b19 <xControllerBSem+0x1>
    12a6:	0e 94 34 1b 	call	0x3668	; 0x3668 <xQueueGenericReceive>
    12aa:	81 30       	cpi	r24, 0x01	; 1
    12ac:	71 f7       	brne	.-36     	; 0x128a <vMainPoseControllerTask+0x6c>
                // Get robot pose
                xSemaphoreTake(xPoseMutex,portMAX_DELAY);
    12ae:	20 e0       	ldi	r18, 0x00	; 0
    12b0:	4f ef       	ldi	r20, 0xFF	; 255
    12b2:	5f ef       	ldi	r21, 0xFF	; 255
    12b4:	60 e0       	ldi	r22, 0x00	; 0
    12b6:	70 e0       	ldi	r23, 0x00	; 0
    12b8:	80 91 34 1b 	lds	r24, 0x1B34	; 0x801b34 <xPoseMutex>
    12bc:	90 91 35 1b 	lds	r25, 0x1B35	; 0x801b35 <xPoseMutex+0x1>
    12c0:	0e 94 34 1b 	call	0x3668	; 0x3668 <xQueueGenericReceive>
                    thetahat = gTheta_hat;
    12c4:	70 90 7a 1a 	lds	r7, 0x1A7A	; 0x801a7a <gTheta_hat>
    12c8:	60 90 7b 1a 	lds	r6, 0x1A7B	; 0x801a7b <gTheta_hat+0x1>
    12cc:	50 90 7c 1a 	lds	r5, 0x1A7C	; 0x801a7c <gTheta_hat+0x2>
    12d0:	40 90 7d 1a 	lds	r4, 0x1A7D	; 0x801a7d <gTheta_hat+0x3>
                    xhat = gX_hat;
    12d4:	e0 90 78 1a 	lds	r14, 0x1A78	; 0x801a78 <gX_hat>
    12d8:	f0 90 79 1a 	lds	r15, 0x1A79	; 0x801a79 <gX_hat+0x1>
                    yhat = gY_hat;
    12dc:	c0 90 76 1a 	lds	r12, 0x1A76	; 0x801a76 <gY_hat>
    12e0:	d0 90 77 1a 	lds	r13, 0x1A77	; 0x801a77 <gY_hat+0x1>
                xSemaphoreGive(xPoseMutex);
    12e4:	60 e0       	ldi	r22, 0x00	; 0
    12e6:	70 e0       	ldi	r23, 0x00	; 0
    12e8:	80 91 34 1b 	lds	r24, 0x1B34	; 0x801b34 <xPoseMutex>
    12ec:	90 91 35 1b 	lds	r25, 0x1B35	; 0x801b35 <xPoseMutex+0x1>
    12f0:	0e 94 9a 19 	call	0x3334	; 0x3334 <xQueueGive>
                       
                // Check if a new update is recieved
                if (xQueueReceive(poseControllerQ, &Setpoint, 0) == pdTRUE){
    12f4:	20 e0       	ldi	r18, 0x00	; 0
    12f6:	40 e0       	ldi	r20, 0x00	; 0
    12f8:	50 e0       	ldi	r21, 0x00	; 0
    12fa:	be 01       	movw	r22, r28
    12fc:	6f 5f       	subi	r22, 0xFF	; 255
    12fe:	7f 4f       	sbci	r23, 0xFF	; 255
    1300:	80 91 87 1a 	lds	r24, 0x1A87	; 0x801a87 <poseControllerQ>
    1304:	90 91 88 1a 	lds	r25, 0x1A88	; 0x801a88 <poseControllerQ+0x1>
    1308:	0e 94 34 1b 	call	0x3668	; 0x3668 <xQueueGenericReceive>
    130c:	81 30       	cpi	r24, 0x01	; 1
    130e:	09 f0       	breq	.+2      	; 0x1312 <vMainPoseControllerTask+0xf4>
    1310:	d9 c0       	rjmp	.+434    	; 0x14c4 <vMainPoseControllerTask+0x2a6>
                    xQueueReceive(poseControllerQ, &Setpoint, 20 / portTICK_PERIOD_MS); // Receive theta and radius set points from com task, wait for 20ms if necessary
    1312:	20 e0       	ldi	r18, 0x00	; 0
    1314:	44 e1       	ldi	r20, 0x14	; 20
    1316:	50 e0       	ldi	r21, 0x00	; 0
    1318:	be 01       	movw	r22, r28
    131a:	6f 5f       	subi	r22, 0xFF	; 255
    131c:	7f 4f       	sbci	r23, 0xFF	; 255
    131e:	80 91 87 1a 	lds	r24, 0x1A87	; 0x801a87 <poseControllerQ>
    1322:	90 91 88 1a 	lds	r25, 0x1A88	; 0x801a88 <poseControllerQ+0x1>
    1326:	0e 94 34 1b 	call	0x3668	; 0x3668 <xQueueGenericReceive>
                    // New set points, reset PID controller variables
                    oldVal.heading = 0;
                    oldVal.distance = 0;
                    integrator = 0;
                    
                    if (Setpoint.heading != 0){
    132a:	89 80       	ldd	r8, Y+1	; 0x01
    132c:	9a 80       	ldd	r9, Y+2	; 0x02
    132e:	ab 80       	ldd	r10, Y+3	; 0x03
    1330:	bc 80       	ldd	r11, Y+4	; 0x04
    1332:	20 e0       	ldi	r18, 0x00	; 0
    1334:	30 e0       	ldi	r19, 0x00	; 0
    1336:	40 e0       	ldi	r20, 0x00	; 0
    1338:	50 e0       	ldi	r21, 0x00	; 0
    133a:	c5 01       	movw	r24, r10
    133c:	b4 01       	movw	r22, r8
    133e:	0e 94 d6 27 	call	0x4fac	; 0x4fac <__cmpsf2>
    1342:	88 23       	and	r24, r24
    1344:	09 f1       	breq	.+66     	; 0x1388 <vMainPoseControllerTask+0x16a>
                        // Received setpoint is in (-pi,pi), use sign to decide rotation direction
                        if (Setpoint.heading > 0){
    1346:	20 e0       	ldi	r18, 0x00	; 0
    1348:	30 e0       	ldi	r19, 0x00	; 0
    134a:	40 e0       	ldi	r20, 0x00	; 0
    134c:	50 e0       	ldi	r21, 0x00	; 0
    134e:	c5 01       	movw	r24, r10
    1350:	b4 01       	movw	r22, r8
    1352:	0e 94 86 29 	call	0x530c	; 0x530c <__gesf2>
    1356:	18 16       	cp	r1, r24
    1358:	1c f4       	brge	.+6      	; 0x1360 <vMainPoseControllerTask+0x142>
                            rotDir = moveCounterClockwise;
    135a:	84 e0       	ldi	r24, 0x04	; 4
    135c:	8d 87       	std	Y+13, r24	; 0x0d
    135e:	02 c0       	rjmp	.+4      	; 0x1364 <vMainPoseControllerTask+0x146>
                        }
                        else{
                            rotDir = moveClockwise;
    1360:	83 e0       	ldi	r24, 0x03	; 3
    1362:	8d 87       	std	Y+13, r24	; 0x0d
                        }
                        Setpoint.heading += thetahat; // Adjust set point relative to current heading
    1364:	a5 01       	movw	r20, r10
    1366:	94 01       	movw	r18, r8
    1368:	67 2d       	mov	r22, r7
    136a:	76 2d       	mov	r23, r6
    136c:	85 2d       	mov	r24, r5
    136e:	94 2d       	mov	r25, r4
    1370:	0e 94 10 27 	call	0x4e20	; 0x4e20 <__addsf3>
    1374:	69 83       	std	Y+1, r22	; 0x01
    1376:	7a 83       	std	Y+2, r23	; 0x02
    1378:	8b 83       	std	Y+3, r24	; 0x03
    137a:	9c 83       	std	Y+4, r25	; 0x04
                        // Initialize reference model
                        referenceModel.heading = thetahat;
    137c:	79 a2       	std	Y+33, r7	; 0x21
    137e:	6a a2       	std	Y+34, r6	; 0x22
    1380:	5b a2       	std	Y+35, r5	; 0x23
    1382:	4c a2       	std	Y+36, r4	; 0x24
                        correctHeading = FALSE;
    1384:	21 2c       	mov	r2, r1
    1386:	1b c0       	rjmp	.+54     	; 0x13be <vMainPoseControllerTask+0x1a0>
                    }
                    else if (Setpoint.heading == 0){
                        correctHeading = TRUE;
                        rotDir = moveStop;
    1388:	1d 86       	std	Y+13, r1	; 0x0d
                        uint8_t actuation = 0;
    138a:	1f 86       	std	Y+15, r1	; 0x0f
                        xQueueSend(movementQ, &rotDir, 0);
    138c:	20 e0       	ldi	r18, 0x00	; 0
    138e:	40 e0       	ldi	r20, 0x00	; 0
    1390:	50 e0       	ldi	r21, 0x00	; 0
    1392:	be 01       	movw	r22, r28
    1394:	63 5f       	subi	r22, 0xF3	; 243
    1396:	7f 4f       	sbci	r23, 0xFF	; 255
    1398:	80 91 89 1a 	lds	r24, 0x1A89	; 0x801a89 <movementQ>
    139c:	90 91 8a 1a 	lds	r25, 0x1A8A	; 0x801a8a <movementQ+0x1>
    13a0:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <xQueueGenericSend>
                        xQueueSend(actuationQ, &actuation, 0);                        
    13a4:	20 e0       	ldi	r18, 0x00	; 0
    13a6:	40 e0       	ldi	r20, 0x00	; 0
    13a8:	50 e0       	ldi	r21, 0x00	; 0
    13aa:	be 01       	movw	r22, r28
    13ac:	61 5f       	subi	r22, 0xF1	; 241
    13ae:	7f 4f       	sbci	r23, 0xFF	; 255
    13b0:	80 91 83 1a 	lds	r24, 0x1A83	; 0x801a83 <actuationQ>
    13b4:	90 91 84 1a 	lds	r25, 0x1A84	; 0x801a84 <actuationQ+0x1>
    13b8:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <xQueueGenericSend>
                        // Initialize reference model
                        referenceModel.heading = thetahat;
                        correctHeading = FALSE;
                    }
                    else if (Setpoint.heading == 0){
                        correctHeading = TRUE;
    13bc:	23 2c       	mov	r2, r3
                        uint8_t actuation = 0;
                        xQueueSend(movementQ, &rotDir, 0);
                        xQueueSend(actuationQ, &actuation, 0);                        
                    }
                    
                    if (Setpoint.distance != 0){
    13be:	8d 81       	ldd	r24, Y+5	; 0x05
    13c0:	9e 81       	ldd	r25, Y+6	; 0x06
    13c2:	00 97       	sbiw	r24, 0x00	; 0
    13c4:	81 f1       	breq	.+96     	; 0x1426 <vMainPoseControllerTask+0x208>
                        // Use sign to decide direction
                        if (Setpoint.distance > 0){
    13c6:	14 f0       	brlt	.+4      	; 0x13cc <vMainPoseControllerTask+0x1ae>
                            moveDir = moveForward;
    13c8:	3e 86       	std	Y+14, r3	; 0x0e
    13ca:	02 c0       	rjmp	.+4      	; 0x13d0 <vMainPoseControllerTask+0x1b2>
                        }
                        else {
                            moveDir = moveBackward;
    13cc:	b2 e0       	ldi	r27, 0x02	; 2
    13ce:	be 87       	std	Y+14, r27	; 0x0e
                        }
                        // Initalize X and Y
                        xInit = xhat;
                        yInit = yhat;
                        // Initialize reference model
                        int16_t xSquaredCm = xhat * xhat / 100;
    13d0:	ee 9c       	mul	r14, r14
    13d2:	c0 01       	movw	r24, r0
    13d4:	ef 9c       	mul	r14, r15
    13d6:	90 0d       	add	r25, r0
    13d8:	90 0d       	add	r25, r0
    13da:	11 24       	eor	r1, r1
    13dc:	24 e6       	ldi	r18, 0x64	; 100
    13de:	30 e0       	ldi	r19, 0x00	; 0
    13e0:	b9 01       	movw	r22, r18
    13e2:	0e 94 ed 2d 	call	0x5bda	; 0x5bda <__divmodhi4>
    13e6:	4b 01       	movw	r8, r22
                        int16_t ySquaredCm = yhat * yhat / 100;
    13e8:	cc 9c       	mul	r12, r12
    13ea:	c0 01       	movw	r24, r0
    13ec:	cd 9c       	mul	r12, r13
    13ee:	90 0d       	add	r25, r0
    13f0:	90 0d       	add	r25, r0
    13f2:	11 24       	eor	r1, r1
    13f4:	b9 01       	movw	r22, r18
    13f6:	0e 94 ed 2d 	call	0x5bda	; 0x5bda <__divmodhi4>
                        referenceModel.distance = sqrt(xSquaredCm + ySquaredCm); 
    13fa:	86 0e       	add	r8, r22
    13fc:	97 1e       	adc	r9, r23
    13fe:	09 2c       	mov	r0, r9
    1400:	00 0c       	add	r0, r0
    1402:	aa 08       	sbc	r10, r10
    1404:	bb 08       	sbc	r11, r11
    1406:	c5 01       	movw	r24, r10
    1408:	b4 01       	movw	r22, r8
    140a:	0e 94 78 28 	call	0x50f0	; 0x50f0 <__floatsisf>
    140e:	0e 94 fe 29 	call	0x53fc	; 0x53fc <sqrt>
    1412:	0e 94 45 28 	call	0x508a	; 0x508a <__fixsfsi>
    1416:	78 a3       	std	Y+32, r23	; 0x20
    1418:	6f 8f       	std	Y+31, r22	; 0x1f
                        else {
                            moveDir = moveBackward;
                        }
                        // Initalize X and Y
                        xInit = xhat;
                        yInit = yhat;
    141a:	da a6       	std	Y+42, r13	; 0x2a
    141c:	c9 a6       	std	Y+41, r12	; 0x29
                        }
                        else {
                            moveDir = moveBackward;
                        }
                        // Initalize X and Y
                        xInit = xhat;
    141e:	f8 a6       	std	Y+40, r15	; 0x28
    1420:	ef a2       	std	Y+39, r14	; 0x27
                        yInit = yhat;
                        // Initialize reference model
                        int16_t xSquaredCm = xhat * xhat / 100;
                        int16_t ySquaredCm = yhat * yhat / 100;
                        referenceModel.distance = sqrt(xSquaredCm + ySquaredCm); 
                        correctDistance = FALSE;
    1422:	10 e0       	ldi	r17, 0x00	; 0
    1424:	1b c0       	rjmp	.+54     	; 0x145c <vMainPoseControllerTask+0x23e>
                    }
                    else if (Setpoint.distance == 0){
                        correctDistance = TRUE;
                        moveDir = moveStop;
    1426:	1e 86       	std	Y+14, r1	; 0x0e
                        uint8_t actuation = 0;
    1428:	1f 86       	std	Y+15, r1	; 0x0f
                        xQueueSend(movementQ, &moveDir, 0);
    142a:	20 e0       	ldi	r18, 0x00	; 0
    142c:	40 e0       	ldi	r20, 0x00	; 0
    142e:	50 e0       	ldi	r21, 0x00	; 0
    1430:	be 01       	movw	r22, r28
    1432:	62 5f       	subi	r22, 0xF2	; 242
    1434:	7f 4f       	sbci	r23, 0xFF	; 255
    1436:	80 91 89 1a 	lds	r24, 0x1A89	; 0x801a89 <movementQ>
    143a:	90 91 8a 1a 	lds	r25, 0x1A8A	; 0x801a8a <movementQ+0x1>
    143e:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <xQueueGenericSend>
                        xQueueSend(actuationQ, &actuation, 0);  
    1442:	20 e0       	ldi	r18, 0x00	; 0
    1444:	40 e0       	ldi	r20, 0x00	; 0
    1446:	50 e0       	ldi	r21, 0x00	; 0
    1448:	be 01       	movw	r22, r28
    144a:	61 5f       	subi	r22, 0xF1	; 241
    144c:	7f 4f       	sbci	r23, 0xFF	; 255
    144e:	80 91 83 1a 	lds	r24, 0x1A83	; 0x801a83 <actuationQ>
    1452:	90 91 84 1a 	lds	r25, 0x1A84	; 0x801a84 <actuationQ+0x1>
    1456:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <xQueueGenericSend>
                        int16_t ySquaredCm = yhat * yhat / 100;
                        referenceModel.distance = sqrt(xSquaredCm + ySquaredCm); 
                        correctDistance = FALSE;
                    }
                    else if (Setpoint.distance == 0){
                        correctDistance = TRUE;
    145a:	13 2d       	mov	r17, r3
                        uint8_t actuation = 0;
                        xQueueSend(movementQ, &moveDir, 0);
                        xQueueSend(actuationQ, &actuation, 0);  
                    }
                    
                    if ((Setpoint.distance == 0) && (Setpoint.heading == 0)){
    145c:	8d 81       	ldd	r24, Y+5	; 0x05
    145e:	9e 81       	ldd	r25, Y+6	; 0x06
    1460:	89 2b       	or	r24, r25
    1462:	d9 f4       	brne	.+54     	; 0x149a <vMainPoseControllerTask+0x27c>
    1464:	20 e0       	ldi	r18, 0x00	; 0
    1466:	30 e0       	ldi	r19, 0x00	; 0
    1468:	40 e0       	ldi	r20, 0x00	; 0
    146a:	50 e0       	ldi	r21, 0x00	; 0
    146c:	69 81       	ldd	r22, Y+1	; 0x01
    146e:	7a 81       	ldd	r23, Y+2	; 0x02
    1470:	8b 81       	ldd	r24, Y+3	; 0x03
    1472:	9c 81       	ldd	r25, Y+4	; 0x04
    1474:	0e 94 d6 27 	call	0x4fac	; 0x4fac <__cmpsf2>
    1478:	81 11       	cpse	r24, r1
    147a:	1a c0       	rjmp	.+52     	; 0x14b0 <vMainPoseControllerTask+0x292>
                        printf(STATUS_IDLE"\n");
    147c:	8e e6       	ldi	r24, 0x6E	; 110
    147e:	96 e0       	ldi	r25, 0x06	; 6
    1480:	0e 94 f9 2f 	call	0x5ff2	; 0x5ff2 <puts>
                // Check if a new update is recieved
                if (xQueueReceive(poseControllerQ, &Setpoint, 0) == pdTRUE){
                    xQueueReceive(poseControllerQ, &Setpoint, 20 / portTICK_PERIOD_MS); // Receive theta and radius set points from com task, wait for 20ms if necessary
                    // New set points, reset PID controller variables
                    oldVal.heading = 0;
                    oldVal.distance = 0;
    1484:	1e a2       	std	Y+38, r1	; 0x26
    1486:	1d a2       	std	Y+37, r1	; 0x25
                       
                // Check if a new update is recieved
                if (xQueueReceive(poseControllerQ, &Setpoint, 0) == pdTRUE){
                    xQueueReceive(poseControllerQ, &Setpoint, 20 / portTICK_PERIOD_MS); // Receive theta and radius set points from com task, wait for 20ms if necessary
                    // New set points, reset PID controller variables
                    oldVal.heading = 0;
    1488:	1b a6       	std	Y+43, r1	; 0x2b
    148a:	1c a6       	std	Y+44, r1	; 0x2c
    148c:	1d a6       	std	Y+45, r1	; 0x2d
    148e:	1e a6       	std	Y+46, r1	; 0x2e
                    oldVal.distance = 0;
                    integrator = 0;
    1490:	1c 8e       	std	Y+28, r1	; 0x1c
    1492:	1d 8e       	std	Y+29, r1	; 0x1d
    1494:	1e 8e       	std	Y+30, r1	; 0x1e
    1496:	00 e0       	ldi	r16, 0x00	; 0
    1498:	15 c0       	rjmp	.+42     	; 0x14c4 <vMainPoseControllerTask+0x2a6>
                // Check if a new update is recieved
                if (xQueueReceive(poseControllerQ, &Setpoint, 0) == pdTRUE){
                    xQueueReceive(poseControllerQ, &Setpoint, 20 / portTICK_PERIOD_MS); // Receive theta and radius set points from com task, wait for 20ms if necessary
                    // New set points, reset PID controller variables
                    oldVal.heading = 0;
                    oldVal.distance = 0;
    149a:	1e a2       	std	Y+38, r1	; 0x26
    149c:	1d a2       	std	Y+37, r1	; 0x25
                       
                // Check if a new update is recieved
                if (xQueueReceive(poseControllerQ, &Setpoint, 0) == pdTRUE){
                    xQueueReceive(poseControllerQ, &Setpoint, 20 / portTICK_PERIOD_MS); // Receive theta and radius set points from com task, wait for 20ms if necessary
                    // New set points, reset PID controller variables
                    oldVal.heading = 0;
    149e:	1b a6       	std	Y+43, r1	; 0x2b
    14a0:	1c a6       	std	Y+44, r1	; 0x2c
    14a2:	1d a6       	std	Y+45, r1	; 0x2d
    14a4:	1e a6       	std	Y+46, r1	; 0x2e
                    oldVal.distance = 0;
                    integrator = 0;
    14a6:	1c 8e       	std	Y+28, r1	; 0x1c
    14a8:	1d 8e       	std	Y+29, r1	; 0x1d
    14aa:	1e 8e       	std	Y+30, r1	; 0x1e
    14ac:	00 e0       	ldi	r16, 0x00	; 0
    14ae:	0a c0       	rjmp	.+20     	; 0x14c4 <vMainPoseControllerTask+0x2a6>
                // Check if a new update is recieved
                if (xQueueReceive(poseControllerQ, &Setpoint, 0) == pdTRUE){
                    xQueueReceive(poseControllerQ, &Setpoint, 20 / portTICK_PERIOD_MS); // Receive theta and radius set points from com task, wait for 20ms if necessary
                    // New set points, reset PID controller variables
                    oldVal.heading = 0;
                    oldVal.distance = 0;
    14b0:	1e a2       	std	Y+38, r1	; 0x26
    14b2:	1d a2       	std	Y+37, r1	; 0x25
                       
                // Check if a new update is recieved
                if (xQueueReceive(poseControllerQ, &Setpoint, 0) == pdTRUE){
                    xQueueReceive(poseControllerQ, &Setpoint, 20 / portTICK_PERIOD_MS); // Receive theta and radius set points from com task, wait for 20ms if necessary
                    // New set points, reset PID controller variables
                    oldVal.heading = 0;
    14b4:	1b a6       	std	Y+43, r1	; 0x2b
    14b6:	1c a6       	std	Y+44, r1	; 0x2c
    14b8:	1d a6       	std	Y+45, r1	; 0x2d
    14ba:	1e a6       	std	Y+46, r1	; 0x2e
                    oldVal.distance = 0;
                    integrator = 0;
    14bc:	1c 8e       	std	Y+28, r1	; 0x1c
    14be:	1d 8e       	std	Y+29, r1	; 0x1d
    14c0:	1e 8e       	std	Y+30, r1	; 0x1e
    14c2:	00 e0       	ldi	r16, 0x00	; 0
                    if ((Setpoint.distance == 0) && (Setpoint.heading == 0)){
                        printf(STATUS_IDLE"\n");
                    }
                } // if (xQueueReceive(poseControllerQ, &Setpoint, 0) == pdTRUE) end
                // No new updates from server, update position errors:
                if(correctHeading == FALSE){
    14c4:	21 10       	cpse	r2, r1
    14c6:	21 c1       	rjmp	.+578    	; 0x170a <vMainPoseControllerTask+0x4ec>
                    float referenceDiff  = (Setpoint.heading - referenceModel.heading);
    14c8:	29 a1       	ldd	r18, Y+33	; 0x21
    14ca:	3a a1       	ldd	r19, Y+34	; 0x22
    14cc:	4b a1       	ldd	r20, Y+35	; 0x23
    14ce:	5c a1       	ldd	r21, Y+36	; 0x24
    14d0:	69 81       	ldd	r22, Y+1	; 0x01
    14d2:	7a 81       	ldd	r23, Y+2	; 0x02
    14d4:	8b 81       	ldd	r24, Y+3	; 0x03
    14d6:	9c 81       	ldd	r25, Y+4	; 0x04
    14d8:	0e 94 0f 27 	call	0x4e1e	; 0x4e1e <__subsf3>
    14dc:	6f 8b       	std	Y+23, r22	; 0x17
    14de:	78 8f       	std	Y+24, r23	; 0x18
    14e0:	89 8f       	std	Y+25, r24	; 0x19
    14e2:	9a 8f       	std	Y+26, r25	; 0x1a
                    vFunc_Inf2pi(&referenceDiff);
    14e4:	ce 01       	movw	r24, r28
    14e6:	47 96       	adiw	r24, 0x17	; 23
    14e8:	0e 94 e6 01 	call	0x3cc	; 0x3cc <vFunc_Inf2pi>
                       
                    referenceModel.heading = referenceModel.heading + (referenceDiff) / 10;                    
    14ec:	20 e0       	ldi	r18, 0x00	; 0
    14ee:	30 e0       	ldi	r19, 0x00	; 0
    14f0:	40 e2       	ldi	r20, 0x20	; 32
    14f2:	51 e4       	ldi	r21, 0x41	; 65
    14f4:	6f 89       	ldd	r22, Y+23	; 0x17
    14f6:	78 8d       	ldd	r23, Y+24	; 0x18
    14f8:	89 8d       	ldd	r24, Y+25	; 0x19
    14fa:	9a 8d       	ldd	r25, Y+26	; 0x1a
    14fc:	0e 94 dd 27 	call	0x4fba	; 0x4fba <__divsf3>
    1500:	9b 01       	movw	r18, r22
    1502:	ac 01       	movw	r20, r24
    1504:	69 a1       	ldd	r22, Y+33	; 0x21
    1506:	7a a1       	ldd	r23, Y+34	; 0x22
    1508:	8b a1       	ldd	r24, Y+35	; 0x23
    150a:	9c a1       	ldd	r25, Y+36	; 0x24
    150c:	0e 94 10 27 	call	0x4e20	; 0x4e20 <__addsf3>
    1510:	69 a3       	std	Y+33, r22	; 0x21
    1512:	7a a3       	std	Y+34, r23	; 0x22
    1514:	8b a3       	std	Y+35, r24	; 0x23
    1516:	9c a3       	std	Y+36, r25	; 0x24
                    Error.heading = fabs(referenceModel.heading - thetahat);
    1518:	27 2d       	mov	r18, r7
    151a:	36 2d       	mov	r19, r6
    151c:	45 2d       	mov	r20, r5
    151e:	54 2d       	mov	r21, r4
    1520:	0e 94 0f 27 	call	0x4e1e	; 0x4e1e <__subsf3>
    1524:	dc 01       	movw	r26, r24
    1526:	cb 01       	movw	r24, r22
    1528:	bf 77       	andi	r27, 0x7F	; 127
    152a:	8f 83       	std	Y+7, r24	; 0x07
    152c:	98 87       	std	Y+8, r25	; 0x08
    152e:	a9 87       	std	Y+9, r26	; 0x09
    1530:	ba 87       	std	Y+10, r27	; 0x0a
                    vFunc_Inf2pi(&Error.heading);
    1532:	ce 01       	movw	r24, r28
    1534:	07 96       	adiw	r24, 0x07	; 7
    1536:	0e 94 e6 01 	call	0x3cc	; 0x3cc <vFunc_Inf2pi>
                    
                    // We use cutoff to stop the robot we need to check the condition in a separate variable without the reference model.
                    float headingError = Setpoint.heading - thetahat;
    153a:	27 2d       	mov	r18, r7
    153c:	36 2d       	mov	r19, r6
    153e:	45 2d       	mov	r20, r5
    1540:	54 2d       	mov	r21, r4
    1542:	69 81       	ldd	r22, Y+1	; 0x01
    1544:	7a 81       	ldd	r23, Y+2	; 0x02
    1546:	8b 81       	ldd	r24, Y+3	; 0x03
    1548:	9c 81       	ldd	r25, Y+4	; 0x04
    154a:	0e 94 0f 27 	call	0x4e1e	; 0x4e1e <__subsf3>
    154e:	6b 8b       	std	Y+19, r22	; 0x13
    1550:	7c 8b       	std	Y+20, r23	; 0x14
    1552:	8d 8b       	std	Y+21, r24	; 0x15
    1554:	9e 8b       	std	Y+22, r25	; 0x16
                    vFunc_Inf2pi(&headingError);
    1556:	ce 01       	movw	r24, r28
    1558:	43 96       	adiw	r24, 0x13	; 19
    155a:	0e 94 e6 01 	call	0x3cc	; 0x3cc <vFunc_Inf2pi>
                    
                    if (fabs(headingError) <= Epsilon.heading){
    155e:	8b 89       	ldd	r24, Y+19	; 0x13
    1560:	9c 89       	ldd	r25, Y+20	; 0x14
    1562:	ad 89       	ldd	r26, Y+21	; 0x15
    1564:	be 89       	ldd	r27, Y+22	; 0x16
    1566:	bc 01       	movw	r22, r24
    1568:	cd 01       	movw	r24, r26
    156a:	9f 77       	andi	r25, 0x7F	; 127
    156c:	24 ef       	ldi	r18, 0xF4	; 244
    156e:	3c e6       	ldi	r19, 0x6C	; 108
    1570:	46 e5       	ldi	r20, 0x56	; 86
    1572:	5d e3       	ldi	r21, 0x3D	; 61
    1574:	0e 94 d6 27 	call	0x4fac	; 0x4fac <__cmpsf2>
    1578:	18 16       	cp	r1, r24
    157a:	74 f1       	brlt	.+92     	; 0x15d8 <vMainPoseControllerTask+0x3ba>
                        rotDir = moveStop;
    157c:	1d 86       	std	Y+13, r1	; 0x0d
                        correctHeading = TRUE;
                        Setpoint.heading = 0;
    157e:	80 e0       	ldi	r24, 0x00	; 0
    1580:	90 e0       	ldi	r25, 0x00	; 0
    1582:	a0 e0       	ldi	r26, 0x00	; 0
    1584:	b0 e0       	ldi	r27, 0x00	; 0
    1586:	89 83       	std	Y+1, r24	; 0x01
    1588:	9a 83       	std	Y+2, r25	; 0x02
    158a:	ab 83       	std	Y+3, r26	; 0x03
    158c:	bc 83       	std	Y+4, r27	; 0x04
                        uint8_t actuation = 0;
    158e:	1f 86       	std	Y+15, r1	; 0x0f
                        integrator = 0;
                        xQueueSend(movementQ, &rotDir, 0);
    1590:	20 e0       	ldi	r18, 0x00	; 0
    1592:	40 e0       	ldi	r20, 0x00	; 0
    1594:	50 e0       	ldi	r21, 0x00	; 0
    1596:	be 01       	movw	r22, r28
    1598:	63 5f       	subi	r22, 0xF3	; 243
    159a:	7f 4f       	sbci	r23, 0xFF	; 255
    159c:	80 91 89 1a 	lds	r24, 0x1A89	; 0x801a89 <movementQ>
    15a0:	90 91 8a 1a 	lds	r25, 0x1A8A	; 0x801a8a <movementQ+0x1>
    15a4:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <xQueueGenericSend>
                        if (correctDistance == TRUE){
    15a8:	11 30       	cpi	r17, 0x01	; 1
    15aa:	81 f4       	brne	.+32     	; 0x15cc <vMainPoseControllerTask+0x3ae>
                            xQueueSend(actuationQ, &actuation, 0);
    15ac:	20 e0       	ldi	r18, 0x00	; 0
    15ae:	40 e0       	ldi	r20, 0x00	; 0
    15b0:	50 e0       	ldi	r21, 0x00	; 0
    15b2:	be 01       	movw	r22, r28
    15b4:	61 5f       	subi	r22, 0xF1	; 241
    15b6:	7f 4f       	sbci	r23, 0xFF	; 255
    15b8:	80 91 83 1a 	lds	r24, 0x1A83	; 0x801a83 <actuationQ>
    15bc:	90 91 84 1a 	lds	r25, 0x1A84	; 0x801a84 <actuationQ+0x1>
    15c0:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <xQueueGenericSend>
                            printf(STATUS_IDLE"\n");
    15c4:	8e e6       	ldi	r24, 0x6E	; 110
    15c6:	96 e0       	ldi	r25, 0x06	; 6
    15c8:	0e 94 f9 2f 	call	0x5ff2	; 0x5ff2 <puts>
                    if (fabs(headingError) <= Epsilon.heading){
                        rotDir = moveStop;
                        correctHeading = TRUE;
                        Setpoint.heading = 0;
                        uint8_t actuation = 0;
                        integrator = 0;
    15cc:	1c 8e       	std	Y+28, r1	; 0x1c
    15ce:	1d 8e       	std	Y+29, r1	; 0x1d
    15d0:	1e 8e       	std	Y+30, r1	; 0x1e
    15d2:	00 e0       	ldi	r16, 0x00	; 0
                    float headingError = Setpoint.heading - thetahat;
                    vFunc_Inf2pi(&headingError);
                    
                    if (fabs(headingError) <= Epsilon.heading){
                        rotDir = moveStop;
                        correctHeading = TRUE;
    15d4:	23 2c       	mov	r2, r3
    15d6:	59 ce       	rjmp	.-846    	; 0x128a <vMainPoseControllerTask+0x6c>
                            xQueueSend(actuationQ, &actuation, 0);
                            printf(STATUS_IDLE"\n");
                        }
                    }
                    else{
                        float dHeading = thetahat - oldVal.heading; 
    15d8:	2b a5       	ldd	r18, Y+43	; 0x2b
    15da:	3c a5       	ldd	r19, Y+44	; 0x2c
    15dc:	4d a5       	ldd	r20, Y+45	; 0x2d
    15de:	5e a5       	ldd	r21, Y+46	; 0x2e
    15e0:	67 2d       	mov	r22, r7
    15e2:	76 2d       	mov	r23, r6
    15e4:	85 2d       	mov	r24, r5
    15e6:	94 2d       	mov	r25, r4
    15e8:	0e 94 0f 27 	call	0x4e1e	; 0x4e1e <__subsf3>
    15ec:	6f 87       	std	Y+15, r22	; 0x0f
    15ee:	78 8b       	std	Y+16, r23	; 0x10
    15f0:	89 8b       	std	Y+17, r24	; 0x11
    15f2:	9a 8b       	std	Y+18, r25	; 0x12
                        vFunc_Inf2pi(&dHeading);
    15f4:	ce 01       	movw	r24, r28
    15f6:	0f 96       	adiw	r24, 0x0f	; 15
    15f8:	0e 94 e6 01 	call	0x3cc	; 0x3cc <vFunc_Inf2pi>
                        
                        dHeading = fabs(dHeading) / 0.03; // Divide by sample time in seconds and get positive value
    15fc:	8f 85       	ldd	r24, Y+15	; 0x0f
    15fe:	98 89       	ldd	r25, Y+16	; 0x10
    1600:	a9 89       	ldd	r26, Y+17	; 0x11
    1602:	ba 89       	ldd	r27, Y+18	; 0x12
    1604:	bc 01       	movw	r22, r24
    1606:	cd 01       	movw	r24, r26
    1608:	9f 77       	andi	r25, 0x7F	; 127
    160a:	2f e8       	ldi	r18, 0x8F	; 143
    160c:	32 ec       	ldi	r19, 0xC2	; 194
    160e:	45 ef       	ldi	r20, 0xF5	; 245
    1610:	5c e3       	ldi	r21, 0x3C	; 60
    1612:	0e 94 dd 27 	call	0x4fba	; 0x4fba <__divsf3>
    1616:	4b 01       	movw	r8, r22
    1618:	5c 01       	movw	r10, r24
    161a:	6f 87       	std	Y+15, r22	; 0x0f
    161c:	78 8b       	std	Y+16, r23	; 0x10
    161e:	89 8b       	std	Y+17, r24	; 0x11
    1620:	9a 8b       	std	Y+18, r25	; 0x12
                        
                        integrator += Error.heading;
    1622:	cf 80       	ldd	r12, Y+7	; 0x07
    1624:	d8 84       	ldd	r13, Y+8	; 0x08
    1626:	e9 84       	ldd	r14, Y+9	; 0x09
    1628:	fa 84       	ldd	r15, Y+10	; 0x0a
    162a:	a7 01       	movw	r20, r14
    162c:	96 01       	movw	r18, r12
    162e:	6c 8d       	ldd	r22, Y+28	; 0x1c
    1630:	7d 8d       	ldd	r23, Y+29	; 0x1d
    1632:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1634:	90 2f       	mov	r25, r16
    1636:	0e 94 10 27 	call	0x4e20	; 0x4e20 <__addsf3>
    163a:	6c 8f       	std	Y+28, r22	; 0x1c
    163c:	7d 8f       	std	Y+29, r23	; 0x1d
    163e:	8e 8f       	std	Y+30, r24	; 0x1e
    1640:	09 2f       	mov	r16, r25
                        
                        if (integrator >= 25) integrator = 25;
    1642:	20 e0       	ldi	r18, 0x00	; 0
    1644:	30 e0       	ldi	r19, 0x00	; 0
    1646:	48 ec       	ldi	r20, 0xC8	; 200
    1648:	51 e4       	ldi	r21, 0x41	; 65
    164a:	0e 94 86 29 	call	0x530c	; 0x530c <__gesf2>
    164e:	88 23       	and	r24, r24
    1650:	2c f0       	brlt	.+10     	; 0x165c <vMainPoseControllerTask+0x43e>
    1652:	1c 8e       	std	Y+28, r1	; 0x1c
    1654:	1d 8e       	std	Y+29, r1	; 0x1d
    1656:	28 ec       	ldi	r18, 0xC8	; 200
    1658:	2e 8f       	std	Y+30, r18	; 0x1e
    165a:	01 e4       	ldi	r16, 0x41	; 65
                        
                        float pidOutput = (Error.heading + integrator - dHeading);
    165c:	a7 01       	movw	r20, r14
    165e:	96 01       	movw	r18, r12
    1660:	6c 8d       	ldd	r22, Y+28	; 0x1c
    1662:	7d 8d       	ldd	r23, Y+29	; 0x1d
    1664:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1666:	90 2f       	mov	r25, r16
    1668:	0e 94 10 27 	call	0x4e20	; 0x4e20 <__addsf3>
    166c:	a5 01       	movw	r20, r10
    166e:	94 01       	movw	r18, r8
    1670:	0e 94 0f 27 	call	0x4e1e	; 0x4e1e <__subsf3>
    1674:	d6 2e       	mov	r13, r22
    1676:	c7 2e       	mov	r12, r23
    1678:	f8 2e       	mov	r15, r24
    167a:	e9 2e       	mov	r14, r25
                        
                        if (pidOutput > 25) pidOutput = 25;
    167c:	20 e0       	ldi	r18, 0x00	; 0
    167e:	30 e0       	ldi	r19, 0x00	; 0
    1680:	48 ec       	ldi	r20, 0xC8	; 200
    1682:	51 e4       	ldi	r21, 0x41	; 65
    1684:	0e 94 86 29 	call	0x530c	; 0x530c <__gesf2>
    1688:	18 16       	cp	r1, r24
    168a:	8c f0       	brlt	.+34     	; 0x16ae <vMainPoseControllerTask+0x490>
                        else if (pidOutput < 0) pidOutput = 0;
    168c:	20 e0       	ldi	r18, 0x00	; 0
    168e:	30 e0       	ldi	r19, 0x00	; 0
    1690:	40 e0       	ldi	r20, 0x00	; 0
    1692:	50 e0       	ldi	r21, 0x00	; 0
    1694:	6d 2d       	mov	r22, r13
    1696:	7c 2d       	mov	r23, r12
    1698:	8f 2d       	mov	r24, r15
    169a:	9e 2d       	mov	r25, r14
    169c:	0e 94 d6 27 	call	0x4fac	; 0x4fac <__cmpsf2>
    16a0:	88 23       	and	r24, r24
    16a2:	7c f4       	brge	.+30     	; 0x16c2 <vMainPoseControllerTask+0x4a4>
    16a4:	d1 2c       	mov	r13, r1
    16a6:	c1 2c       	mov	r12, r1
    16a8:	f1 2c       	mov	r15, r1
    16aa:	e1 2c       	mov	r14, r1
    16ac:	0a c0       	rjmp	.+20     	; 0x16c2 <vMainPoseControllerTask+0x4a4>
                        
                        if (integrator >= 25) integrator = 25;
                        
                        float pidOutput = (Error.heading + integrator - dHeading);
                        
                        if (pidOutput > 25) pidOutput = 25;
    16ae:	d1 2c       	mov	r13, r1
    16b0:	c1 2c       	mov	r12, r1
    16b2:	0f 2e       	mov	r0, r31
    16b4:	f8 ec       	ldi	r31, 0xC8	; 200
    16b6:	ff 2e       	mov	r15, r31
    16b8:	f0 2d       	mov	r31, r0
    16ba:	0f 2e       	mov	r0, r31
    16bc:	f1 e4       	ldi	r31, 0x41	; 65
    16be:	ef 2e       	mov	r14, r31
    16c0:	f0 2d       	mov	r31, r0
                        else if (pidOutput < 0) pidOutput = 0;
                        
                        uint8_t actuation = (uint8_t)pidOutput;
    16c2:	6d 2d       	mov	r22, r13
    16c4:	7c 2d       	mov	r23, r12
    16c6:	8f 2d       	mov	r24, r15
    16c8:	9e 2d       	mov	r25, r14
    16ca:	0e 94 4a 28 	call	0x5094	; 0x5094 <__fixunssfsi>
    16ce:	6b 8f       	std	Y+27, r22	; 0x1b
                        
                        xQueueSend(movementQ, &rotDir, 0);
    16d0:	20 e0       	ldi	r18, 0x00	; 0
    16d2:	40 e0       	ldi	r20, 0x00	; 0
    16d4:	50 e0       	ldi	r21, 0x00	; 0
    16d6:	be 01       	movw	r22, r28
    16d8:	63 5f       	subi	r22, 0xF3	; 243
    16da:	7f 4f       	sbci	r23, 0xFF	; 255
    16dc:	80 91 89 1a 	lds	r24, 0x1A89	; 0x801a89 <movementQ>
    16e0:	90 91 8a 1a 	lds	r25, 0x1A8A	; 0x801a8a <movementQ+0x1>
    16e4:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <xQueueGenericSend>
                        xQueueSend(actuationQ, &actuation, 0);
    16e8:	20 e0       	ldi	r18, 0x00	; 0
    16ea:	40 e0       	ldi	r20, 0x00	; 0
    16ec:	50 e0       	ldi	r21, 0x00	; 0
    16ee:	be 01       	movw	r22, r28
    16f0:	65 5e       	subi	r22, 0xE5	; 229
    16f2:	7f 4f       	sbci	r23, 0xFF	; 255
    16f4:	80 91 83 1a 	lds	r24, 0x1A83	; 0x801a83 <actuationQ>
    16f8:	90 91 84 1a 	lds	r25, 0x1A84	; 0x801a84 <actuationQ+0x1>
    16fc:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <xQueueGenericSend>
                        oldVal.heading = thetahat;                        
    1700:	7b a6       	std	Y+43, r7	; 0x2b
    1702:	6c a6       	std	Y+44, r6	; 0x2c
    1704:	5d a6       	std	Y+45, r5	; 0x2d
    1706:	4e a6       	std	Y+46, r4	; 0x2e
    1708:	c0 cd       	rjmp	.-1152   	; 0x128a <vMainPoseControllerTask+0x6c>
                    }
                }
                else if (correctDistance == FALSE){
    170a:	11 11       	cpse	r17, r1
    170c:	be cd       	rjmp	.-1156   	; 0x128a <vMainPoseControllerTask+0x6c>
                    int16_t diffX = (xInit - xhat) / 10;
    170e:	8f a1       	ldd	r24, Y+39	; 0x27
    1710:	98 a5       	ldd	r25, Y+40	; 0x28
    1712:	8e 19       	sub	r24, r14
    1714:	9f 09       	sbc	r25, r15
    1716:	6a e0       	ldi	r22, 0x0A	; 10
    1718:	70 e0       	ldi	r23, 0x00	; 0
    171a:	0e 94 ed 2d 	call	0x5bda	; 0x5bda <__divmodhi4>
    171e:	fb 01       	movw	r30, r22
                    int16_t diffY = (yInit - yhat) / 10;
    1720:	89 a5       	ldd	r24, Y+41	; 0x29
    1722:	9a a5       	ldd	r25, Y+42	; 0x2a
    1724:	8c 19       	sub	r24, r12
    1726:	9d 09       	sbc	r25, r13
    1728:	6a e0       	ldi	r22, 0x0A	; 10
    172a:	70 e0       	ldi	r23, 0x00	; 0
    172c:	0e 94 ed 2d 	call	0x5bda	; 0x5bda <__divmodhi4>
    1730:	9b 01       	movw	r18, r22
                    
                    diffX *= diffX;
                    diffY *= diffY;

                    referenceModel.distance = referenceModel.distance + (abs(Setpoint.distance) - referenceModel.distance) / 10;
    1732:	ed 80       	ldd	r14, Y+5	; 0x05
    1734:	fe 80       	ldd	r15, Y+6	; 0x06
    1736:	ff 20       	and	r15, r15
    1738:	1c f4       	brge	.+6      	; 0x1740 <vMainPoseControllerTask+0x522>
    173a:	f1 94       	neg	r15
    173c:	e1 94       	neg	r14
    173e:	f1 08       	sbc	r15, r1
    1740:	c7 01       	movw	r24, r14
    1742:	4f 8d       	ldd	r20, Y+31	; 0x1f
    1744:	58 a1       	ldd	r21, Y+32	; 0x20
    1746:	84 1b       	sub	r24, r20
    1748:	95 0b       	sbc	r25, r21
    174a:	6a e0       	ldi	r22, 0x0A	; 10
    174c:	70 e0       	ldi	r23, 0x00	; 0
    174e:	0e 94 ed 2d 	call	0x5bda	; 0x5bda <__divmodhi4>
    1752:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1754:	98 a1       	ldd	r25, Y+32	; 0x20
    1756:	86 0f       	add	r24, r22
    1758:	97 1f       	adc	r25, r23
    175a:	98 a3       	std	Y+32, r25	; 0x20
    175c:	8f 8f       	std	Y+31, r24	; 0x1f
                }
                else if (correctDistance == FALSE){
                    int16_t diffX = (xInit - xhat) / 10;
                    int16_t diffY = (yInit - yhat) / 10;
                    
                    diffX *= diffX;
    175e:	ee 9f       	mul	r30, r30
    1760:	40 01       	movw	r8, r0
    1762:	ef 9f       	mul	r30, r31
    1764:	90 0c       	add	r9, r0
    1766:	90 0c       	add	r9, r0
    1768:	11 24       	eor	r1, r1
                    diffY *= diffY;
    176a:	22 9f       	mul	r18, r18
    176c:	c0 01       	movw	r24, r0
    176e:	23 9f       	mul	r18, r19
    1770:	90 0d       	add	r25, r0
    1772:	90 0d       	add	r25, r0
    1774:	11 24       	eor	r1, r1

                    referenceModel.distance = referenceModel.distance + (abs(Setpoint.distance) - referenceModel.distance) / 10;
                    Error.distance = referenceModel.distance - sqrt((diffX + diffY));
    1776:	88 0e       	add	r8, r24
    1778:	99 1e       	adc	r9, r25
    177a:	09 2c       	mov	r0, r9
    177c:	00 0c       	add	r0, r0
    177e:	aa 08       	sbc	r10, r10
    1780:	bb 08       	sbc	r11, r11
    1782:	c5 01       	movw	r24, r10
    1784:	b4 01       	movw	r22, r8
    1786:	0e 94 78 28 	call	0x50f0	; 0x50f0 <__floatsisf>
    178a:	0e 94 fe 29 	call	0x53fc	; 0x53fc <sqrt>
    178e:	2b 01       	movw	r4, r22
    1790:	3c 01       	movw	r6, r24
    1792:	af 8d       	ldd	r26, Y+31	; 0x1f
    1794:	b8 a1       	ldd	r27, Y+32	; 0x20
    1796:	bd 01       	movw	r22, r26
    1798:	bb 0f       	add	r27, r27
    179a:	88 0b       	sbc	r24, r24
    179c:	99 0b       	sbc	r25, r25
    179e:	0e 94 78 28 	call	0x50f0	; 0x50f0 <__floatsisf>
    17a2:	a3 01       	movw	r20, r6
    17a4:	92 01       	movw	r18, r4
    17a6:	0e 94 0f 27 	call	0x4e1e	; 0x4e1e <__subsf3>
    17aa:	0e 94 45 28 	call	0x508a	; 0x508a <__fixsfsi>
    17ae:	4b 01       	movw	r8, r22
    17b0:	5c 01       	movw	r10, r24
    17b2:	7c 87       	std	Y+12, r23	; 0x0c
    17b4:	6b 87       	std	Y+11, r22	; 0x0b
                    
                    // Since we use cutoff to stop the robot we need to check the condition in a separate variable without the reference model.
                    int16_t errorDistance = abs(Setpoint.distance) - sqrt((diffX + diffY));
    17b6:	b7 01       	movw	r22, r14
    17b8:	ff 0c       	add	r15, r15
    17ba:	88 0b       	sbc	r24, r24
    17bc:	99 0b       	sbc	r25, r25
    17be:	0e 94 78 28 	call	0x50f0	; 0x50f0 <__floatsisf>
    17c2:	a3 01       	movw	r20, r6
    17c4:	92 01       	movw	r18, r4
    17c6:	0e 94 0f 27 	call	0x4e1e	; 0x4e1e <__subsf3>
    17ca:	0e 94 45 28 	call	0x508a	; 0x508a <__fixsfsi>
                    
                    if (errorDistance <= Epsilon.distance){
    17ce:	62 30       	cpi	r22, 0x02	; 2
    17d0:	71 05       	cpc	r23, r1
    17d2:	34 f5       	brge	.+76     	; 0x1820 <vMainPoseControllerTask+0x602>
                        moveDir = moveStop;
    17d4:	1e 86       	std	Y+14, r1	; 0x0e
                        correctDistance = TRUE;
                        Setpoint.distance = 0;
    17d6:	1e 82       	std	Y+6, r1	; 0x06
    17d8:	1d 82       	std	Y+5, r1	; 0x05
                        integrator = 0;
                        uint8_t actuation = 0;
    17da:	1f 86       	std	Y+15, r1	; 0x0f
                        printf(STATUS_IDLE"\n"); 
    17dc:	8e e6       	ldi	r24, 0x6E	; 110
    17de:	96 e0       	ldi	r25, 0x06	; 6
    17e0:	0e 94 f9 2f 	call	0x5ff2	; 0x5ff2 <puts>
                        xQueueSend(movementQ, &moveDir, 0);
    17e4:	20 e0       	ldi	r18, 0x00	; 0
    17e6:	40 e0       	ldi	r20, 0x00	; 0
    17e8:	50 e0       	ldi	r21, 0x00	; 0
    17ea:	be 01       	movw	r22, r28
    17ec:	62 5f       	subi	r22, 0xF2	; 242
    17ee:	7f 4f       	sbci	r23, 0xFF	; 255
    17f0:	80 91 89 1a 	lds	r24, 0x1A89	; 0x801a89 <movementQ>
    17f4:	90 91 8a 1a 	lds	r25, 0x1A8A	; 0x801a8a <movementQ+0x1>
    17f8:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <xQueueGenericSend>
                        xQueueSend(actuationQ, &actuation, 0);                        
    17fc:	20 e0       	ldi	r18, 0x00	; 0
    17fe:	40 e0       	ldi	r20, 0x00	; 0
    1800:	50 e0       	ldi	r21, 0x00	; 0
    1802:	be 01       	movw	r22, r28
    1804:	61 5f       	subi	r22, 0xF1	; 241
    1806:	7f 4f       	sbci	r23, 0xFF	; 255
    1808:	80 91 83 1a 	lds	r24, 0x1A83	; 0x801a83 <actuationQ>
    180c:	90 91 84 1a 	lds	r25, 0x1A84	; 0x801a84 <actuationQ+0x1>
    1810:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <xQueueGenericSend>
                    
                    if (errorDistance <= Epsilon.distance){
                        moveDir = moveStop;
                        correctDistance = TRUE;
                        Setpoint.distance = 0;
                        integrator = 0;
    1814:	1c 8e       	std	Y+28, r1	; 0x1c
    1816:	1d 8e       	std	Y+29, r1	; 0x1d
    1818:	1e 8e       	std	Y+30, r1	; 0x1e
    181a:	00 e0       	ldi	r16, 0x00	; 0
                    // Since we use cutoff to stop the robot we need to check the condition in a separate variable without the reference model.
                    int16_t errorDistance = abs(Setpoint.distance) - sqrt((diffX + diffY));
                    
                    if (errorDistance <= Epsilon.distance){
                        moveDir = moveStop;
                        correctDistance = TRUE;
    181c:	13 2d       	mov	r17, r3
    181e:	35 cd       	rjmp	.-1430   	; 0x128a <vMainPoseControllerTask+0x6c>
                        printf(STATUS_IDLE"\n"); 
                        xQueueSend(movementQ, &moveDir, 0);
                        xQueueSend(actuationQ, &actuation, 0);                        
                    }
                    else{
                        float dXY = (sqrt((diffX + diffY)) - oldVal.distance) / 0.030; // Divide by sample time in seconds and get positive value
    1820:	2d a1       	ldd	r18, Y+37	; 0x25
    1822:	3e a1       	ldd	r19, Y+38	; 0x26
    1824:	b9 01       	movw	r22, r18
    1826:	33 0f       	add	r19, r19
    1828:	88 0b       	sbc	r24, r24
    182a:	99 0b       	sbc	r25, r25
    182c:	0e 94 78 28 	call	0x50f0	; 0x50f0 <__floatsisf>
    1830:	9b 01       	movw	r18, r22
    1832:	ac 01       	movw	r20, r24
    1834:	c3 01       	movw	r24, r6
    1836:	b2 01       	movw	r22, r4
    1838:	0e 94 0f 27 	call	0x4e1e	; 0x4e1e <__subsf3>
    183c:	2f e8       	ldi	r18, 0x8F	; 143
    183e:	32 ec       	ldi	r19, 0xC2	; 194
    1840:	45 ef       	ldi	r20, 0xF5	; 245
    1842:	5c e3       	ldi	r21, 0x3C	; 60
    1844:	0e 94 dd 27 	call	0x4fba	; 0x4fba <__divsf3>
    1848:	6b 01       	movw	r12, r22
    184a:	7c 01       	movw	r14, r24
                        
                        integrator += Error.distance;                        
    184c:	b4 01       	movw	r22, r8
    184e:	09 2c       	mov	r0, r9
    1850:	00 0c       	add	r0, r0
    1852:	88 0b       	sbc	r24, r24
    1854:	99 0b       	sbc	r25, r25
    1856:	0e 94 78 28 	call	0x50f0	; 0x50f0 <__floatsisf>
    185a:	9b 01       	movw	r18, r22
    185c:	ac 01       	movw	r20, r24
    185e:	6c 8d       	ldd	r22, Y+28	; 0x1c
    1860:	7d 8d       	ldd	r23, Y+29	; 0x1d
    1862:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1864:	90 2f       	mov	r25, r16
    1866:	0e 94 10 27 	call	0x4e20	; 0x4e20 <__addsf3>
    186a:	6c 8f       	std	Y+28, r22	; 0x1c
    186c:	7d 8f       	std	Y+29, r23	; 0x1d
    186e:	8e 8f       	std	Y+30, r24	; 0x1e
    1870:	09 2f       	mov	r16, r25
                        if (integrator >= 25) integrator = 25;
    1872:	20 e0       	ldi	r18, 0x00	; 0
    1874:	30 e0       	ldi	r19, 0x00	; 0
    1876:	48 ec       	ldi	r20, 0xC8	; 200
    1878:	51 e4       	ldi	r21, 0x41	; 65
    187a:	0e 94 86 29 	call	0x530c	; 0x530c <__gesf2>
    187e:	88 23       	and	r24, r24
    1880:	2c f0       	brlt	.+10     	; 0x188c <vMainPoseControllerTask+0x66e>
    1882:	1c 8e       	std	Y+28, r1	; 0x1c
    1884:	1d 8e       	std	Y+29, r1	; 0x1d
    1886:	38 ec       	ldi	r19, 0xC8	; 200
    1888:	3e 8f       	std	Y+30, r19	; 0x1e
    188a:	01 e4       	ldi	r16, 0x41	; 65
                        
                        int16_t pidOutput = 4 * Error.distance + (int16_t)integrator - (int16_t)dXY;
    188c:	88 0c       	add	r8, r8
    188e:	99 1c       	adc	r9, r9
    1890:	88 0c       	add	r8, r8
    1892:	99 1c       	adc	r9, r9
    1894:	6c 8d       	ldd	r22, Y+28	; 0x1c
    1896:	7d 8d       	ldd	r23, Y+29	; 0x1d
    1898:	8e 8d       	ldd	r24, Y+30	; 0x1e
    189a:	90 2f       	mov	r25, r16
    189c:	0e 94 45 28 	call	0x508a	; 0x508a <__fixsfsi>
    18a0:	54 01       	movw	r10, r8
    18a2:	a6 0e       	add	r10, r22
    18a4:	b7 1e       	adc	r11, r23
    18a6:	c7 01       	movw	r24, r14
    18a8:	b6 01       	movw	r22, r12
    18aa:	0e 94 45 28 	call	0x508a	; 0x508a <__fixsfsi>
    18ae:	a6 1a       	sub	r10, r22
    18b0:	b7 0a       	sbc	r11, r23
    18b2:	12 f4       	brpl	.+4      	; 0x18b8 <vMainPoseControllerTask+0x69a>
    18b4:	a1 2c       	mov	r10, r1
    18b6:	b1 2c       	mov	r11, r1
    18b8:	4a e1       	ldi	r20, 0x1A	; 26
    18ba:	a4 16       	cp	r10, r20
    18bc:	b1 04       	cpc	r11, r1
    18be:	24 f0       	brlt	.+8      	; 0x18c8 <vMainPoseControllerTask+0x6aa>
    18c0:	0f 2e       	mov	r0, r31
    18c2:	f9 e1       	ldi	r31, 0x19	; 25
    18c4:	af 2e       	mov	r10, r31
    18c6:	f0 2d       	mov	r31, r0
                        
                        if (pidOutput > 25) pidOutput = 25;
                        else if (pidOutput < 0) pidOutput = 0;
                        
                        uint8_t actuation = (uint8_t)pidOutput;
    18c8:	af 86       	std	Y+15, r10	; 0x0f
                        
                        xQueueSend(movementQ, &moveDir, 0);
    18ca:	20 e0       	ldi	r18, 0x00	; 0
    18cc:	40 e0       	ldi	r20, 0x00	; 0
    18ce:	50 e0       	ldi	r21, 0x00	; 0
    18d0:	be 01       	movw	r22, r28
    18d2:	62 5f       	subi	r22, 0xF2	; 242
    18d4:	7f 4f       	sbci	r23, 0xFF	; 255
    18d6:	80 91 89 1a 	lds	r24, 0x1A89	; 0x801a89 <movementQ>
    18da:	90 91 8a 1a 	lds	r25, 0x1A8A	; 0x801a8a <movementQ+0x1>
    18de:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <xQueueGenericSend>
                        xQueueSend(actuationQ, &actuation, 0);
    18e2:	20 e0       	ldi	r18, 0x00	; 0
    18e4:	40 e0       	ldi	r20, 0x00	; 0
    18e6:	50 e0       	ldi	r21, 0x00	; 0
    18e8:	be 01       	movw	r22, r28
    18ea:	61 5f       	subi	r22, 0xF1	; 241
    18ec:	7f 4f       	sbci	r23, 0xFF	; 255
    18ee:	80 91 83 1a 	lds	r24, 0x1A83	; 0x801a83 <actuationQ>
    18f2:	90 91 84 1a 	lds	r25, 0x1A84	; 0x801a84 <actuationQ+0x1>
    18f6:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <xQueueGenericSend>
                        oldVal.distance = sqrt((diffX + diffY));
    18fa:	c3 01       	movw	r24, r6
    18fc:	b2 01       	movw	r22, r4
    18fe:	0e 94 45 28 	call	0x508a	; 0x508a <__fixsfsi>
    1902:	7e a3       	std	Y+38, r23	; 0x26
    1904:	6d a3       	std	Y+37, r22	; 0x25
    1906:	c1 cc       	rjmp	.-1662   	; 0x128a <vMainPoseControllerTask+0x6c>
        } //if(gHandshook) end
        else{
            // Reset controller
            correctHeading = TRUE;
            correctDistance = TRUE;
            moveDir = moveStop;
    1908:	1e 86       	std	Y+14, r1	; 0x0e
            xQueueSend(movementQ, &moveDir, 200 / portTICK_PERIOD_MS);
    190a:	20 e0       	ldi	r18, 0x00	; 0
    190c:	48 ec       	ldi	r20, 0xC8	; 200
    190e:	50 e0       	ldi	r21, 0x00	; 0
    1910:	be 01       	movw	r22, r28
    1912:	62 5f       	subi	r22, 0xF2	; 242
    1914:	7f 4f       	sbci	r23, 0xFF	; 255
    1916:	80 91 89 1a 	lds	r24, 0x1A89	; 0x801a89 <movementQ>
    191a:	90 91 8a 1a 	lds	r25, 0x1A8A	; 0x801a8a <movementQ+0x1>
    191e:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <xQueueGenericSend>
            vTaskDelay(100 / portTICK_PERIOD_MS);
    1922:	84 e6       	ldi	r24, 0x64	; 100
    1924:	90 e0       	ldi	r25, 0x00	; 0
    1926:	0e 94 c6 1f 	call	0x3f8c	; 0x3f8c <vTaskDelay>
            } // No semaphore available, task is blocking
        } //if(gHandshook) end
        else{
            // Reset controller
            correctHeading = TRUE;
            correctDistance = TRUE;
    192a:	13 2d       	mov	r17, r3
                }
            } // No semaphore available, task is blocking
        } //if(gHandshook) end
        else{
            // Reset controller
            correctHeading = TRUE;
    192c:	23 2c       	mov	r2, r3
    192e:	ad cc       	rjmp	.-1702   	; 0x128a <vMainPoseControllerTask+0x6c>

00001930 <vMainPoseEstimatorTask>:
        }
    }// while (1)
}

/* Pose estimator task */
void vMainPoseEstimatorTask( void *pvParameters ){
    1930:	cf 93       	push	r28
    1932:	df 93       	push	r29
    1934:	cd b7       	in	r28, 0x3d	; 61
    1936:	de b7       	in	r29, 0x3e	; 62
    1938:	e1 97       	sbiw	r28, 0x31	; 49
    193a:	0f b6       	in	r0, 0x3f	; 63
    193c:	f8 94       	cli
    193e:	de bf       	out	0x3e, r29	; 62
    1940:	0f be       	out	0x3f, r0	; 63
    1942:	cd bf       	out	0x3d, r28	; 61
    const TickType_t xDelay = PERIOD_ESTIMATOR_MS;
    float period_in_S = PERIOD_ESTIMATOR_MS / 1000.0f;
    
    float kalmanGain = 0.5;
    
    float predictedTheta = 0.0;
    1944:	19 82       	std	Y+1, r1	; 0x01
    1946:	1a 82       	std	Y+2, r1	; 0x02
    1948:	1b 82       	std	Y+3, r1	; 0x03
    194a:	1c 82       	std	Y+4, r1	; 0x04
    float gyroWeight = 0.5;//encoderError / (encoderError + gyroError);
    uint8_t robot_is_turning = 0;
    
    
    #ifdef DEBUG
        printf("Estimator OK");
    194c:	88 e8       	ldi	r24, 0x88	; 136
    194e:	96 e0       	ldi	r25, 0x06	; 6
    1950:	9f 93       	push	r25
    1952:	8f 93       	push	r24
    1954:	0e 94 e6 2f 	call	0x5fcc	; 0x5fcc <printf>
        printf("[%i]",PERIOD_ESTIMATOR_MS);
    1958:	1f 92       	push	r1
    195a:	88 e2       	ldi	r24, 0x28	; 40
    195c:	8f 93       	push	r24
    195e:	85 e9       	ldi	r24, 0x95	; 149
    1960:	96 e0       	ldi	r25, 0x06	; 6
    1962:	9f 93       	push	r25
    1964:	8f 93       	push	r24
    1966:	0e 94 e6 2f 	call	0x5fcc	; 0x5fcc <printf>
        printf("ms\n");   
    196a:	8a e9       	ldi	r24, 0x9A	; 154
    196c:	96 e0       	ldi	r25, 0x06	; 6
    196e:	0e 94 f9 2f 	call	0x5ff2	; 0x5ff2 <puts>
        uint8_t printerTellar = 0;     
    #endif
    
    // Initialise the xLastWakeTime variable with the current time.
    TickType_t xLastWakeTime;
    xLastWakeTime = xTaskGetTickCount();
    1972:	0e 94 70 23 	call	0x46e0	; 0x46e0 <xTaskGetTickCount>
    1976:	9e 83       	std	Y+6, r25	; 0x06
    1978:	8d 83       	std	Y+5, r24	; 0x05
    197a:	0f 90       	pop	r0
    197c:	0f 90       	pop	r0
    197e:	0f 90       	pop	r0
    1980:	0f 90       	pop	r0
    1982:	0f 90       	pop	r0
    1984:	0f 90       	pop	r0
    
    float variance_gyro = 0.0482f; // [rad] calculated offline, see report
    float variance_encoder = (2.0f * WHEEL_FACTOR_MM) / (WHEELBASE_MM / 2.0f); // approximation, 0.0257 [rad]
    
    float variance_gyro_encoder = (variance_gyro + variance_encoder) * period_in_S; // (Var gyro + var encoder) * timestep
    float covariance_filter_predicted = 0;
    1986:	1d a6       	std	Y+45, r1	; 0x2d
    1988:	1e a6       	std	Y+46, r1	; 0x2e
    198a:	1f a6       	std	Y+47, r1	; 0x2f
    198c:	18 aa       	std	Y+48, r1	; 0x30
    float predictedTheta = 0.0;
    float predictedX = 0.0;
    float predictedY = 0.0;
    
    float gyroOffset = 0.0;
    float compassOffset = 0.0;
    198e:	1d 8e       	std	Y+29, r1	; 0x1d
    1990:	1e 8e       	std	Y+30, r1	; 0x1e
    1992:	1f 8e       	std	Y+31, r1	; 0x1f
    1994:	18 a2       	std	Y+32, r1	; 0x20
    
    float predictedTheta = 0.0;
    float predictedX = 0.0;
    float predictedY = 0.0;
    
    float gyroOffset = 0.0;
    1996:	19 8e       	std	Y+25, r1	; 0x19
    1998:	1a 8e       	std	Y+26, r1	; 0x1a
    199a:	1b 8e       	std	Y+27, r1	; 0x1b
    199c:	1c 8e       	std	Y+28, r1	; 0x1c
    
    float kalmanGain = 0.5;
    
    float predictedTheta = 0.0;
    float predictedX = 0.0;
    float predictedY = 0.0;
    199e:	1d 8a       	std	Y+21, r1	; 0x15
    19a0:	1e 8a       	std	Y+22, r1	; 0x16
    19a2:	1f 8a       	std	Y+23, r1	; 0x17
    19a4:	18 8e       	std	Y+24, r1	; 0x18
    float period_in_S = PERIOD_ESTIMATOR_MS / 1000.0f;
    
    float kalmanGain = 0.5;
    
    float predictedTheta = 0.0;
    float predictedX = 0.0;
    19a6:	19 8a       	std	Y+17, r1	; 0x11
    19a8:	1a 8a       	std	Y+18, r1	; 0x12
    19aa:	1b 8a       	std	Y+19, r1	; 0x13
    19ac:	1c 8a       	std	Y+20, r1	; 0x14
}

/* Pose estimator task */
void vMainPoseEstimatorTask( void *pvParameters ){
    int16_t previous_ticksLeft = 0;
    int16_t previous_ticksRight = 0;  
    19ae:	61 2c       	mov	r6, r1
    19b0:	71 2c       	mov	r7, r1
    }// while (1)
}

/* Pose estimator task */
void vMainPoseEstimatorTask( void *pvParameters ){
    int16_t previous_ticksLeft = 0;
    19b2:	41 2c       	mov	r4, r1
    19b4:	51 2c       	mov	r5, r1
    19b6:	21 2c       	mov	r2, r1
            yCom += yComOff;
            
            
            // Initialize pose to 0 and reset offset variables
            predictedX = 0;
            predictedY = 0;
    19b8:	31 2c       	mov	r3, r1
    TickType_t xLastWakeTime;
    xLastWakeTime = xTaskGetTickCount();
    
    while(1){
        // Loop
        vTaskDelayUntil(&xLastWakeTime, xDelay / portTICK_PERIOD_MS );  
    19ba:	68 e2       	ldi	r22, 0x28	; 40
    19bc:	70 e0       	ldi	r23, 0x00	; 0
    19be:	ce 01       	movw	r24, r28
    19c0:	05 96       	adiw	r24, 0x05	; 5
    19c2:	0e 94 23 1e 	call	0x3c46	; 0x3c46 <vTaskDelayUntil>
        if (gHandshook){ // Check if we are ready    
    19c6:	80 91 80 1a 	lds	r24, 0x1A80	; 0x801a80 <gHandshook>
    19ca:	88 23       	and	r24, r24
    19cc:	09 f4       	brne	.+2      	; 0x19d0 <vMainPoseEstimatorTask+0xa0>
    19ce:	2f c2       	rjmp	.+1118   	; 0x1e2e <vMainPoseEstimatorTask+0x4fe>
            int16_t leftWheelTicks = 0;
            int16_t rightWheelTicks = 0;
            
            // Get encoder data, protect the global tick variables
            xSemaphoreTake(xTickMutex, 15 / portTICK_PERIOD_MS);
    19d0:	23 2d       	mov	r18, r3
    19d2:	4f e0       	ldi	r20, 0x0F	; 15
    19d4:	50 e0       	ldi	r21, 0x00	; 0
    19d6:	60 e0       	ldi	r22, 0x00	; 0
    19d8:	70 e0       	ldi	r23, 0x00	; 0
    19da:	80 91 1a 1b 	lds	r24, 0x1B1A	; 0x801b1a <xTickMutex>
    19de:	90 91 1b 1b 	lds	r25, 0x1B1B	; 0x801b1b <xTickMutex+0x1>
    19e2:	0e 94 34 1b 	call	0x3668	; 0x3668 <xQueueGenericReceive>
                leftWheelTicks = gLeftWheelTicks;
    19e6:	80 91 72 1a 	lds	r24, 0x1A72	; 0x801a72 <gLeftWheelTicks>
    19ea:	90 91 73 1a 	lds	r25, 0x1A73	; 0x801a73 <gLeftWheelTicks+0x1>
    19ee:	9a a7       	std	Y+42, r25	; 0x2a
    19f0:	89 a7       	std	Y+41, r24	; 0x29
                rightWheelTicks = gRightWheelTicks;
    19f2:	a0 91 74 1a 	lds	r26, 0x1A74	; 0x801a74 <gRightWheelTicks>
    19f6:	b0 91 75 1a 	lds	r27, 0x1A75	; 0x801a75 <gRightWheelTicks+0x1>
    19fa:	bc a7       	std	Y+44, r27	; 0x2c
    19fc:	ab a7       	std	Y+43, r26	; 0x2b
            xSemaphoreGive(xTickMutex);
    19fe:	60 e0       	ldi	r22, 0x00	; 0
    1a00:	70 e0       	ldi	r23, 0x00	; 0
    1a02:	80 91 1a 1b 	lds	r24, 0x1B1A	; 0x801b1a <xTickMutex>
    1a06:	90 91 1b 1b 	lds	r25, 0x1B1B	; 0x801b1b <xTickMutex+0x1>
    1a0a:	0e 94 9a 19 	call	0x3334	; 0x3334 <xQueueGive>
            
            float dLeft = (float)(leftWheelTicks - previous_ticksLeft) * WHEEL_FACTOR_MM; // Distance left wheel has traveled since last sample
    1a0e:	69 a5       	ldd	r22, Y+41	; 0x29
    1a10:	7a a5       	ldd	r23, Y+42	; 0x2a
    1a12:	64 19       	sub	r22, r4
    1a14:	75 09       	sbc	r23, r5
    1a16:	07 2e       	mov	r0, r23
    1a18:	00 0c       	add	r0, r0
    1a1a:	88 0b       	sbc	r24, r24
    1a1c:	99 0b       	sbc	r25, r25
    1a1e:	0e 94 78 28 	call	0x50f0	; 0x50f0 <__floatsisf>
    1a22:	2d e3       	ldi	r18, 0x3D	; 61
    1a24:	3c e2       	ldi	r19, 0x2C	; 44
    1a26:	44 e5       	ldi	r20, 0x54	; 84
    1a28:	5e e3       	ldi	r21, 0x3E	; 62
    1a2a:	0e 94 91 29 	call	0x5322	; 0x5322 <__mulsf3>
    1a2e:	6b 01       	movw	r12, r22
    1a30:	7c 01       	movw	r14, r24
            float dRight =(float)(rightWheelTicks - previous_ticksRight) * WHEEL_FACTOR_MM; // Distance right wheel has traveled since last sample
    1a32:	6b a5       	ldd	r22, Y+43	; 0x2b
    1a34:	7c a5       	ldd	r23, Y+44	; 0x2c
    1a36:	66 19       	sub	r22, r6
    1a38:	77 09       	sbc	r23, r7
    1a3a:	07 2e       	mov	r0, r23
    1a3c:	00 0c       	add	r0, r0
    1a3e:	88 0b       	sbc	r24, r24
    1a40:	99 0b       	sbc	r25, r25
    1a42:	0e 94 78 28 	call	0x50f0	; 0x50f0 <__floatsisf>
    1a46:	2d e3       	ldi	r18, 0x3D	; 61
    1a48:	3c e2       	ldi	r19, 0x2C	; 44
    1a4a:	44 e5       	ldi	r20, 0x54	; 84
    1a4c:	5e e3       	ldi	r21, 0x3E	; 62
    1a4e:	0e 94 91 29 	call	0x5322	; 0x5322 <__mulsf3>
    1a52:	4b 01       	movw	r8, r22
    1a54:	5c 01       	movw	r10, r24
            previous_ticksLeft = leftWheelTicks;
            previous_ticksRight = rightWheelTicks;
                       
            float dRobot = (dLeft + dRight) / 2;           
    1a56:	9b 01       	movw	r18, r22
    1a58:	ac 01       	movw	r20, r24
    1a5a:	c7 01       	movw	r24, r14
    1a5c:	b6 01       	movw	r22, r12
    1a5e:	0e 94 10 27 	call	0x4e20	; 0x4e20 <__addsf3>
    1a62:	20 e0       	ldi	r18, 0x00	; 0
    1a64:	30 e0       	ldi	r19, 0x00	; 0
    1a66:	40 e0       	ldi	r20, 0x00	; 0
    1a68:	5f e3       	ldi	r21, 0x3F	; 63
    1a6a:	0e 94 91 29 	call	0x5322	; 0x5322 <__mulsf3>
    1a6e:	69 a3       	std	Y+33, r22	; 0x21
    1a70:	7a a3       	std	Y+34, r23	; 0x22
    1a72:	8b a3       	std	Y+35, r24	; 0x23
    1a74:	9c a3       	std	Y+36, r25	; 0x24
            float dTheta = (dRight - dLeft) / WHEELBASE_MM; // Get angle from encoders, dervied from arch of circles formula
    1a76:	a7 01       	movw	r20, r14
    1a78:	96 01       	movw	r18, r12
    1a7a:	c5 01       	movw	r24, r10
    1a7c:	b4 01       	movw	r22, r8
    1a7e:	0e 94 0f 27 	call	0x4e1e	; 0x4e1e <__subsf3>
    1a82:	20 e0       	ldi	r18, 0x00	; 0
    1a84:	30 e0       	ldi	r19, 0x00	; 0
    1a86:	47 e5       	ldi	r20, 0x57	; 87
    1a88:	53 e4       	ldi	r21, 0x43	; 67
    1a8a:	0e 94 dd 27 	call	0x4fba	; 0x4fba <__divsf3>
    1a8e:	4b 01       	movw	r8, r22
    1a90:	5c 01       	movw	r10, r24
            
            
            /* PREDICT */
            // Get gyro data:
            float gyrZ = (fIMU_readFloatGyroZ() - gyroOffset);
    1a92:	4a d8       	rcall	.-3948   	; 0xb28 <fIMU_readFloatGyroZ>
    1a94:	29 8d       	ldd	r18, Y+25	; 0x19
    1a96:	3a 8d       	ldd	r19, Y+26	; 0x1a
    1a98:	4b 8d       	ldd	r20, Y+27	; 0x1b
    1a9a:	5c 8d       	ldd	r21, Y+28	; 0x1c
    1a9c:	0e 94 0f 27 	call	0x4e1e	; 0x4e1e <__subsf3>
    1aa0:	6b 01       	movw	r12, r22
    1aa2:	7c 01       	movw	r14, r24
            //dTheta = gyrZ * period_in_S * DEG2RAD; [COMMENT]I believe this line is not supposed to be here. Residual from broken encoders?
            
            // If the robot is not really rotating we don't include the gyro measurements, to avoid the trouble with drift while driving in a straight line
            if(fabs(gyrZ) < 10){ 
    1aa4:	9f 77       	andi	r25, 0x7F	; 127
    1aa6:	20 e0       	ldi	r18, 0x00	; 0
    1aa8:	30 e0       	ldi	r19, 0x00	; 0
    1aaa:	40 e2       	ldi	r20, 0x20	; 32
    1aac:	51 e4       	ldi	r21, 0x41	; 65
    1aae:	0e 94 d6 27 	call	0x4fac	; 0x4fac <__cmpsf2>
    1ab2:	88 23       	and	r24, r24
    1ab4:	6c f0       	brlt	.+26     	; 0x1ad0 <vMainPoseEstimatorTask+0x1a0>
                gyroWeight = 0; // Disregard gyro while driving in a straight line
                robot_is_turning = FALSE; // Don't update angle estimates
                }
            else {
                robot_is_turning = TRUE;
    1ab6:	b1 e0       	ldi	r27, 0x01	; 1
    1ab8:	b9 ab       	std	Y+49, r27	; 0x31
                gyroWeight = 0.85; // Found by experiment, after 20x90 degree turns, gyro seems 85% more accurate than encoders
    1aba:	1a e9       	ldi	r17, 0x9A	; 154
    1abc:	09 e9       	ldi	r16, 0x99	; 153
    1abe:	0f 2e       	mov	r0, r31
    1ac0:	f9 e5       	ldi	r31, 0x59	; 89
    1ac2:	7f 2e       	mov	r7, r31
    1ac4:	f0 2d       	mov	r31, r0
    1ac6:	0f 2e       	mov	r0, r31
    1ac8:	ff e3       	ldi	r31, 0x3F	; 63
    1aca:	6f 2e       	mov	r6, r31
    1acc:	f0 2d       	mov	r31, r0
    1ace:	05 c0       	rjmp	.+10     	; 0x1ada <vMainPoseEstimatorTask+0x1aa>
            //dTheta = gyrZ * period_in_S * DEG2RAD; [COMMENT]I believe this line is not supposed to be here. Residual from broken encoders?
            
            // If the robot is not really rotating we don't include the gyro measurements, to avoid the trouble with drift while driving in a straight line
            if(fabs(gyrZ) < 10){ 
                gyroWeight = 0; // Disregard gyro while driving in a straight line
                robot_is_turning = FALSE; // Don't update angle estimates
    1ad0:	39 aa       	std	Y+49, r3	; 0x31
            float gyrZ = (fIMU_readFloatGyroZ() - gyroOffset);
            //dTheta = gyrZ * period_in_S * DEG2RAD; [COMMENT]I believe this line is not supposed to be here. Residual from broken encoders?
            
            // If the robot is not really rotating we don't include the gyro measurements, to avoid the trouble with drift while driving in a straight line
            if(fabs(gyrZ) < 10){ 
                gyroWeight = 0; // Disregard gyro while driving in a straight line
    1ad2:	10 e0       	ldi	r17, 0x00	; 0
    1ad4:	00 e0       	ldi	r16, 0x00	; 0
    1ad6:	71 2c       	mov	r7, r1
    1ad8:	62 2c       	mov	r6, r2
			
			
			
			
            // Fuse heading from sensors to predict heading:
            dTheta =  (1 - gyroWeight) * dTheta + gyroWeight * gyrZ;
    1ada:	21 2f       	mov	r18, r17
    1adc:	30 2f       	mov	r19, r16
    1ade:	47 2d       	mov	r20, r7
    1ae0:	56 2d       	mov	r21, r6
    1ae2:	60 e0       	ldi	r22, 0x00	; 0
    1ae4:	70 e0       	ldi	r23, 0x00	; 0
    1ae6:	80 e8       	ldi	r24, 0x80	; 128
    1ae8:	9f e3       	ldi	r25, 0x3F	; 63
    1aea:	0e 94 0f 27 	call	0x4e1e	; 0x4e1e <__subsf3>
    1aee:	a5 01       	movw	r20, r10
    1af0:	94 01       	movw	r18, r8
    1af2:	0e 94 91 29 	call	0x5322	; 0x5322 <__mulsf3>
    1af6:	4b 01       	movw	r8, r22
    1af8:	5c 01       	movw	r10, r24
                robot_is_turning = TRUE;
                gyroWeight = 0.85; // Found by experiment, after 20x90 degree turns, gyro seems 85% more accurate than encoders
                
            }
            
            gyrZ *= period_in_S * DEG2RAD; // Scale gyro measurement      
    1afa:	24 ed       	ldi	r18, 0xD4	; 212
    1afc:	32 e0       	ldi	r19, 0x02	; 2
    1afe:	47 e3       	ldi	r20, 0x37	; 55
    1b00:	5a e3       	ldi	r21, 0x3A	; 58
    1b02:	c7 01       	movw	r24, r14
    1b04:	b6 01       	movw	r22, r12
    1b06:	0e 94 91 29 	call	0x5322	; 0x5322 <__mulsf3>
    1b0a:	9b 01       	movw	r18, r22
    1b0c:	ac 01       	movw	r20, r24
			
			
			
			
            // Fuse heading from sensors to predict heading:
            dTheta =  (1 - gyroWeight) * dTheta + gyroWeight * gyrZ;
    1b0e:	61 2f       	mov	r22, r17
    1b10:	70 2f       	mov	r23, r16
    1b12:	87 2d       	mov	r24, r7
    1b14:	96 2d       	mov	r25, r6
    1b16:	0e 94 91 29 	call	0x5322	; 0x5322 <__mulsf3>
    1b1a:	9b 01       	movw	r18, r22
    1b1c:	ac 01       	movw	r20, r24
    1b1e:	c5 01       	movw	r24, r10
    1b20:	b4 01       	movw	r22, r8
    1b22:	0e 94 10 27 	call	0x4e20	; 0x4e20 <__addsf3>
    1b26:	6b 01       	movw	r12, r22
    1b28:	7c 01       	movw	r14, r24
            
            
            // Estimate global X and Y pos
            // Todo; Include accelerator measurements to estimate position and handle wheel slippage
            predictedX = predictedX + (dRobot * cos(predictedTheta + 0.5 * dTheta)); // [COMMENT]What is the 0.5?
    1b2a:	49 80       	ldd	r4, Y+1	; 0x01
    1b2c:	5a 80       	ldd	r5, Y+2	; 0x02
    1b2e:	6b 80       	ldd	r6, Y+3	; 0x03
    1b30:	7c 80       	ldd	r7, Y+4	; 0x04
    1b32:	20 e0       	ldi	r18, 0x00	; 0
    1b34:	30 e0       	ldi	r19, 0x00	; 0
    1b36:	40 e0       	ldi	r20, 0x00	; 0
    1b38:	5f e3       	ldi	r21, 0x3F	; 63
    1b3a:	0e 94 91 29 	call	0x5322	; 0x5322 <__mulsf3>
    1b3e:	a3 01       	movw	r20, r6
    1b40:	92 01       	movw	r18, r4
    1b42:	0e 94 10 27 	call	0x4e20	; 0x4e20 <__addsf3>
    1b46:	4b 01       	movw	r8, r22
    1b48:	5c 01       	movw	r10, r24
    1b4a:	0e 94 da 27 	call	0x4fb4	; 0x4fb4 <cos>
    1b4e:	29 a1       	ldd	r18, Y+33	; 0x21
    1b50:	3a a1       	ldd	r19, Y+34	; 0x22
    1b52:	4b a1       	ldd	r20, Y+35	; 0x23
    1b54:	5c a1       	ldd	r21, Y+36	; 0x24
    1b56:	0e 94 91 29 	call	0x5322	; 0x5322 <__mulsf3>
    1b5a:	9b 01       	movw	r18, r22
    1b5c:	ac 01       	movw	r20, r24
    1b5e:	f9 89       	ldd	r31, Y+17	; 0x11
    1b60:	ea 89       	ldd	r30, Y+18	; 0x12
    1b62:	bb 89       	ldd	r27, Y+19	; 0x13
    1b64:	ac 89       	ldd	r26, Y+20	; 0x14
    1b66:	6f 2f       	mov	r22, r31
    1b68:	7e 2f       	mov	r23, r30
    1b6a:	8b 2f       	mov	r24, r27
    1b6c:	9a 2f       	mov	r25, r26
    1b6e:	0e 94 10 27 	call	0x4e20	; 0x4e20 <__addsf3>
    1b72:	6d a3       	std	Y+37, r22	; 0x25
    1b74:	7e a3       	std	Y+38, r23	; 0x26
    1b76:	8f a3       	std	Y+39, r24	; 0x27
    1b78:	98 a7       	std	Y+40, r25	; 0x28
    1b7a:	69 8b       	std	Y+17, r22	; 0x11
    1b7c:	7a 8b       	std	Y+18, r23	; 0x12
    1b7e:	8b 8b       	std	Y+19, r24	; 0x13
    1b80:	9c 8b       	std	Y+20, r25	; 0x14
            predictedY = predictedY + (dRobot * sin(predictedTheta + 0.5 * dTheta));
    1b82:	c5 01       	movw	r24, r10
    1b84:	b4 01       	movw	r22, r8
    1b86:	0e 94 f4 29 	call	0x53e8	; 0x53e8 <sin>
    1b8a:	29 a1       	ldd	r18, Y+33	; 0x21
    1b8c:	3a a1       	ldd	r19, Y+34	; 0x22
    1b8e:	4b a1       	ldd	r20, Y+35	; 0x23
    1b90:	5c a1       	ldd	r21, Y+36	; 0x24
    1b92:	0e 94 91 29 	call	0x5322	; 0x5322 <__mulsf3>
    1b96:	9b 01       	movw	r18, r22
    1b98:	ac 01       	movw	r20, r24
    1b9a:	fd 89       	ldd	r31, Y+21	; 0x15
    1b9c:	ee 89       	ldd	r30, Y+22	; 0x16
    1b9e:	bf 89       	ldd	r27, Y+23	; 0x17
    1ba0:	a8 8d       	ldd	r26, Y+24	; 0x18
    1ba2:	6f 2f       	mov	r22, r31
    1ba4:	7e 2f       	mov	r23, r30
    1ba6:	8b 2f       	mov	r24, r27
    1ba8:	9a 2f       	mov	r25, r26
    1baa:	0e 94 10 27 	call	0x4e20	; 0x4e20 <__addsf3>
    1bae:	86 2e       	mov	r8, r22
    1bb0:	97 2e       	mov	r9, r23
    1bb2:	a8 2e       	mov	r10, r24
    1bb4:	b9 2e       	mov	r11, r25
    1bb6:	6d 8b       	std	Y+21, r22	; 0x15
    1bb8:	7e 8b       	std	Y+22, r23	; 0x16
    1bba:	8f 8b       	std	Y+23, r24	; 0x17
    1bbc:	98 8f       	std	Y+24, r25	; 0x18

            // Predicted (a priori) state estimate for theta
            predictedTheta += dTheta;
    1bbe:	a3 01       	movw	r20, r6
    1bc0:	92 01       	movw	r18, r4
    1bc2:	c7 01       	movw	r24, r14
    1bc4:	b6 01       	movw	r22, r12
    1bc6:	0e 94 10 27 	call	0x4e20	; 0x4e20 <__addsf3>
    1bca:	69 83       	std	Y+1, r22	; 0x01
    1bcc:	7a 83       	std	Y+2, r23	; 0x02
    1bce:	8b 83       	std	Y+3, r24	; 0x03
    1bd0:	9c 83       	std	Y+4, r25	; 0x04
                  
            // Predicted (a priori) estimate covariance
            covariance_filter_predicted += variance_gyro_encoder;
    1bd2:	20 e7       	ldi	r18, 0x70	; 112
    1bd4:	35 e7       	ldi	r19, 0x75	; 117
    1bd6:	48 e0       	ldi	r20, 0x08	; 8
    1bd8:	5b e3       	ldi	r21, 0x3B	; 59
    1bda:	6d a5       	ldd	r22, Y+45	; 0x2d
    1bdc:	7e a5       	ldd	r23, Y+46	; 0x2e
    1bde:	8f a5       	ldd	r24, Y+47	; 0x2f
    1be0:	98 a9       	ldd	r25, Y+48	; 0x30
    1be2:	0e 94 10 27 	call	0x4e20	; 0x4e20 <__addsf3>
    1be6:	2b 01       	movw	r4, r22
    1be8:	3c 01       	movw	r6, r24
            
            /* UPDATE */
            // Get compass data: ( Request and recheck after 6 ms?)
            int16_t xCom, yCom, zCom;
            vCOM_getData(&xCom, &yCom, &zCom);
    1bea:	ae 01       	movw	r20, r28
    1bec:	45 5f       	subi	r20, 0xF5	; 245
    1bee:	5f 4f       	sbci	r21, 0xFF	; 255
    1bf0:	be 01       	movw	r22, r28
    1bf2:	63 5f       	subi	r22, 0xF3	; 243
    1bf4:	7f 4f       	sbci	r23, 0xFF	; 255
    1bf6:	ce 01       	movw	r24, r28
    1bf8:	0f 96       	adiw	r24, 0x0f	; 15
    1bfa:	0e 94 6f 01 	call	0x2de	; 0x2de <vCOM_getData>
            // Add calibrated bias
            xCom += xComOff;
    1bfe:	6f 85       	ldd	r22, Y+15	; 0x0f
    1c00:	78 89       	ldd	r23, Y+16	; 0x10
    1c02:	65 5f       	subi	r22, 0xF5	; 245
    1c04:	7f 4f       	sbci	r23, 0xFF	; 255
    1c06:	78 8b       	std	Y+16, r23	; 0x10
    1c08:	6f 87       	std	Y+15, r22	; 0x0f
            yCom += yComOff;
    1c0a:	0d 85       	ldd	r16, Y+13	; 0x0d
    1c0c:	1e 85       	ldd	r17, Y+14	; 0x0e
    1c0e:	0e 54       	subi	r16, 0x4E	; 78
    1c10:	11 09       	sbc	r17, r1
    1c12:	1e 87       	std	Y+14, r17	; 0x0e
    1c14:	0d 87       	std	Y+13, r16	; 0x0d
            // calculate heading
            float compassHeading;
            compassHeading = atan2(yCom, xCom) - compassOffset ; // returns -pi, pi
    1c16:	07 2e       	mov	r0, r23
    1c18:	00 0c       	add	r0, r0
    1c1a:	88 0b       	sbc	r24, r24
    1c1c:	99 0b       	sbc	r25, r25
    1c1e:	0e 94 78 28 	call	0x50f0	; 0x50f0 <__floatsisf>
    1c22:	6b 01       	movw	r12, r22
    1c24:	7c 01       	movw	r14, r24
    1c26:	b8 01       	movw	r22, r16
    1c28:	11 0f       	add	r17, r17
    1c2a:	88 0b       	sbc	r24, r24
    1c2c:	99 0b       	sbc	r25, r25
    1c2e:	0e 94 78 28 	call	0x50f0	; 0x50f0 <__floatsisf>
    1c32:	a7 01       	movw	r20, r14
    1c34:	96 01       	movw	r18, r12
    1c36:	0e 94 83 27 	call	0x4f06	; 0x4f06 <atan2>
    1c3a:	2d 8d       	ldd	r18, Y+29	; 0x1d
    1c3c:	3e 8d       	ldd	r19, Y+30	; 0x1e
    1c3e:	4f 8d       	ldd	r20, Y+31	; 0x1f
    1c40:	58 a1       	ldd	r21, Y+32	; 0x20
    1c42:	0e 94 0f 27 	call	0x4e1e	; 0x4e1e <__subsf3>
            // Update predicted state:    
            float error = (compassHeading - predictedTheta);
    1c46:	29 81       	ldd	r18, Y+1	; 0x01
    1c48:	3a 81       	ldd	r19, Y+2	; 0x02
    1c4a:	4b 81       	ldd	r20, Y+3	; 0x03
    1c4c:	5c 81       	ldd	r21, Y+4	; 0x04
    1c4e:	0e 94 0f 27 	call	0x4e1e	; 0x4e1e <__subsf3>
    1c52:	6f 83       	std	Y+7, r22	; 0x07
    1c54:	78 87       	std	Y+8, r23	; 0x08
    1c56:	89 87       	std	Y+9, r24	; 0x09
    1c58:	9a 87       	std	Y+10, r25	; 0x0a
            vFunc_Inf2pi(&error);
    1c5a:	ce 01       	movw	r24, r28
    1c5c:	07 96       	adiw	r24, 0x07	; 7
    1c5e:	0e 94 e6 01 	call	0x3cc	; 0x3cc <vFunc_Inf2pi>
            
            // Handling of compass is removed due to broken encoders, so we estimate heading with gyro and always update with compass
            //kalmanGain = covariance_filter_predicted / (covariance_filter_predicted + CONST_VARIANCE_COMPASS);
            ///* Commented back in due to fixed encoder
            if (fabs(error) > (0.8727*period_in_S)){ // 0.8727 rad/s is top speed while turning
    1c62:	8f 81       	ldd	r24, Y+7	; 0x07
    1c64:	98 85       	ldd	r25, Y+8	; 0x08
    1c66:	a9 85       	ldd	r26, Y+9	; 0x09
    1c68:	ba 85       	ldd	r27, Y+10	; 0x0a
    1c6a:	bc 01       	movw	r22, r24
    1c6c:	cd 01       	movw	r24, r26
    1c6e:	9f 77       	andi	r25, 0x7F	; 127
    1c70:	20 eb       	ldi	r18, 0xB0	; 176
    1c72:	3b ef       	ldi	r19, 0xFB	; 251
    1c74:	4e e0       	ldi	r20, 0x0E	; 14
    1c76:	5d e3       	ldi	r21, 0x3D	; 61
    1c78:	0e 94 86 29 	call	0x530c	; 0x530c <__gesf2>
    1c7c:	18 16       	cp	r1, r24
    1c7e:	4c f4       	brge	.+18     	; 0x1c92 <vMainPoseEstimatorTask+0x362>
                // If we have a reading over this, we can safely ignore the compass
                // Ignore compass while driving in a straight line
                kalmanGain = 0;
                vLED_singleLow(ledYELLOW);
    1c80:	81 e0       	ldi	r24, 0x01	; 1
    1c82:	90 e0       	ldi	r25, 0x00	; 0
    1c84:	0e 94 b7 05 	call	0xb6e	; 0xb6e <vLED_singleLow>
            //kalmanGain = covariance_filter_predicted / (covariance_filter_predicted + CONST_VARIANCE_COMPASS);
            ///* Commented back in due to fixed encoder
            if (fabs(error) > (0.8727*period_in_S)){ // 0.8727 rad/s is top speed while turning
                // If we have a reading over this, we can safely ignore the compass
                // Ignore compass while driving in a straight line
                kalmanGain = 0;
    1c88:	10 e0       	ldi	r17, 0x00	; 0
    1c8a:	00 e0       	ldi	r16, 0x00	; 0
    1c8c:	f1 2c       	mov	r15, r1
    1c8e:	e2 2c       	mov	r14, r2
    1c90:	2e c0       	rjmp	.+92     	; 0x1cee <vMainPoseEstimatorTask+0x3be>
                vLED_singleLow(ledYELLOW);
            }
            else if ((robot_is_turning == FALSE) && (dRobot == 0)){
    1c92:	89 a9       	ldd	r24, Y+49	; 0x31
    1c94:	81 11       	cpse	r24, r1
    1c96:	23 c0       	rjmp	.+70     	; 0x1cde <vMainPoseEstimatorTask+0x3ae>
    1c98:	20 e0       	ldi	r18, 0x00	; 0
    1c9a:	30 e0       	ldi	r19, 0x00	; 0
    1c9c:	40 e0       	ldi	r20, 0x00	; 0
    1c9e:	52 2d       	mov	r21, r2
    1ca0:	69 a1       	ldd	r22, Y+33	; 0x21
    1ca2:	7a a1       	ldd	r23, Y+34	; 0x22
    1ca4:	8b a1       	ldd	r24, Y+35	; 0x23
    1ca6:	9c a1       	ldd	r25, Y+36	; 0x24
    1ca8:	0e 94 d6 27 	call	0x4fac	; 0x4fac <__cmpsf2>
    1cac:	81 11       	cpse	r24, r1
    1cae:	17 c0       	rjmp	.+46     	; 0x1cde <vMainPoseEstimatorTask+0x3ae>
                // Updated (a posteriori) state estimate
                kalmanGain = covariance_filter_predicted / (covariance_filter_predicted + CONST_VARIANCE_COMPASS);
    1cb0:	21 e2       	ldi	r18, 0x21	; 33
    1cb2:	30 eb       	ldi	r19, 0xB0	; 176
    1cb4:	42 eb       	ldi	r20, 0xB2	; 178
    1cb6:	5e e3       	ldi	r21, 0x3E	; 62
    1cb8:	c3 01       	movw	r24, r6
    1cba:	b2 01       	movw	r22, r4
    1cbc:	0e 94 10 27 	call	0x4e20	; 0x4e20 <__addsf3>
    1cc0:	9b 01       	movw	r18, r22
    1cc2:	ac 01       	movw	r20, r24
    1cc4:	c3 01       	movw	r24, r6
    1cc6:	b2 01       	movw	r22, r4
    1cc8:	0e 94 dd 27 	call	0x4fba	; 0x4fba <__divsf3>
    1ccc:	16 2f       	mov	r17, r22
    1cce:	07 2f       	mov	r16, r23
    1cd0:	f8 2e       	mov	r15, r24
    1cd2:	e9 2e       	mov	r14, r25
                vLED_singleHigh(ledYELLOW);
    1cd4:	81 e0       	ldi	r24, 0x01	; 1
    1cd6:	90 e0       	ldi	r25, 0x00	; 0
    1cd8:	0e 94 9d 05 	call	0xb3a	; 0xb3a <vLED_singleHigh>
    1cdc:	08 c0       	rjmp	.+16     	; 0x1cee <vMainPoseEstimatorTask+0x3be>
            }
            else{
                kalmanGain = 0;
                vLED_singleLow(ledYELLOW);
    1cde:	81 e0       	ldi	r24, 0x01	; 1
    1ce0:	90 e0       	ldi	r25, 0x00	; 0
    1ce2:	0e 94 b7 05 	call	0xb6e	; 0xb6e <vLED_singleLow>
                // Updated (a posteriori) state estimate
                kalmanGain = covariance_filter_predicted / (covariance_filter_predicted + CONST_VARIANCE_COMPASS);
                vLED_singleHigh(ledYELLOW);
            }
            else{
                kalmanGain = 0;
    1ce6:	10 e0       	ldi	r17, 0x00	; 0
    1ce8:	00 e0       	ldi	r16, 0x00	; 0
    1cea:	f1 2c       	mov	r15, r1
    1cec:	e2 2c       	mov	r14, r2
                vLED_singleLow(ledYELLOW);
            }            
            //*/
           
            predictedTheta  += kalmanGain*(error);
    1cee:	2f 81       	ldd	r18, Y+7	; 0x07
    1cf0:	38 85       	ldd	r19, Y+8	; 0x08
    1cf2:	49 85       	ldd	r20, Y+9	; 0x09
    1cf4:	5a 85       	ldd	r21, Y+10	; 0x0a
    1cf6:	61 2f       	mov	r22, r17
    1cf8:	70 2f       	mov	r23, r16
    1cfa:	8f 2d       	mov	r24, r15
    1cfc:	9e 2d       	mov	r25, r14
    1cfe:	0e 94 91 29 	call	0x5322	; 0x5322 <__mulsf3>
    1d02:	9b 01       	movw	r18, r22
    1d04:	ac 01       	movw	r20, r24
    1d06:	69 81       	ldd	r22, Y+1	; 0x01
    1d08:	7a 81       	ldd	r23, Y+2	; 0x02
    1d0a:	8b 81       	ldd	r24, Y+3	; 0x03
    1d0c:	9c 81       	ldd	r25, Y+4	; 0x04
    1d0e:	0e 94 10 27 	call	0x4e20	; 0x4e20 <__addsf3>
    1d12:	69 83       	std	Y+1, r22	; 0x01
    1d14:	7a 83       	std	Y+2, r23	; 0x02
    1d16:	8b 83       	std	Y+3, r24	; 0x03
    1d18:	9c 83       	std	Y+4, r25	; 0x04
			vFunc_Inf2pi(&predictedTheta);            
    1d1a:	ce 01       	movw	r24, r28
    1d1c:	01 96       	adiw	r24, 0x01	; 1
    1d1e:	0e 94 e6 01 	call	0x3cc	; 0x3cc <vFunc_Inf2pi>
            
            // Updated (a posteriori) estimate covariance
            covariance_filter_predicted = (1 - kalmanGain) * covariance_filter_predicted;  
    1d22:	21 2f       	mov	r18, r17
    1d24:	30 2f       	mov	r19, r16
    1d26:	4f 2d       	mov	r20, r15
    1d28:	5e 2d       	mov	r21, r14
    1d2a:	60 e0       	ldi	r22, 0x00	; 0
    1d2c:	70 e0       	ldi	r23, 0x00	; 0
    1d2e:	80 e8       	ldi	r24, 0x80	; 128
    1d30:	9f e3       	ldi	r25, 0x3F	; 63
    1d32:	0e 94 0f 27 	call	0x4e1e	; 0x4e1e <__subsf3>
    1d36:	a3 01       	movw	r20, r6
    1d38:	92 01       	movw	r18, r4
    1d3a:	0e 94 91 29 	call	0x5322	; 0x5322 <__mulsf3>
    1d3e:	6d a7       	std	Y+45, r22	; 0x2d
    1d40:	7e a7       	std	Y+46, r23	; 0x2e
    1d42:	8f a7       	std	Y+47, r24	; 0x2f
    1d44:	98 ab       	std	Y+48, r25	; 0x30

			//DEBUG START
			static int16_t messageCounter = 0;
			if (messageCounter == 2){
    1d46:	80 91 70 1a 	lds	r24, 0x1A70	; 0x801a70 <messageCounter.3429>
    1d4a:	90 91 71 1a 	lds	r25, 0x1A71	; 0x801a71 <messageCounter.3429+0x1>
    1d4e:	82 30       	cpi	r24, 0x02	; 2
    1d50:	91 05       	cpc	r25, r1
    1d52:	21 f5       	brne	.+72     	; 0x1d9c <vMainPoseEstimatorTask+0x46c>
				messageCounter = 0;
    1d54:	10 92 71 1a 	sts	0x1A71, r1	; 0x801a71 <messageCounter.3429+0x1>
    1d58:	10 92 70 1a 	sts	0x1A70, r1	; 0x801a70 <messageCounter.3429>
				printf("%.0f %.0f %.2f\n",predictedX,predictedY,predictedTheta);
    1d5c:	8c 81       	ldd	r24, Y+4	; 0x04
    1d5e:	8f 93       	push	r24
    1d60:	8b 81       	ldd	r24, Y+3	; 0x03
    1d62:	8f 93       	push	r24
    1d64:	8a 81       	ldd	r24, Y+2	; 0x02
    1d66:	8f 93       	push	r24
    1d68:	89 81       	ldd	r24, Y+1	; 0x01
    1d6a:	8f 93       	push	r24
    1d6c:	bf 92       	push	r11
    1d6e:	af 92       	push	r10
    1d70:	9f 92       	push	r9
    1d72:	8f 92       	push	r8
    1d74:	98 a5       	ldd	r25, Y+40	; 0x28
    1d76:	9f 93       	push	r25
    1d78:	af a1       	ldd	r26, Y+39	; 0x27
    1d7a:	af 93       	push	r26
    1d7c:	be a1       	ldd	r27, Y+38	; 0x26
    1d7e:	bf 93       	push	r27
    1d80:	8d a1       	ldd	r24, Y+37	; 0x25
    1d82:	8f 93       	push	r24
    1d84:	ad e9       	ldi	r26, 0x9D	; 157
    1d86:	b6 e0       	ldi	r27, 0x06	; 6
    1d88:	bf 93       	push	r27
    1d8a:	af 93       	push	r26
    1d8c:	0e 94 e6 2f 	call	0x5fcc	; 0x5fcc <printf>
    1d90:	0f b6       	in	r0, 0x3f	; 63
    1d92:	f8 94       	cli
    1d94:	de bf       	out	0x3e, r29	; 62
    1d96:	0f be       	out	0x3f, r0	; 63
    1d98:	cd bf       	out	0x3d, r28	; 61
    1d9a:	05 c0       	rjmp	.+10     	; 0x1da6 <vMainPoseEstimatorTask+0x476>
				
				}else{
				messageCounter = messageCounter + 1;
    1d9c:	01 96       	adiw	r24, 0x01	; 1
    1d9e:	90 93 71 1a 	sts	0x1A71, r25	; 0x801a71 <messageCounter.3429+0x1>
    1da2:	80 93 70 1a 	sts	0x1A70, r24	; 0x801a70 <messageCounter.3429>
			}
			//DEBUG END

            // Update pose
            xSemaphoreTake(xPoseMutex, 15 / portTICK_PERIOD_MS);
    1da6:	23 2d       	mov	r18, r3
    1da8:	4f e0       	ldi	r20, 0x0F	; 15
    1daa:	50 e0       	ldi	r21, 0x00	; 0
    1dac:	60 e0       	ldi	r22, 0x00	; 0
    1dae:	70 e0       	ldi	r23, 0x00	; 0
    1db0:	80 91 34 1b 	lds	r24, 0x1B34	; 0x801b34 <xPoseMutex>
    1db4:	90 91 35 1b 	lds	r25, 0x1B35	; 0x801b35 <xPoseMutex+0x1>
    1db8:	0e 94 34 1b 	call	0x3668	; 0x3668 <xQueueGenericReceive>
                gTheta_hat = predictedTheta;
    1dbc:	89 81       	ldd	r24, Y+1	; 0x01
    1dbe:	9a 81       	ldd	r25, Y+2	; 0x02
    1dc0:	ab 81       	ldd	r26, Y+3	; 0x03
    1dc2:	bc 81       	ldd	r27, Y+4	; 0x04
    1dc4:	80 93 7a 1a 	sts	0x1A7A, r24	; 0x801a7a <gTheta_hat>
    1dc8:	90 93 7b 1a 	sts	0x1A7B, r25	; 0x801a7b <gTheta_hat+0x1>
    1dcc:	a0 93 7c 1a 	sts	0x1A7C, r26	; 0x801a7c <gTheta_hat+0x2>
    1dd0:	b0 93 7d 1a 	sts	0x1A7D, r27	; 0x801a7d <gTheta_hat+0x3>
                gX_hat = predictedX;
    1dd4:	5d a1       	ldd	r21, Y+37	; 0x25
    1dd6:	4e a1       	ldd	r20, Y+38	; 0x26
    1dd8:	3f a1       	ldd	r19, Y+39	; 0x27
    1dda:	28 a5       	ldd	r18, Y+40	; 0x28
    1ddc:	65 2f       	mov	r22, r21
    1dde:	74 2f       	mov	r23, r20
    1de0:	83 2f       	mov	r24, r19
    1de2:	92 2f       	mov	r25, r18
    1de4:	0e 94 45 28 	call	0x508a	; 0x508a <__fixsfsi>
    1de8:	70 93 79 1a 	sts	0x1A79, r23	; 0x801a79 <gX_hat+0x1>
    1dec:	60 93 78 1a 	sts	0x1A78, r22	; 0x801a78 <gX_hat>
                gY_hat = predictedY;
    1df0:	68 2d       	mov	r22, r8
    1df2:	79 2d       	mov	r23, r9
    1df4:	8a 2d       	mov	r24, r10
    1df6:	9b 2d       	mov	r25, r11
    1df8:	0e 94 45 28 	call	0x508a	; 0x508a <__fixsfsi>
    1dfc:	70 93 77 1a 	sts	0x1A77, r23	; 0x801a77 <gY_hat+0x1>
    1e00:	60 93 76 1a 	sts	0x1A76, r22	; 0x801a76 <gY_hat>
            xSemaphoreGive(xPoseMutex);
    1e04:	60 e0       	ldi	r22, 0x00	; 0
    1e06:	70 e0       	ldi	r23, 0x00	; 0
    1e08:	80 91 34 1b 	lds	r24, 0x1B34	; 0x801b34 <xPoseMutex>
    1e0c:	90 91 35 1b 	lds	r25, 0x1B35	; 0x801b35 <xPoseMutex+0x1>
    1e10:	0e 94 9a 19 	call	0x3334	; 0x3334 <xQueueGive>
            // Send semaphore to controller
            xSemaphoreGive(xControllerBSem);
    1e14:	60 e0       	ldi	r22, 0x00	; 0
    1e16:	70 e0       	ldi	r23, 0x00	; 0
    1e18:	80 91 18 1b 	lds	r24, 0x1B18	; 0x801b18 <xControllerBSem>
    1e1c:	90 91 19 1b 	lds	r25, 0x1B19	; 0x801b19 <xControllerBSem+0x1>
    1e20:	0e 94 9a 19 	call	0x3334	; 0x3334 <xQueueGive>
            xSemaphoreGive(xTickMutex);
            
            float dLeft = (float)(leftWheelTicks - previous_ticksLeft) * WHEEL_FACTOR_MM; // Distance left wheel has traveled since last sample
            float dRight =(float)(rightWheelTicks - previous_ticksRight) * WHEEL_FACTOR_MM; // Distance right wheel has traveled since last sample
            previous_ticksLeft = leftWheelTicks;
            previous_ticksRight = rightWheelTicks;
    1e24:	6b a4       	ldd	r6, Y+43	; 0x2b
    1e26:	7c a4       	ldd	r7, Y+44	; 0x2c
                rightWheelTicks = gRightWheelTicks;
            xSemaphoreGive(xTickMutex);
            
            float dLeft = (float)(leftWheelTicks - previous_ticksLeft) * WHEEL_FACTOR_MM; // Distance left wheel has traveled since last sample
            float dRight =(float)(rightWheelTicks - previous_ticksRight) * WHEEL_FACTOR_MM; // Distance right wheel has traveled since last sample
            previous_ticksLeft = leftWheelTicks;
    1e28:	49 a4       	ldd	r4, Y+41	; 0x29
    1e2a:	5a a4       	ldd	r5, Y+42	; 0x2a
    1e2c:	c6 cd       	rjmp	.-1140   	; 0x19ba <vMainPoseEstimatorTask+0x8a>
    1e2e:	05 e6       	ldi	r16, 0x65	; 101
    1e30:	10 e0       	ldi	r17, 0x00	; 0
    1e32:	c1 2c       	mov	r12, r1
    1e34:	d1 2c       	mov	r13, r1
    1e36:	e1 2c       	mov	r14, r1
    1e38:	f2 2c       	mov	r15, r2
            // Not connected, getting heading and gyro bias
            uint16_t i;
            uint16_t samples = 100;
            float gyro = 0;
            for (i = 0; i<=samples; i++){
                gyro+= fIMU_readFloatGyroZ();
    1e3a:	0e 94 94 05 	call	0xb28	; 0xb28 <fIMU_readFloatGyroZ>
    1e3e:	9b 01       	movw	r18, r22
    1e40:	ac 01       	movw	r20, r24
    1e42:	6c 2d       	mov	r22, r12
    1e44:	7d 2d       	mov	r23, r13
    1e46:	8e 2d       	mov	r24, r14
    1e48:	9f 2d       	mov	r25, r15
    1e4a:	0e 94 10 27 	call	0x4e20	; 0x4e20 <__addsf3>
    1e4e:	c6 2e       	mov	r12, r22
    1e50:	d7 2e       	mov	r13, r23
    1e52:	e8 2e       	mov	r14, r24
    1e54:	f9 2e       	mov	r15, r25
    1e56:	01 50       	subi	r16, 0x01	; 1
    1e58:	11 09       	sbc	r17, r1
        else{
            // Not connected, getting heading and gyro bias
            uint16_t i;
            uint16_t samples = 100;
            float gyro = 0;
            for (i = 0; i<=samples; i++){
    1e5a:	79 f7       	brne	.-34     	; 0x1e3a <vMainPoseEstimatorTask+0x50a>
                gyro+= fIMU_readFloatGyroZ();
            }
            
            int16_t xCom, yCom, zCom;
            vCOM_getData(&xCom, &yCom, &zCom);
    1e5c:	ae 01       	movw	r20, r28
    1e5e:	49 5f       	subi	r20, 0xF9	; 249
    1e60:	5f 4f       	sbci	r21, 0xFF	; 255
    1e62:	be 01       	movw	r22, r28
    1e64:	65 5f       	subi	r22, 0xF5	; 245
    1e66:	7f 4f       	sbci	r23, 0xFF	; 255
    1e68:	ce 01       	movw	r24, r28
    1e6a:	0d 96       	adiw	r24, 0x0d	; 13
    1e6c:	0e 94 6f 01 	call	0x2de	; 0x2de <vCOM_getData>
            xCom += xComOff;
    1e70:	6d 85       	ldd	r22, Y+13	; 0x0d
    1e72:	7e 85       	ldd	r23, Y+14	; 0x0e
    1e74:	65 5f       	subi	r22, 0xF5	; 245
    1e76:	7f 4f       	sbci	r23, 0xFF	; 255
            yCom += yComOff;
    1e78:	0b 85       	ldd	r16, Y+11	; 0x0b
    1e7a:	1c 85       	ldd	r17, Y+12	; 0x0c
    1e7c:	0e 54       	subi	r16, 0x4E	; 78
    1e7e:	11 09       	sbc	r17, r1
            
            
            // Initialize pose to 0 and reset offset variables
            predictedX = 0;
            predictedY = 0;
            predictedTheta = 0;
    1e80:	80 e0       	ldi	r24, 0x00	; 0
    1e82:	90 e0       	ldi	r25, 0x00	; 0
    1e84:	a0 e0       	ldi	r26, 0x00	; 0
    1e86:	b2 2d       	mov	r27, r2
    1e88:	89 83       	std	Y+1, r24	; 0x01
    1e8a:	9a 83       	std	Y+2, r25	; 0x02
    1e8c:	ab 83       	std	Y+3, r26	; 0x03
    1e8e:	bc 83       	std	Y+4, r27	; 0x04
            
            compassOffset = atan2(yCom, xCom);    
    1e90:	07 2e       	mov	r0, r23
    1e92:	00 0c       	add	r0, r0
    1e94:	88 0b       	sbc	r24, r24
    1e96:	99 0b       	sbc	r25, r25
    1e98:	0e 94 78 28 	call	0x50f0	; 0x50f0 <__floatsisf>
    1e9c:	4b 01       	movw	r8, r22
    1e9e:	5c 01       	movw	r10, r24
    1ea0:	b8 01       	movw	r22, r16
    1ea2:	11 0f       	add	r17, r17
    1ea4:	88 0b       	sbc	r24, r24
    1ea6:	99 0b       	sbc	r25, r25
    1ea8:	0e 94 78 28 	call	0x50f0	; 0x50f0 <__floatsisf>
    1eac:	a5 01       	movw	r20, r10
    1eae:	94 01       	movw	r18, r8
    1eb0:	0e 94 83 27 	call	0x4f06	; 0x4f06 <atan2>
    1eb4:	6d 8f       	std	Y+29, r22	; 0x1d
    1eb6:	7e 8f       	std	Y+30, r23	; 0x1e
    1eb8:	8f 8f       	std	Y+31, r24	; 0x1f
    1eba:	98 a3       	std	Y+32, r25	; 0x20
            gyroOffset = gyro / (float)i;               
    1ebc:	20 e0       	ldi	r18, 0x00	; 0
    1ebe:	30 e0       	ldi	r19, 0x00	; 0
    1ec0:	4a ec       	ldi	r20, 0xCA	; 202
    1ec2:	52 e4       	ldi	r21, 0x42	; 66
    1ec4:	6c 2d       	mov	r22, r12
    1ec6:	7d 2d       	mov	r23, r13
    1ec8:	8e 2d       	mov	r24, r14
    1eca:	9f 2d       	mov	r25, r15
    1ecc:	0e 94 dd 27 	call	0x4fba	; 0x4fba <__divsf3>
    1ed0:	69 8f       	std	Y+25, r22	; 0x19
    1ed2:	7a 8f       	std	Y+26, r23	; 0x1a
    1ed4:	8b 8f       	std	Y+27, r24	; 0x1b
    1ed6:	9c 8f       	std	Y+28, r25	; 0x1c
            yCom += yComOff;
            
            
            // Initialize pose to 0 and reset offset variables
            predictedX = 0;
            predictedY = 0;
    1ed8:	3d 8a       	std	Y+21, r3	; 0x15
    1eda:	3e 8a       	std	Y+22, r3	; 0x16
    1edc:	3f 8a       	std	Y+23, r3	; 0x17
    1ede:	38 8e       	std	Y+24, r3	; 0x18
            xCom += xComOff;
            yCom += yComOff;
            
            
            // Initialize pose to 0 and reset offset variables
            predictedX = 0;
    1ee0:	39 8a       	std	Y+17, r3	; 0x11
    1ee2:	3a 8a       	std	Y+18, r3	; 0x12
    1ee4:	3b 8a       	std	Y+19, r3	; 0x13
    1ee6:	3c 8a       	std	Y+20, r3	; 0x14
    1ee8:	68 cd       	rjmp	.-1328   	; 0x19ba <vMainPoseEstimatorTask+0x8a>

00001eea <vMainMovementTask>:
    } // While(1) end
}

/* Handles request from position controller and sets motor pins. */
/* Frequency set by PERIOD_MOTOR_MS in defines.h */
void vMainMovementTask( void *pvParameters ){
    1eea:	cf 93       	push	r28
    1eec:	df 93       	push	r29
    1eee:	cd b7       	in	r28, 0x3d	; 61
    1ef0:	de b7       	in	r29, 0x3e	; 62
    1ef2:	65 97       	sbiw	r28, 0x15	; 21
    1ef4:	0f b6       	in	r0, 0x3f	; 63
    1ef6:	f8 94       	cli
    1ef8:	de bf       	out	0x3e, r29	; 62
    1efa:	0f be       	out	0x3f, r0	; 63
    1efc:	cd bf       	out	0x3d, r28	; 61
    /* Task init */
    uint8_t lastMovement = 0;
    1efe:	19 82       	std	Y+1, r1	; 0x01
    uint8_t movement = 0;
    1f00:	1a 82       	std	Y+2, r1	; 0x02
    uint8_t actuation = 0;
    1f02:	1b 82       	std	Y+3, r1	; 0x03
    
    
    const TickType_t xDelay = PERIOD_MOTOR_MS;
    // Initialise the xLastWakeTime variable with the current time.
    TickType_t xLastWakeTime;
    xLastWakeTime = xTaskGetTickCount();
    1f04:	0e 94 70 23 	call	0x46e0	; 0x46e0 <xTaskGetTickCount>
    1f08:	9d 83       	std	Y+5, r25	; 0x05
    1f0a:	8c 83       	std	Y+4, r24	; 0x04
    #ifdef DEBUG
    printf("Movement OK\n");
    1f0c:	8d ea       	ldi	r24, 0xAD	; 173
    1f0e:	96 e0       	ldi	r25, 0x06	; 6
    1f10:	0e 94 f9 2f 	call	0x5ff2	; 0x5ff2 <puts>
    #endif
    
    int16_t leftWheelTicks = 0;
    1f14:	1f 82       	std	Y+7, r1	; 0x07
    1f16:	1e 82       	std	Y+6, r1	; 0x06
    int16_t rightWheelTicks = 0;
    1f18:	19 86       	std	Y+9, r1	; 0x09
    1f1a:	18 86       	std	Y+8, r1	; 0x08
    
    uint8_t leftEncoderVal = 0;
    uint8_t rightEncoderVal = 0;
    
    uint8_t gLeftWheelDirection = 0;
    1f1c:	1a 86       	std	Y+10, r1	; 0x0a
    uint8_t gRightWheelDirection = 0;
    1f1e:	1b 86       	std	Y+11, r1	; 0x0b
    
    // PI control Variabels 
    uint8_t previous_leftEncoderVal = 0;
    uint8_t previous_rightEncoderVal = 0;
    int16_t errorL_I = 0;
    int16_t errorR_I = 0;
    1f20:	61 2c       	mov	r6, r1
    1f22:	71 2c       	mov	r7, r1
    
    
    // PI control Variabels 
    uint8_t previous_leftEncoderVal = 0;
    uint8_t previous_rightEncoderVal = 0;
    int16_t errorL_I = 0;
    1f24:	21 2c       	mov	r2, r1
    1f26:	31 2c       	mov	r3, r1
    int16_t bias_RightWheelTick = 0;
    
    
    // PI control Variabels 
    uint8_t previous_leftEncoderVal = 0;
    uint8_t previous_rightEncoderVal = 0;
    1f28:	10 e0       	ldi	r17, 0x00	; 0
    uint8_t lastMovement = 0;
    uint8_t movement = 0;
    uint8_t actuation = 0;
    
    int16_t bias_LeftWheelTick = 0;
    int16_t bias_RightWheelTick = 0;
    1f2a:	41 2c       	mov	r4, r1
    1f2c:	51 2c       	mov	r5, r1
    /* Task init */
    uint8_t lastMovement = 0;
    uint8_t movement = 0;
    uint8_t actuation = 0;
    
    int16_t bias_LeftWheelTick = 0;
    1f2e:	1b 8a       	std	Y+19, r1	; 0x13
    1f30:	1a 8a       	std	Y+18, r1	; 0x12
    1f32:	a1 2c       	mov	r10, r1
            xQueueReceive(actuationQ, &actuation, 0);
            if (movement != lastMovement){
                bias_LeftWheelTick = leftWheelTicks;
                bias_RightWheelTick = rightWheelTicks;
                lastMovement = movement;                   
                xQueueSend(scanStatusQ, &lastMovement, 0); // Send the current movement to the scan task
    1f34:	5d 8a       	std	Y+21, r5	; 0x15
    1f36:	4c 8a       	std	Y+20, r4	; 0x14
    1f38:	d1 2e       	mov	r13, r17
    1f3a:	43 01       	movw	r8, r6
    uint8_t gRightWheelDirection = 0;
    
    
    
    while(1){
        vTaskDelayUntil(&xLastWakeTime, xDelay / portTICK_PERIOD_MS );  
    1f3c:	64 e1       	ldi	r22, 0x14	; 20
    1f3e:	70 e0       	ldi	r23, 0x00	; 0
    1f40:	ce 01       	movw	r24, r28
    1f42:	04 96       	adiw	r24, 0x04	; 4
    1f44:	0e 94 23 1e 	call	0x3c46	; 0x3c46 <vTaskDelayUntil>
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    1f48:	f8 94       	cli
        // Handle encoder ticks
        ATOMIC_BLOCK(ATOMIC_FORCEON){
            leftEncoderVal = gISR_leftWheelTicks;
    1f4a:	40 91 81 1a 	lds	r20, 0x1A81	; 0x801a81 <gISR_leftWheelTicks>
            gISR_leftWheelTicks = 0;
    1f4e:	10 92 81 1a 	sts	0x1A81, r1	; 0x801a81 <gISR_leftWheelTicks>
            rightEncoderVal = gISR_rightWheelTicks;
    1f52:	b0 90 82 1a 	lds	r11, 0x1A82	; 0x801a82 <gISR_rightWheelTicks>
            gISR_rightWheelTicks = 0;
    1f56:	10 92 82 1a 	sts	0x1A82, r1	; 0x801a82 <gISR_rightWheelTicks>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    1f5a:	78 94       	sei
        }
        vMotorEncoderLeftTickFromISR(gLeftWheelDirection, &leftWheelTicks, leftEncoderVal);
    1f5c:	be 01       	movw	r22, r28
    1f5e:	6a 5f       	subi	r22, 0xFA	; 250
    1f60:	7f 4f       	sbci	r23, 0xFF	; 255
    1f62:	8a 85       	ldd	r24, Y+10	; 0x0a
    1f64:	7f d4       	rcall	.+2302   	; 0x2864 <vMotorEncoderLeftTickFromISR>
        vMotorEncoderRightTickFromISR(gRightWheelDirection, &rightWheelTicks, rightEncoderVal);
    1f66:	4b 2d       	mov	r20, r11
    1f68:	be 01       	movw	r22, r28
    1f6a:	68 5f       	subi	r22, 0xF8	; 248
    1f6c:	7f 4f       	sbci	r23, 0xFF	; 255
    1f6e:	8b 85       	ldd	r24, Y+11	; 0x0b
    1f70:	90 d4       	rcall	.+2336   	; 0x2892 <vMotorEncoderRightTickFromISR>
        
        xSemaphoreTake(xTickMutex,1 / portTICK_PERIOD_MS);
    1f72:	20 e0       	ldi	r18, 0x00	; 0
    1f74:	41 e0       	ldi	r20, 0x01	; 1
    1f76:	50 e0       	ldi	r21, 0x00	; 0
    1f78:	60 e0       	ldi	r22, 0x00	; 0
    1f7a:	70 e0       	ldi	r23, 0x00	; 0
    1f7c:	80 91 1a 1b 	lds	r24, 0x1B1A	; 0x801b1a <xTickMutex>
    1f80:	90 91 1b 1b 	lds	r25, 0x1B1B	; 0x801b1b <xTickMutex+0x1>
    1f84:	0e 94 34 1b 	call	0x3668	; 0x3668 <xQueueGenericReceive>
            gLeftWheelTicks = leftWheelTicks;
    1f88:	8e 81       	ldd	r24, Y+6	; 0x06
    1f8a:	9f 81       	ldd	r25, Y+7	; 0x07
    1f8c:	90 93 73 1a 	sts	0x1A73, r25	; 0x801a73 <gLeftWheelTicks+0x1>
    1f90:	80 93 72 1a 	sts	0x1A72, r24	; 0x801a72 <gLeftWheelTicks>
            gRightWheelTicks = rightWheelTicks;
    1f94:	88 85       	ldd	r24, Y+8	; 0x08
    1f96:	99 85       	ldd	r25, Y+9	; 0x09
    1f98:	90 93 75 1a 	sts	0x1A75, r25	; 0x801a75 <gRightWheelTicks+0x1>
    1f9c:	80 93 74 1a 	sts	0x1A74, r24	; 0x801a74 <gRightWheelTicks>
        xSemaphoreGive(xTickMutex);
    1fa0:	60 e0       	ldi	r22, 0x00	; 0
    1fa2:	70 e0       	ldi	r23, 0x00	; 0
    1fa4:	80 91 1a 1b 	lds	r24, 0x1B1A	; 0x801b1a <xTickMutex>
    1fa8:	90 91 1b 1b 	lds	r25, 0x1B1B	; 0x801b1b <xTickMutex+0x1>
    1fac:	0e 94 9a 19 	call	0x3334	; 0x3334 <xQueueGive>
            
        if (gHandshook){ // Check if we are connected and good to go
    1fb0:	80 91 80 1a 	lds	r24, 0x1A80	; 0x801a80 <gHandshook>
    1fb4:	88 23       	and	r24, r24
    1fb6:	09 f4       	brne	.+2      	; 0x1fba <vMainMovementTask+0xd0>
    1fb8:	ac c1       	rjmp	.+856    	; 0x2312 <__stack+0x113>
            xQueueReceive(movementQ, &movement, 0);
    1fba:	20 e0       	ldi	r18, 0x00	; 0
    1fbc:	40 e0       	ldi	r20, 0x00	; 0
    1fbe:	50 e0       	ldi	r21, 0x00	; 0
    1fc0:	be 01       	movw	r22, r28
    1fc2:	6e 5f       	subi	r22, 0xFE	; 254
    1fc4:	7f 4f       	sbci	r23, 0xFF	; 255
    1fc6:	80 91 89 1a 	lds	r24, 0x1A89	; 0x801a89 <movementQ>
    1fca:	90 91 8a 1a 	lds	r25, 0x1A8A	; 0x801a8a <movementQ+0x1>
    1fce:	0e 94 34 1b 	call	0x3668	; 0x3668 <xQueueGenericReceive>
            xQueueReceive(actuationQ, &actuation, 0);
    1fd2:	20 e0       	ldi	r18, 0x00	; 0
    1fd4:	40 e0       	ldi	r20, 0x00	; 0
    1fd6:	50 e0       	ldi	r21, 0x00	; 0
    1fd8:	be 01       	movw	r22, r28
    1fda:	6d 5f       	subi	r22, 0xFD	; 253
    1fdc:	7f 4f       	sbci	r23, 0xFF	; 255
    1fde:	80 91 83 1a 	lds	r24, 0x1A83	; 0x801a83 <actuationQ>
    1fe2:	90 91 84 1a 	lds	r25, 0x1A84	; 0x801a84 <actuationQ+0x1>
    1fe6:	0e 94 34 1b 	call	0x3668	; 0x3668 <xQueueGenericReceive>
            if (movement != lastMovement){
    1fea:	8a 81       	ldd	r24, Y+2	; 0x02
    1fec:	99 81       	ldd	r25, Y+1	; 0x01
    1fee:	89 17       	cp	r24, r25
    1ff0:	a1 f0       	breq	.+40     	; 0x201a <vMainMovementTask+0x130>
                bias_LeftWheelTick = leftWheelTicks;
    1ff2:	2e 81       	ldd	r18, Y+6	; 0x06
    1ff4:	3f 81       	ldd	r19, Y+7	; 0x07
    1ff6:	3b 8b       	std	Y+19, r19	; 0x13
    1ff8:	2a 8b       	std	Y+18, r18	; 0x12
                bias_RightWheelTick = rightWheelTicks;
    1ffa:	28 85       	ldd	r18, Y+8	; 0x08
    1ffc:	39 85       	ldd	r19, Y+9	; 0x09
    1ffe:	3d 8b       	std	Y+21, r19	; 0x15
    2000:	2c 8b       	std	Y+20, r18	; 0x14
                lastMovement = movement;                   
    2002:	89 83       	std	Y+1, r24	; 0x01
                xQueueSend(scanStatusQ, &lastMovement, 0); // Send the current movement to the scan task
    2004:	20 e0       	ldi	r18, 0x00	; 0
    2006:	40 e0       	ldi	r20, 0x00	; 0
    2008:	50 e0       	ldi	r21, 0x00	; 0
    200a:	be 01       	movw	r22, r28
    200c:	6f 5f       	subi	r22, 0xFF	; 255
    200e:	7f 4f       	sbci	r23, 0xFF	; 255
    2010:	80 91 85 1a 	lds	r24, 0x1A85	; 0x801a85 <scanStatusQ>
    2014:	90 91 86 1a 	lds	r25, 0x1A86	; 0x801a86 <scanStatusQ+0x1>
    2018:	bc d7       	rcall	.+3960   	; 0x2f92 <xQueueGenericSend>
            }
            int16_t tmp_leftWheelTicks = 0;
            int16_t tmp_rightWheelTicks = 0;
            
            tmp_leftWheelTicks = leftWheelTicks - bias_LeftWheelTick;
    201a:	ee 80       	ldd	r14, Y+6	; 0x06
    201c:	ff 80       	ldd	r15, Y+7	; 0x07
    201e:	97 01       	movw	r18, r14
    2020:	8a 89       	ldd	r24, Y+18	; 0x12
    2022:	9b 89       	ldd	r25, Y+19	; 0x13
    2024:	28 1b       	sub	r18, r24
    2026:	39 0b       	sbc	r19, r25
            tmp_rightWheelTicks = rightWheelTicks - bias_RightWheelTick;
    2028:	08 85       	ldd	r16, Y+8	; 0x08
    202a:	19 85       	ldd	r17, Y+9	; 0x09
    202c:	a8 01       	movw	r20, r16
    202e:	8c 89       	ldd	r24, Y+20	; 0x14
    2030:	9d 89       	ldd	r25, Y+21	; 0x15
    2032:	48 1b       	sub	r20, r24
    2034:	59 0b       	sbc	r21, r25

            /* Saturate values */
            if (actuation <= 0) actuation = 0;
    2036:	8b 81       	ldd	r24, Y+3	; 0x03
    2038:	81 11       	cpse	r24, r1
    203a:	02 c0       	rjmp	.+4      	; 0x2040 <vMainMovementTask+0x156>
    203c:	1b 82       	std	Y+3, r1	; 0x03
    203e:	04 c0       	rjmp	.+8      	; 0x2048 <vMainMovementTask+0x15e>
            else if (actuation > 25) actuation = 25; 
    2040:	8a 31       	cpi	r24, 0x1A	; 26
    2042:	10 f0       	brcs	.+4      	; 0x2048 <vMainMovementTask+0x15e>
    2044:	99 e1       	ldi	r25, 0x19	; 25
    2046:	9b 83       	std	Y+3, r25	; 0x03
            // Use right motor as "Master" and left as "Slave" 
            //uint8_t rightOutput = actuation * 8 + 40; // scale actuation from 48-240
            
            // PI controller for motors
            
			rightVelocitySP = actuation;
    2048:	cb 80       	ldd	r12, Y+3	; 0x03
    204a:	8c 2d       	mov	r24, r12
    204c:	90 e0       	ldi	r25, 0x00	; 0
            
            int8_t leftVelocity = leftEncoderVal - previous_leftEncoderVal;
            previous_leftEncoderVal = tmp_leftWheelTicks;
            
            int8_t rightVelocity = rightEncoderVal - previous_rightEncoderVal;
    204e:	6b 2d       	mov	r22, r11
    2050:	6d 19       	sub	r22, r13
            previous_rightEncoderVal = rightEncoderVal;
            
            int16_t errorR = (rightVelocitySP - rightVelocity);
    2052:	6c 01       	movw	r12, r24
    2054:	c6 1a       	sub	r12, r22
    2056:	d1 08       	sbc	r13, r1
    2058:	67 fd       	sbrc	r22, 7
    205a:	d3 94       	inc	r13
            //int16_t errorL = (rightVelocity - leftVelocity);
            int16_t errorL = abs(abs(tmp_rightWheelTicks) - abs(tmp_leftWheelTicks));                      
    205c:	ca 01       	movw	r24, r20
    205e:	99 23       	and	r25, r25
    2060:	24 f4       	brge	.+8      	; 0x206a <vMainMovementTask+0x180>
    2062:	88 27       	eor	r24, r24
    2064:	99 27       	eor	r25, r25
    2066:	84 1b       	sub	r24, r20
    2068:	95 0b       	sbc	r25, r21
    206a:	a9 01       	movw	r20, r18
    206c:	33 23       	and	r19, r19
    206e:	24 f4       	brge	.+8      	; 0x2078 <vMainMovementTask+0x18e>
    2070:	44 27       	eor	r20, r20
    2072:	55 27       	eor	r21, r21
    2074:	42 1b       	sub	r20, r18
    2076:	53 0b       	sbc	r21, r19
    2078:	84 1b       	sub	r24, r20
    207a:	95 0b       	sbc	r25, r21
    207c:	9c 01       	movw	r18, r24
    207e:	22 f4       	brpl	.+8      	; 0x2088 <vMainMovementTask+0x19e>
    2080:	22 27       	eor	r18, r18
    2082:	33 27       	eor	r19, r19
    2084:	28 1b       	sub	r18, r24
    2086:	39 0b       	sbc	r19, r25
    2088:	c9 01       	movw	r24, r18
            
            errorR_I += errorR;
    208a:	8c 0c       	add	r8, r12
    208c:	9d 1c       	adc	r9, r13
            errorL_I += errorL;
    208e:	22 0e       	add	r2, r18
    2090:	33 1e       	adc	r3, r19
    2092:	2f ef       	ldi	r18, 0xFF	; 255
    2094:	22 16       	cp	r2, r18
    2096:	31 04       	cpc	r3, r1
    2098:	21 f0       	breq	.+8      	; 0x20a2 <vMainMovementTask+0x1b8>
    209a:	1c f0       	brlt	.+6      	; 0x20a2 <vMainMovementTask+0x1b8>
    209c:	22 24       	eor	r2, r2
    209e:	2a 94       	dec	r2
    20a0:	3a 2c       	mov	r3, r10
    20a2:	3f ef       	ldi	r19, 0xFF	; 255
    20a4:	83 16       	cp	r8, r19
    20a6:	91 04       	cpc	r9, r1
    20a8:	21 f0       	breq	.+8      	; 0x20b2 <vMainMovementTask+0x1c8>
    20aa:	1c f0       	brlt	.+6      	; 0x20b2 <vMainMovementTask+0x1c8>
    20ac:	88 24       	eor	r8, r8
    20ae:	8a 94       	dec	r8
    20b0:	9a 2c       	mov	r9, r10
            
            if (errorL_I > 255) errorL_I = 255;
            if (errorR_I > 255) errorR_I = 255;
            
            int16_t rightOutput = 2 * errorR + 2 * errorR_I;
    20b2:	c8 0c       	add	r12, r8
    20b4:	d9 1c       	adc	r13, r9
    20b6:	cc 0c       	add	r12, r12
    20b8:	dd 1c       	adc	r13, r13
            int16_t leftOutput = rightOutput + 10 * errorL + errorL_I;
    20ba:	9c 01       	movw	r18, r24
    20bc:	22 0f       	add	r18, r18
    20be:	33 1f       	adc	r19, r19
    20c0:	88 0f       	add	r24, r24
    20c2:	99 1f       	adc	r25, r25
    20c4:	88 0f       	add	r24, r24
    20c6:	99 1f       	adc	r25, r25
    20c8:	88 0f       	add	r24, r24
    20ca:	99 1f       	adc	r25, r25
    20cc:	82 0f       	add	r24, r18
    20ce:	93 1f       	adc	r25, r19
    20d0:	8c 0d       	add	r24, r12
    20d2:	9d 1d       	adc	r25, r13
    20d4:	91 01       	movw	r18, r2
    20d6:	28 0f       	add	r18, r24
    20d8:	39 1f       	adc	r19, r25
    20da:	39 8b       	std	Y+17, r19	; 0x11
    20dc:	28 8b       	std	Y+16, r18	; 0x10
			static int16_t previous_ticksLeft = 0;
			static int16_t previous_ticksRight = 0;
			static float totalRobot = 0;
			static float totalTheta = 0;
			
			float dLeft = (float)(leftWheelTicks - previous_ticksLeft) * WHEEL_FACTOR_MM; // Distance left wheel has traveled since last sample
    20de:	80 91 6e 1a 	lds	r24, 0x1A6E	; 0x801a6e <previous_ticksLeft.3474>
    20e2:	90 91 6f 1a 	lds	r25, 0x1A6F	; 0x801a6f <previous_ticksLeft.3474+0x1>
    20e6:	b7 01       	movw	r22, r14
    20e8:	68 1b       	sub	r22, r24
    20ea:	79 0b       	sbc	r23, r25
    20ec:	07 2e       	mov	r0, r23
    20ee:	00 0c       	add	r0, r0
    20f0:	88 0b       	sbc	r24, r24
    20f2:	99 0b       	sbc	r25, r25
    20f4:	0e 94 78 28 	call	0x50f0	; 0x50f0 <__floatsisf>
    20f8:	2d e3       	ldi	r18, 0x3D	; 61
    20fa:	3c e2       	ldi	r19, 0x2C	; 44
    20fc:	44 e5       	ldi	r20, 0x54	; 84
    20fe:	5e e3       	ldi	r21, 0x3E	; 62
    2100:	0e 94 91 29 	call	0x5322	; 0x5322 <__mulsf3>
    2104:	6c 87       	std	Y+12, r22	; 0x0c
    2106:	7d 87       	std	Y+13, r23	; 0x0d
    2108:	8e 87       	std	Y+14, r24	; 0x0e
    210a:	9f 87       	std	Y+15, r25	; 0x0f
			float dRight =(float)(rightWheelTicks - previous_ticksRight) * WHEEL_FACTOR_MM; // Distance right wheel has traveled since last sample
    210c:	80 91 6c 1a 	lds	r24, 0x1A6C	; 0x801a6c <previous_ticksRight.3475>
    2110:	90 91 6d 1a 	lds	r25, 0x1A6D	; 0x801a6d <previous_ticksRight.3475+0x1>
    2114:	b8 01       	movw	r22, r16
    2116:	68 1b       	sub	r22, r24
    2118:	79 0b       	sbc	r23, r25
    211a:	07 2e       	mov	r0, r23
    211c:	00 0c       	add	r0, r0
    211e:	88 0b       	sbc	r24, r24
    2120:	99 0b       	sbc	r25, r25
    2122:	0e 94 78 28 	call	0x50f0	; 0x50f0 <__floatsisf>
    2126:	2d e3       	ldi	r18, 0x3D	; 61
    2128:	3c e2       	ldi	r19, 0x2C	; 44
    212a:	44 e5       	ldi	r20, 0x54	; 84
    212c:	5e e3       	ldi	r21, 0x3E	; 62
    212e:	0e 94 91 29 	call	0x5322	; 0x5322 <__mulsf3>
    2132:	2b 01       	movw	r4, r22
    2134:	3c 01       	movw	r6, r24
			previous_ticksLeft = leftWheelTicks;
    2136:	f0 92 6f 1a 	sts	0x1A6F, r15	; 0x801a6f <previous_ticksLeft.3474+0x1>
    213a:	e0 92 6e 1a 	sts	0x1A6E, r14	; 0x801a6e <previous_ticksLeft.3474>
			previous_ticksRight = rightWheelTicks;
    213e:	10 93 6d 1a 	sts	0x1A6D, r17	; 0x801a6d <previous_ticksRight.3475+0x1>
    2142:	00 93 6c 1a 	sts	0x1A6C, r16	; 0x801a6c <previous_ticksRight.3475>
			
			float dRobot = (dLeft + dRight) / 2;
    2146:	9b 01       	movw	r18, r22
    2148:	ac 01       	movw	r20, r24
    214a:	6c 85       	ldd	r22, Y+12	; 0x0c
    214c:	7d 85       	ldd	r23, Y+13	; 0x0d
    214e:	8e 85       	ldd	r24, Y+14	; 0x0e
    2150:	9f 85       	ldd	r25, Y+15	; 0x0f
    2152:	0e 94 10 27 	call	0x4e20	; 0x4e20 <__addsf3>
    2156:	20 e0       	ldi	r18, 0x00	; 0
    2158:	30 e0       	ldi	r19, 0x00	; 0
    215a:	40 e0       	ldi	r20, 0x00	; 0
    215c:	5f e3       	ldi	r21, 0x3F	; 63
    215e:	0e 94 91 29 	call	0x5322	; 0x5322 <__mulsf3>
    2162:	9b 01       	movw	r18, r22
    2164:	ac 01       	movw	r20, r24
			float dTheta = (dRight - dLeft) / WHEELBASE_MM; // Get angle from encoders, dervied from arch of circles formula
			
			totalRobot += dRobot;
    2166:	60 91 68 1a 	lds	r22, 0x1A68	; 0x801a68 <totalRobot.3476>
    216a:	70 91 69 1a 	lds	r23, 0x1A69	; 0x801a69 <totalRobot.3476+0x1>
    216e:	80 91 6a 1a 	lds	r24, 0x1A6A	; 0x801a6a <totalRobot.3476+0x2>
    2172:	90 91 6b 1a 	lds	r25, 0x1A6B	; 0x801a6b <totalRobot.3476+0x3>
    2176:	0e 94 10 27 	call	0x4e20	; 0x4e20 <__addsf3>
    217a:	60 93 68 1a 	sts	0x1A68, r22	; 0x801a68 <totalRobot.3476>
    217e:	70 93 69 1a 	sts	0x1A69, r23	; 0x801a69 <totalRobot.3476+0x1>
    2182:	80 93 6a 1a 	sts	0x1A6A, r24	; 0x801a6a <totalRobot.3476+0x2>
    2186:	90 93 6b 1a 	sts	0x1A6B, r25	; 0x801a6b <totalRobot.3476+0x3>
			float dRight =(float)(rightWheelTicks - previous_ticksRight) * WHEEL_FACTOR_MM; // Distance right wheel has traveled since last sample
			previous_ticksLeft = leftWheelTicks;
			previous_ticksRight = rightWheelTicks;
			
			float dRobot = (dLeft + dRight) / 2;
			float dTheta = (dRight - dLeft) / WHEELBASE_MM; // Get angle from encoders, dervied from arch of circles formula
    218a:	2c 85       	ldd	r18, Y+12	; 0x0c
    218c:	3d 85       	ldd	r19, Y+13	; 0x0d
    218e:	4e 85       	ldd	r20, Y+14	; 0x0e
    2190:	5f 85       	ldd	r21, Y+15	; 0x0f
    2192:	c3 01       	movw	r24, r6
    2194:	b2 01       	movw	r22, r4
    2196:	0e 94 0f 27 	call	0x4e1e	; 0x4e1e <__subsf3>
    219a:	20 e0       	ldi	r18, 0x00	; 0
    219c:	30 e0       	ldi	r19, 0x00	; 0
    219e:	47 e5       	ldi	r20, 0x57	; 87
    21a0:	53 e4       	ldi	r21, 0x43	; 67
    21a2:	0e 94 dd 27 	call	0x4fba	; 0x4fba <__divsf3>
    21a6:	9b 01       	movw	r18, r22
    21a8:	ac 01       	movw	r20, r24
			
			totalRobot += dRobot;
			totalTheta += dTheta;
    21aa:	60 91 64 1a 	lds	r22, 0x1A64	; 0x801a64 <totalTheta.3477>
    21ae:	70 91 65 1a 	lds	r23, 0x1A65	; 0x801a65 <totalTheta.3477+0x1>
    21b2:	80 91 66 1a 	lds	r24, 0x1A66	; 0x801a66 <totalTheta.3477+0x2>
    21b6:	90 91 67 1a 	lds	r25, 0x1A67	; 0x801a67 <totalTheta.3477+0x3>
    21ba:	0e 94 10 27 	call	0x4e20	; 0x4e20 <__addsf3>
    21be:	60 93 64 1a 	sts	0x1A64, r22	; 0x801a64 <totalTheta.3477>
    21c2:	70 93 65 1a 	sts	0x1A65, r23	; 0x801a65 <totalTheta.3477+0x1>
    21c6:	80 93 66 1a 	sts	0x1A66, r24	; 0x801a66 <totalTheta.3477+0x2>
    21ca:	90 93 67 1a 	sts	0x1A67, r25	; 0x801a67 <totalTheta.3477+0x3>
			
			float period_in_S = PERIOD_MOTOR_MS / 1000.0f;
			static float predictedTheta = 0.0;
			
			
			float gyrZ = fIMU_readFloatGyroZ() - 0.6728; //Offset:  - 0.6728 degrees
    21ce:	0e 94 94 05 	call	0xb28	; 0xb28 <fIMU_readFloatGyroZ>
    21d2:	2f e9       	ldi	r18, 0x9F	; 159
    21d4:	3c e3       	ldi	r19, 0x3C	; 60
    21d6:	4c e2       	ldi	r20, 0x2C	; 44
    21d8:	5f e3       	ldi	r21, 0x3F	; 63
    21da:	0e 94 0f 27 	call	0x4e1e	; 0x4e1e <__subsf3>
			gyrZ *= period_in_S * DEG2RAD; // Scale gyro measurement
    21de:	24 ed       	ldi	r18, 0xD4	; 212
    21e0:	32 e0       	ldi	r19, 0x02	; 2
    21e2:	47 eb       	ldi	r20, 0xB7	; 183
    21e4:	59 e3       	ldi	r21, 0x39	; 57
    21e6:	0e 94 91 29 	call	0x5322	; 0x5322 <__mulsf3>
    21ea:	9b 01       	movw	r18, r22
    21ec:	ac 01       	movw	r20, r24
			predictedTheta += gyrZ;
    21ee:	60 91 60 1a 	lds	r22, 0x1A60	; 0x801a60 <predictedTheta.3483>
    21f2:	70 91 61 1a 	lds	r23, 0x1A61	; 0x801a61 <predictedTheta.3483+0x1>
    21f6:	80 91 62 1a 	lds	r24, 0x1A62	; 0x801a62 <predictedTheta.3483+0x2>
    21fa:	90 91 63 1a 	lds	r25, 0x1A63	; 0x801a63 <predictedTheta.3483+0x3>
    21fe:	0e 94 10 27 	call	0x4e20	; 0x4e20 <__addsf3>
    2202:	60 93 60 1a 	sts	0x1A60, r22	; 0x801a60 <predictedTheta.3483>
    2206:	70 93 61 1a 	sts	0x1A61, r23	; 0x801a61 <predictedTheta.3483+0x1>
    220a:	80 93 62 1a 	sts	0x1A62, r24	; 0x801a62 <predictedTheta.3483+0x2>
    220e:	90 93 63 1a 	sts	0x1A63, r25	; 0x801a63 <predictedTheta.3483+0x3>
			
			static float accelY = 0;
			
			accelY = (fIMU_readFloatAccelY() - 0.02);
    2212:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <fIMU_readFloatAccelY>
    2216:	2a e0       	ldi	r18, 0x0A	; 10
    2218:	37 ed       	ldi	r19, 0xD7	; 215
    221a:	43 ea       	ldi	r20, 0xA3	; 163
    221c:	5c e3       	ldi	r21, 0x3C	; 60
    221e:	0e 94 0f 27 	call	0x4e1e	; 0x4e1e <__subsf3>
    2222:	2b 01       	movw	r4, r22
    2224:	3c 01       	movw	r6, r24
    2226:	60 93 5c 1a 	sts	0x1A5C, r22	; 0x801a5c <accelY.3485>
    222a:	70 93 5d 1a 	sts	0x1A5D, r23	; 0x801a5d <accelY.3485+0x1>
    222e:	80 93 5e 1a 	sts	0x1A5E, r24	; 0x801a5e <accelY.3485+0x2>
    2232:	90 93 5f 1a 	sts	0x1A5F, r25	; 0x801a5f <accelY.3485+0x3>
			
			static float dacclIntr;
			static float acclIntr;
			
			if (fabs(accelY) > 0.01 ){	
    2236:	9f 77       	andi	r25, 0x7F	; 127
    2238:	2a e0       	ldi	r18, 0x0A	; 10
    223a:	37 ed       	ldi	r19, 0xD7	; 215
    223c:	43 e2       	ldi	r20, 0x23	; 35
    223e:	5c e3       	ldi	r21, 0x3C	; 60
    2240:	0e 94 86 29 	call	0x530c	; 0x530c <__gesf2>
    2244:	18 16       	cp	r1, r24
    2246:	44 f5       	brge	.+80     	; 0x2298 <__stack+0x99>
				acclIntr += accelY;	
    2248:	20 91 58 1a 	lds	r18, 0x1A58	; 0x801a58 <acclIntr.3487>
    224c:	30 91 59 1a 	lds	r19, 0x1A59	; 0x801a59 <acclIntr.3487+0x1>
    2250:	40 91 5a 1a 	lds	r20, 0x1A5A	; 0x801a5a <acclIntr.3487+0x2>
    2254:	50 91 5b 1a 	lds	r21, 0x1A5B	; 0x801a5b <acclIntr.3487+0x3>
    2258:	c3 01       	movw	r24, r6
    225a:	b2 01       	movw	r22, r4
    225c:	0e 94 10 27 	call	0x4e20	; 0x4e20 <__addsf3>
    2260:	9b 01       	movw	r18, r22
    2262:	ac 01       	movw	r20, r24
    2264:	60 93 58 1a 	sts	0x1A58, r22	; 0x801a58 <acclIntr.3487>
    2268:	70 93 59 1a 	sts	0x1A59, r23	; 0x801a59 <acclIntr.3487+0x1>
    226c:	80 93 5a 1a 	sts	0x1A5A, r24	; 0x801a5a <acclIntr.3487+0x2>
    2270:	90 93 5b 1a 	sts	0x1A5B, r25	; 0x801a5b <acclIntr.3487+0x3>
				dacclIntr += acclIntr;
    2274:	60 91 54 1a 	lds	r22, 0x1A54	; 0x801a54 <dacclIntr.3486>
    2278:	70 91 55 1a 	lds	r23, 0x1A55	; 0x801a55 <dacclIntr.3486+0x1>
    227c:	80 91 56 1a 	lds	r24, 0x1A56	; 0x801a56 <dacclIntr.3486+0x2>
    2280:	90 91 57 1a 	lds	r25, 0x1A57	; 0x801a57 <dacclIntr.3486+0x3>
    2284:	0e 94 10 27 	call	0x4e20	; 0x4e20 <__addsf3>
    2288:	60 93 54 1a 	sts	0x1A54, r22	; 0x801a54 <dacclIntr.3486>
    228c:	70 93 55 1a 	sts	0x1A55, r23	; 0x801a55 <dacclIntr.3486+0x1>
    2290:	80 93 56 1a 	sts	0x1A56, r24	; 0x801a56 <dacclIntr.3486+0x2>
    2294:	90 93 57 1a 	sts	0x1A57, r25	; 0x801a57 <dacclIntr.3486+0x3>
			}
		
			static int16_t messageCounter = 0;
			if (messageCounter == 3){
    2298:	80 91 52 1a 	lds	r24, 0x1A52	; 0x801a52 <messageCounter.3488>
    229c:	90 91 53 1a 	lds	r25, 0x1A53	; 0x801a53 <messageCounter.3488+0x1>
    22a0:	83 30       	cpi	r24, 0x03	; 3
    22a2:	91 05       	cpc	r25, r1
    22a4:	49 f4       	brne	.+18     	; 0x22b8 <__stack+0xb9>
				messageCounter = 0;
    22a6:	10 92 53 1a 	sts	0x1A53, r1	; 0x801a53 <messageCounter.3488+0x1>
    22aa:	10 92 52 1a 	sts	0x1A52, r1	; 0x801a52 <messageCounter.3488>
				
				float yAccl = fIMU_readFloatAccelY();
    22ae:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <fIMU_readFloatAccelY>
				float zGyro = fIMU_readFloatGyroX();
    22b2:	0e 94 91 05 	call	0xb22	; 0xb22 <fIMU_readFloatGyroX>
    22b6:	05 c0       	rjmp	.+10     	; 0x22c2 <__stack+0xc3>
				//printf("R: %i L:  %i\n",rightOutput,leftOutput);
				//printf("%i %i \n",tmp_leftWheelTicks,tmp_rightWheelTicks);
			}
			
			else{
				messageCounter = messageCounter + 1;
    22b8:	01 96       	adiw	r24, 0x01	; 1
    22ba:	90 93 53 1a 	sts	0x1A53, r25	; 0x801a53 <messageCounter.3488+0x1>
    22be:	80 93 52 1a 	sts	0x1A52, r24	; 0x801a52 <messageCounter.3488>
    22c2:	68 89       	ldd	r22, Y+16	; 0x10
    22c4:	79 89       	ldd	r23, Y+17	; 0x11
    22c6:	6f 3f       	cpi	r22, 0xFF	; 255
    22c8:	71 05       	cpc	r23, r1
    22ca:	19 f0       	breq	.+6      	; 0x22d2 <__stack+0xd3>
    22cc:	14 f0       	brlt	.+4      	; 0x22d2 <__stack+0xd3>
    22ce:	6f ef       	ldi	r22, 0xFF	; 255
    22d0:	7a 2d       	mov	r23, r10
    22d2:	3f ef       	ldi	r19, 0xFF	; 255
    22d4:	c3 16       	cp	r12, r19
    22d6:	d1 04       	cpc	r13, r1
    22d8:	21 f0       	breq	.+8      	; 0x22e2 <__stack+0xe3>
    22da:	1c f0       	brlt	.+6      	; 0x22e2 <__stack+0xe3>
    22dc:	cc 24       	eor	r12, r12
    22de:	ca 94       	dec	r12
    22e0:	da 2c       	mov	r13, r10
    22e2:	a6 01       	movw	r20, r12
    22e4:	dd 20       	and	r13, r13
    22e6:	14 f4       	brge	.+4      	; 0x22ec <__stack+0xed>
    22e8:	40 e0       	ldi	r20, 0x00	; 0
    22ea:	50 e0       	ldi	r21, 0x00	; 0
    22ec:	77 23       	and	r23, r23
    22ee:	14 f4       	brge	.+4      	; 0x22f4 <__stack+0xf5>
    22f0:	60 e0       	ldi	r22, 0x00	; 0
    22f2:	70 e0       	ldi	r23, 0x00	; 0
            // Send values to motor control switch. 
            // Note that both comparing ticks AND using a PI controller is suboptimal and should be changed in further work.
            // Set wheelticks to 0 to disable tickcomparison in function
            tmp_leftWheelTicks = 0;
            tmp_rightWheelTicks = 0;
            vMotorMovementSwitch(movement, leftOutput, rightOutput, tmp_leftWheelTicks, tmp_rightWheelTicks, &gLeftWheelDirection, &gRightWheelDirection); // Remove tmp_ticks if robot oscillates too much 
    22f4:	ce 01       	movw	r24, r28
    22f6:	0b 96       	adiw	r24, 0x0b	; 11
    22f8:	6c 01       	movw	r12, r24
    22fa:	9e 01       	movw	r18, r28
    22fc:	26 5f       	subi	r18, 0xF6	; 246
    22fe:	3f 4f       	sbci	r19, 0xFF	; 255
    2300:	79 01       	movw	r14, r18
    2302:	00 e0       	ldi	r16, 0x00	; 0
    2304:	10 e0       	ldi	r17, 0x00	; 0
    2306:	20 e0       	ldi	r18, 0x00	; 0
    2308:	30 e0       	ldi	r19, 0x00	; 0
    230a:	8a 81       	ldd	r24, Y+2	; 0x02
    230c:	0a d2       	rcall	.+1044   	; 0x2722 <vMotorMovementSwitch>
            
            int8_t leftVelocity = leftEncoderVal - previous_leftEncoderVal;
            previous_leftEncoderVal = tmp_leftWheelTicks;
            
            int8_t rightVelocity = rightEncoderVal - previous_rightEncoderVal;
            previous_rightEncoderVal = rightEncoderVal;
    230e:	db 2c       	mov	r13, r11
    2310:	15 ce       	rjmp	.-982    	; 0x1f3c <vMainMovementTask+0x52>
            tmp_leftWheelTicks = 0;
            tmp_rightWheelTicks = 0;
            vMotorMovementSwitch(movement, leftOutput, rightOutput, tmp_leftWheelTicks, tmp_rightWheelTicks, &gLeftWheelDirection, &gRightWheelDirection); // Remove tmp_ticks if robot oscillates too much 
        }                
        else{ // Not connected, stop & do nothing
            vMotorBrakeLeft();
    2312:	fd d1       	rcall	.+1018   	; 0x270e <vMotorBrakeLeft>
            vMotorBrakeRight();
    2314:	01 d2       	rcall	.+1026   	; 0x2718 <vMotorBrakeRight>
    2316:	12 ce       	rjmp	.-988    	; 0x1f3c <vMainMovementTask+0x52>

00002318 <vApplicationStackOverflowHook>:
}
#endif

/*  In case of stack overflow, disable all interrupts and handle it  */
void vApplicationStackOverflowHook(TaskHandle_t *pxTask, signed char *pcTaskName){
    cli();
    2318:	f8 94       	cli
    /*  Handle overflow */
    #ifdef DEBUG
        vUSART_sendS("Overflow\n");
    231a:	89 eb       	ldi	r24, 0xB9	; 185
    231c:	96 e0       	ldi	r25, 0x06	; 6
    231e:	0e 94 fc 26 	call	0x4df8	; 0x4df8 <vUSART_sendS>
    #endif
    while(1){
        vLED_toggle(ledRED);
    2322:	80 e0       	ldi	r24, 0x00	; 0
    2324:	90 e0       	ldi	r25, 0x00	; 0
    2326:	0e 94 d1 05 	call	0xba2	; 0xba2 <vLED_toggle>
        //ledPORT ^= (1<<ledGREEN) | (1<<ledYELLOW) | (1<<ledRED);
    }// While(1) end
    232a:	fb cf       	rjmp	.-10     	; 0x2322 <vApplicationStackOverflowHook+0xa>

0000232c <main>:
}

/*  Main function   */
int main(void){
    232c:	cf 93       	push	r28
    232e:	df 93       	push	r29
    2330:	cd b7       	in	r28, 0x3d	; 61
    2332:	de b7       	in	r29, 0x3e	; 62
    2334:	28 97       	sbiw	r28, 0x08	; 8
    2336:	0f b6       	in	r0, 0x3f	; 63
    2338:	f8 94       	cli
    233a:	de bf       	out	0x3e, r29	; 62
    233c:	0f be       	out	0x3f, r0	; 63
    233e:	cd bf       	out	0x3d, r28	; 61
    /* Setup - Initialize all settings before tasks  */
    /* Initialize LED, pins defined in LED.h   */
    vLED_init();
    2340:	0e 94 97 05 	call	0xb2e	; 0xb2e <vLED_init>
    vLED_singleHigh(ledRED); // Set red LED on to indicate INIT is ongoing
    2344:	80 e0       	ldi	r24, 0x00	; 0
    2346:	90 e0       	ldi	r25, 0x00	; 0
    2348:	0e 94 9d 05 	call	0xb3a	; 0xb3a <vLED_singleHigh>
    /* Initialize USART driver, NB! baud is dependent on nRF51 dongle */
    vUSART_init();
    234c:	0e 94 da 26 	call	0x4db4	; 0x4db4 <vUSART_init>
    
    // If the MCU resets, the cause can be seen in MCUSR register
    // See page 56 in the data sheet
    #ifdef DEBUG
        vUSART_sendS("Reboot.\nStatus register: 0b");
    2350:	83 ec       	ldi	r24, 0xC3	; 195
    2352:	96 e0       	ldi	r25, 0x06	; 6
    2354:	0e 94 fc 26 	call	0x4df8	; 0x4df8 <vUSART_sendS>
        char printer[8];
        uint8_t reg = MCUSR;
    2358:	84 b7       	in	r24, 0x34	; 52
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    235a:	42 e0       	ldi	r20, 0x02	; 2
    235c:	be 01       	movw	r22, r28
    235e:	6f 5f       	subi	r22, 0xFF	; 255
    2360:	7f 4f       	sbci	r23, 0xFF	; 255
    2362:	90 e0       	ldi	r25, 0x00	; 0
    2364:	0e 94 83 2f 	call	0x5f06	; 0x5f06 <__itoa_ncheck>
        itoa(reg,printer,2);
        vUSART_sendS(printer);
    2368:	ce 01       	movw	r24, r28
    236a:	01 96       	adiw	r24, 0x01	; 1
    236c:	0e 94 fc 26 	call	0x4df8	; 0x4df8 <vUSART_sendS>
        vUSART_sendS("\n");
    2370:	89 e2       	ldi	r24, 0x29	; 41
    2372:	96 e0       	ldi	r25, 0x06	; 6
    2374:	0e 94 fc 26 	call	0x4df8	; 0x4df8 <vUSART_sendS>
        MCUSR = 0; // Reset MCUSR
    2378:	14 be       	out	0x34, r1	; 52
        vUSART_sendS("tictoc!\n");
        tic;
    #endif
    
    /* Initialize servo for sensor tower to zero degrees */
    vServo_init(0);
    237a:	80 e0       	ldi	r24, 0x00	; 0
    237c:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <vServo_init>
    /* Initialize sensors */
    vDistSens_init();
    2380:	0e 94 b1 01 	call	0x362	; 0x362 <vDistSens_init>
    /* Initialize motor controller */
    vMotor_init();
    2384:	6b d1       	rcall	.+726    	; 0x265c <vMotor_init>
    /* Initialize Inertial Measurement Unit (IMU) and SPI  */
    #ifdef DEBUG
        vUSART_sendS("IMU init..\n");
    2386:	8f ed       	ldi	r24, 0xDF	; 223
    2388:	96 e0       	ldi	r25, 0x06	; 6
    238a:	0e 94 fc 26 	call	0x4df8	; 0x4df8 <vUSART_sendS>
    #endif
    sIMU_begin(); 
    238e:	0e 94 89 03 	call	0x712	; 0x712 <sIMU_begin>
   
    /* Initialize compass */
    /* Connected with I2C, if the chip has no power, MCU will lock. */
    #ifdef DEBUG
            vUSART_sendS("Compass init..\n");
    2392:	8b ee       	ldi	r24, 0xEB	; 235
    2394:	96 e0       	ldi	r25, 0x06	; 6
    2396:	0e 94 fc 26 	call	0x4df8	; 0x4df8 <vUSART_sendS>
    #endif
    
    vCOM_init();
    239a:	0e 94 4b 01 	call	0x296	; 0x296 <vCOM_init>
    
    /* Initialize RTOS utilities  */
    movementQ = xQueueCreate(2,sizeof(uint8_t)); // For sending movements to vMainMovementTask
    239e:	40 e0       	ldi	r20, 0x00	; 0
    23a0:	61 e0       	ldi	r22, 0x01	; 1
    23a2:	82 e0       	ldi	r24, 0x02	; 2
    23a4:	22 d4       	rcall	.+2116   	; 0x2bea <xQueueGenericCreate>
    23a6:	90 93 8a 1a 	sts	0x1A8A, r25	; 0x801a8a <movementQ+0x1>
    23aa:	80 93 89 1a 	sts	0x1A89, r24	; 0x801a89 <movementQ>
    poseControllerQ = xQueueCreate(1, sizeof(struct sPolar)); // For setpoints to controller
    23ae:	40 e0       	ldi	r20, 0x00	; 0
    23b0:	66 e0       	ldi	r22, 0x06	; 6
    23b2:	81 e0       	ldi	r24, 0x01	; 1
    23b4:	1a d4       	rcall	.+2100   	; 0x2bea <xQueueGenericCreate>
    23b6:	90 93 88 1a 	sts	0x1A88, r25	; 0x801a88 <poseControllerQ+0x1>
    23ba:	80 93 87 1a 	sts	0x1A87, r24	; 0x801a87 <poseControllerQ>
    scanStatusQ = xQueueCreate(1,sizeof(uint8_t)); // For robot status
    23be:	40 e0       	ldi	r20, 0x00	; 0
    23c0:	61 e0       	ldi	r22, 0x01	; 1
    23c2:	81 e0       	ldi	r24, 0x01	; 1
    23c4:	12 d4       	rcall	.+2084   	; 0x2bea <xQueueGenericCreate>
    23c6:	90 93 86 1a 	sts	0x1A86, r25	; 0x801a86 <scanStatusQ+0x1>
    23ca:	80 93 85 1a 	sts	0x1A85, r24	; 0x801a85 <scanStatusQ>
    actuationQ = xQueueCreate(2,sizeof(uint8_t)); // To send variable actuation to motors
    23ce:	40 e0       	ldi	r20, 0x00	; 0
    23d0:	61 e0       	ldi	r22, 0x01	; 1
    23d2:	82 e0       	ldi	r24, 0x02	; 2
    23d4:	0a d4       	rcall	.+2068   	; 0x2bea <xQueueGenericCreate>
    23d6:	90 93 84 1a 	sts	0x1A84, r25	; 0x801a84 <actuationQ+0x1>
    23da:	80 93 83 1a 	sts	0x1A83, r24	; 0x801a83 <actuationQ>
    
    xPoseMutex = xSemaphoreCreateMutex(); // Global variables for robot pose. Only updated from estimator, accessed from many
    23de:	81 e0       	ldi	r24, 0x01	; 1
    23e0:	56 d4       	rcall	.+2220   	; 0x2c8e <xQueueCreateMutex>
    23e2:	90 93 35 1b 	sts	0x1B35, r25	; 0x801b35 <xPoseMutex+0x1>
    23e6:	80 93 34 1b 	sts	0x1B34, r24	; 0x801b34 <xPoseMutex>
    xUartMutex = xSemaphoreCreateMutex(); // Protected printf with a mutex, may cause fragmented bytes if higher priority task want to print as well
    23ea:	81 e0       	ldi	r24, 0x01	; 1
    23ec:	50 d4       	rcall	.+2208   	; 0x2c8e <xQueueCreateMutex>
    23ee:	90 93 1d 1b 	sts	0x1B1D, r25	; 0x801b1d <xUartMutex+0x1>
    23f2:	80 93 1c 1b 	sts	0x1B1C, r24	; 0x801b1c <xUartMutex>
    xTickMutex = xSemaphoreCreateMutex(); // Global variable to hold robot tick values
    23f6:	81 e0       	ldi	r24, 0x01	; 1
    23f8:	4a d4       	rcall	.+2196   	; 0x2c8e <xQueueCreateMutex>
    23fa:	90 93 1b 1b 	sts	0x1B1B, r25	; 0x801b1b <xTickMutex+0x1>
    23fe:	80 93 1a 1b 	sts	0x1B1A, r24	; 0x801b1a <xTickMutex>
    
    xControllerBSem = xSemaphoreCreateBinary(); // Estimator to Controller synchronization
    2402:	43 e0       	ldi	r20, 0x03	; 3
    2404:	60 e0       	ldi	r22, 0x00	; 0
    2406:	81 e0       	ldi	r24, 0x01	; 1
    2408:	f0 d3       	rcall	.+2016   	; 0x2bea <xQueueGenericCreate>
    240a:	90 93 19 1b 	sts	0x1B19, r25	; 0x801b19 <xControllerBSem+0x1>
    240e:	80 93 18 1b 	sts	0x1B18, r24	; 0x801b18 <xControllerBSem>
    xCommandReadyBSem = xSemaphoreCreateBinary(); // uart ISR to comm task sync
    2412:	43 e0       	ldi	r20, 0x03	; 3
    2414:	60 e0       	ldi	r22, 0x00	; 0
    2416:	81 e0       	ldi	r24, 0x01	; 1
    2418:	e8 d3       	rcall	.+2000   	; 0x2bea <xQueueGenericCreate>
    241a:	90 93 1f 1b 	sts	0x1B1F, r25	; 0x801b1f <xCommandReadyBSem+0x1>
    241e:	80 93 1e 1b 	sts	0x1B1E, r24	; 0x801b1e <xCommandReadyBSem>
    
    // Todo: Check return variable to ensure RTOS utilities were successfully initialized before continue
    xTaskCreate(vMainMovementTask, "Movement", 500, NULL, 4, NULL); // Independent task, uses ticks from ISR
    2422:	a1 2c       	mov	r10, r1
    2424:	b1 2c       	mov	r11, r1
    2426:	c1 2c       	mov	r12, r1
    2428:	d1 2c       	mov	r13, r1
    242a:	e1 2c       	mov	r14, r1
    242c:	f1 2c       	mov	r15, r1
    242e:	04 e0       	ldi	r16, 0x04	; 4
    2430:	20 e0       	ldi	r18, 0x00	; 0
    2432:	30 e0       	ldi	r19, 0x00	; 0
    2434:	44 ef       	ldi	r20, 0xF4	; 244
    2436:	51 e0       	ldi	r21, 0x01	; 1
    2438:	6b ef       	ldi	r22, 0xFB	; 251
    243a:	76 e0       	ldi	r23, 0x06	; 6
    243c:	85 e7       	ldi	r24, 0x75	; 117
    243e:	9f e0       	ldi	r25, 0x0F	; 15
    2440:	0e 94 0f 1d 	call	0x3a1e	; 0x3a1e <xTaskGenericCreate>
    xTaskCreate(vMainCommunicationTask, "Comm", 500, NULL, 3, NULL); // Dependant on ISR from UART, sends instructions to other tasks
    2444:	03 e0       	ldi	r16, 0x03	; 3
    2446:	20 e0       	ldi	r18, 0x00	; 0
    2448:	30 e0       	ldi	r19, 0x00	; 0
    244a:	44 ef       	ldi	r20, 0xF4	; 244
    244c:	51 e0       	ldi	r21, 0x01	; 1
    244e:	64 e0       	ldi	r22, 0x04	; 4
    2450:	77 e0       	ldi	r23, 0x07	; 7
    2452:	88 e7       	ldi	r24, 0x78	; 120
    2454:	96 e0       	ldi	r25, 0x06	; 6
    2456:	0e 94 0f 1d 	call	0x3a1e	; 0x3a1e <xTaskGenericCreate>
    
    #ifndef COMPASS_CALIBRATE // If compass calibration task is running dont use these tasks
        xTaskCreate(vMainPoseControllerTask, "PoseCon", 500, NULL, 2, NULL); // Dependant on estimator, sends instructions to movement task
    245a:	02 e0       	ldi	r16, 0x02	; 2
    245c:	20 e0       	ldi	r18, 0x00	; 0
    245e:	30 e0       	ldi	r19, 0x00	; 0
    2460:	44 ef       	ldi	r20, 0xF4	; 244
    2462:	51 e0       	ldi	r21, 0x01	; 1
    2464:	69 e0       	ldi	r22, 0x09	; 9
    2466:	77 e0       	ldi	r23, 0x07	; 7
    2468:	8f e0       	ldi	r24, 0x0F	; 15
    246a:	99 e0       	ldi	r25, 0x09	; 9
    246c:	0e 94 0f 1d 	call	0x3a1e	; 0x3a1e <xTaskGenericCreate>
        xTaskCreate(vMainPoseEstimatorTask, "PoseEst", 500, NULL, 5, NULL); // Independent task, uses ticks from ISR
    2470:	05 e0       	ldi	r16, 0x05	; 5
    2472:	20 e0       	ldi	r18, 0x00	; 0
    2474:	30 e0       	ldi	r19, 0x00	; 0
    2476:	44 ef       	ldi	r20, 0xF4	; 244
    2478:	51 e0       	ldi	r21, 0x01	; 1
    247a:	61 e1       	ldi	r22, 0x11	; 17
    247c:	77 e0       	ldi	r23, 0x07	; 7
    247e:	88 e9       	ldi	r24, 0x98	; 152
    2480:	9c e0       	ldi	r25, 0x0C	; 12
    2482:	0e 94 0f 1d 	call	0x3a1e	; 0x3a1e <xTaskGenericCreate>
        xTaskCreate(vMainSensorTowerTask,"Tower",500, NULL, 1, NULL); // Independent task, but use pose updates from estimator
    2486:	01 e0       	ldi	r16, 0x01	; 1
    2488:	20 e0       	ldi	r18, 0x00	; 0
    248a:	30 e0       	ldi	r19, 0x00	; 0
    248c:	44 ef       	ldi	r20, 0xF4	; 244
    248e:	51 e0       	ldi	r21, 0x01	; 1
    2490:	69 e1       	ldi	r22, 0x19	; 25
    2492:	77 e0       	ldi	r23, 0x07	; 7
    2494:	80 eb       	ldi	r24, 0xB0	; 176
    2496:	97 e0       	ldi	r25, 0x07	; 7
    2498:	0e 94 0f 1d 	call	0x3a1e	; 0x3a1e <xTaskGenericCreate>
        xTaskCreate(compassTask, "compasscal", 3500, NULL, 3, NULL); // Task used for compass calibration, dependant on communication and movement task
    #endif
    
    

    sei();
    249c:	78 94       	sei
    vLED_singleLow(ledRED);
    249e:	80 e0       	ldi	r24, 0x00	; 0
    24a0:	90 e0       	ldi	r25, 0x00	; 0
    24a2:	0e 94 b7 05 	call	0xb6e	; 0xb6e <vLED_singleLow>
    #ifdef DEBUG
    vUSART_sendS("Starting scheduler ....\n");
    24a6:	8f e1       	ldi	r24, 0x1F	; 31
    24a8:	97 e0       	ldi	r25, 0x07	; 7
    24aa:	0e 94 fc 26 	call	0x4df8	; 0x4df8 <vUSART_sendS>
    #endif
    /*  Start scheduler */
    vTaskStartScheduler();
    24ae:	0e 94 4b 21 	call	0x4296	; 0x4296 <vTaskStartScheduler>

    /*  MCU is out of RAM if the program comes here */
    while(1){
        cli();
    24b2:	f8 94       	cli
        vUSART_sendS("RAM fail\n");
    24b4:	88 e3       	ldi	r24, 0x38	; 56
    24b6:	97 e0       	ldi	r25, 0x07	; 7
    24b8:	0e 94 fc 26 	call	0x4df8	; 0x4df8 <vUSART_sendS>
    }
    24bc:	fa cf       	rjmp	.-12     	; 0x24b2 <main+0x186>

000024be <__vector_4>:

/* Handle tick from left wheel encoder */
// If ticks generate overly many interrupts, you can 
// connect to T0 and T5 pins and set up  hardware timer overflow to 
// prescale the ticks
ISR(leftWheelCount){
    24be:	1f 92       	push	r1
    24c0:	0f 92       	push	r0
    24c2:	0f b6       	in	r0, 0x3f	; 63
    24c4:	0f 92       	push	r0
    24c6:	11 24       	eor	r1, r1
    24c8:	8f 93       	push	r24
    gISR_leftWheelTicks++;
    24ca:	80 91 81 1a 	lds	r24, 0x1A81	; 0x801a81 <gISR_leftWheelTicks>
    24ce:	8f 5f       	subi	r24, 0xFF	; 255
    24d0:	80 93 81 1a 	sts	0x1A81, r24	; 0x801a81 <gISR_leftWheelTicks>
}
    24d4:	8f 91       	pop	r24
    24d6:	0f 90       	pop	r0
    24d8:	0f be       	out	0x3f, r0	; 63
    24da:	0f 90       	pop	r0
    24dc:	1f 90       	pop	r1
    24de:	18 95       	reti

000024e0 <__vector_3>:

/* Handle tick from right wheel encoder */
ISR(rightWheelCount){
    24e0:	1f 92       	push	r1
    24e2:	0f 92       	push	r0
    24e4:	0f b6       	in	r0, 0x3f	; 63
    24e6:	0f 92       	push	r0
    24e8:	11 24       	eor	r1, r1
    24ea:	8f 93       	push	r24
    gISR_rightWheelTicks++;
    24ec:	80 91 82 1a 	lds	r24, 0x1A82	; 0x801a82 <gISR_rightWheelTicks>
    24f0:	8f 5f       	subi	r24, 0xFF	; 255
    24f2:	80 93 82 1a 	sts	0x1A82, r24	; 0x801a82 <gISR_rightWheelTicks>
}
    24f6:	8f 91       	pop	r24
    24f8:	0f 90       	pop	r0
    24fa:	0f be       	out	0x3f, r0	; 63
    24fc:	0f 90       	pop	r0
    24fe:	1f 90       	pop	r1
    2500:	18 95       	reti

00002502 <__vector_5>:

/* Handle change of connection status */
ISR(nRF51_status){
    2502:	1f 92       	push	r1
    2504:	0f 92       	push	r0
    2506:	0f b6       	in	r0, 0x3f	; 63
    2508:	0f 92       	push	r0
    250a:	11 24       	eor	r1, r1
    250c:	0b b6       	in	r0, 0x3b	; 59
    250e:	0f 92       	push	r0
    2510:	2f 93       	push	r18
    2512:	3f 93       	push	r19
    2514:	4f 93       	push	r20
    2516:	5f 93       	push	r21
    2518:	6f 93       	push	r22
    251a:	7f 93       	push	r23
    251c:	8f 93       	push	r24
    251e:	9f 93       	push	r25
    2520:	af 93       	push	r26
    2522:	bf 93       	push	r27
    2524:	ef 93       	push	r30
    2526:	ff 93       	push	r31
    if (nRFconnected){
    2528:	64 99       	sbic	0x0c, 4	; 12
    252a:	09 c0       	rjmp	.+18     	; 0x253e <__vector_5+0x3c>
        // indicate we are connected
        vLED_singleHigh(ledGREEN);
    252c:	82 e0       	ldi	r24, 0x02	; 2
    252e:	90 e0       	ldi	r25, 0x00	; 0
    2530:	0e 94 9d 05 	call	0xb3a	; 0xb3a <vLED_singleHigh>
        vLED_singleHigh(ledYELLOW);
    2534:	81 e0       	ldi	r24, 0x01	; 1
    2536:	90 e0       	ldi	r25, 0x00	; 0
    2538:	0e 94 9d 05 	call	0xb3a	; 0xb3a <vLED_singleHigh>
    253c:	18 c0       	rjmp	.+48     	; 0x256e <__vector_5+0x6c>
    }
    else{
        // We are not connected or lost connection, reset handshake flag
        gHandshook = FALSE;
    253e:	10 92 80 1a 	sts	0x1A80, r1	; 0x801a80 <gHandshook>
        gPaused = FALSE;
    2542:	10 92 7f 1a 	sts	0x1A7F, r1	; 0x801a7f <gPaused>
        vLED_singleLow(ledGREEN);
    2546:	82 e0       	ldi	r24, 0x02	; 2
    2548:	90 e0       	ldi	r25, 0x00	; 0
    254a:	0e 94 b7 05 	call	0xb6e	; 0xb6e <vLED_singleLow>
        vLED_singleLow(ledYELLOW);
    254e:	81 e0       	ldi	r24, 0x01	; 1
    2550:	90 e0       	ldi	r25, 0x00	; 0
    2552:	0e 94 b7 05 	call	0xb6e	; 0xb6e <vLED_singleLow>
        vLED_singleLow(ledRED);
    2556:	80 e0       	ldi	r24, 0x00	; 0
    2558:	90 e0       	ldi	r25, 0x00	; 0
    255a:	0e 94 b7 05 	call	0xb6e	; 0xb6e <vLED_singleLow>
        xSemaphoreGiveFromISR(xCommandReadyBSem,0); // Let uart parser reset if needed
    255e:	60 e0       	ldi	r22, 0x00	; 0
    2560:	70 e0       	ldi	r23, 0x00	; 0
    2562:	80 91 1e 1b 	lds	r24, 0x1B1E	; 0x801b1e <xCommandReadyBSem>
    2566:	90 91 1f 1b 	lds	r25, 0x1B1F	; 0x801b1f <xCommandReadyBSem+0x1>
    256a:	0e 94 09 1b 	call	0x3612	; 0x3612 <xQueueGiveFromISR>
    }
    xSemaphoreGiveFromISR(xControllerBSem,0); // let the controller reset if needed    
    256e:	60 e0       	ldi	r22, 0x00	; 0
    2570:	70 e0       	ldi	r23, 0x00	; 0
    2572:	80 91 18 1b 	lds	r24, 0x1B18	; 0x801b18 <xControllerBSem>
    2576:	90 91 19 1b 	lds	r25, 0x1B19	; 0x801b19 <xControllerBSem+0x1>
    257a:	0e 94 09 1b 	call	0x3612	; 0x3612 <xQueueGiveFromISR>
}
    257e:	ff 91       	pop	r31
    2580:	ef 91       	pop	r30
    2582:	bf 91       	pop	r27
    2584:	af 91       	pop	r26
    2586:	9f 91       	pop	r25
    2588:	8f 91       	pop	r24
    258a:	7f 91       	pop	r23
    258c:	6f 91       	pop	r22
    258e:	5f 91       	pop	r21
    2590:	4f 91       	pop	r20
    2592:	3f 91       	pop	r19
    2594:	2f 91       	pop	r18
    2596:	0f 90       	pop	r0
    2598:	0b be       	out	0x3b, r0	; 59
    259a:	0f 90       	pop	r0
    259c:	0f be       	out	0x3f, r0	; 63
    259e:	0f 90       	pop	r0
    25a0:	1f 90       	pop	r1
    25a2:	18 95       	reti

000025a4 <__vector_51>:

/* Handle rx complete */
ISR(USART2_RX_vect){
    25a4:	1f 92       	push	r1
    25a6:	0f 92       	push	r0
    25a8:	0f b6       	in	r0, 0x3f	; 63
    25aa:	0f 92       	push	r0
    25ac:	11 24       	eor	r1, r1
    25ae:	0b b6       	in	r0, 0x3b	; 59
    25b0:	0f 92       	push	r0
    25b2:	2f 93       	push	r18
    25b4:	3f 93       	push	r19
    25b6:	4f 93       	push	r20
    25b8:	5f 93       	push	r21
    25ba:	6f 93       	push	r22
    25bc:	7f 93       	push	r23
    25be:	8f 93       	push	r24
    25c0:	9f 93       	push	r25
    25c2:	af 93       	push	r26
    25c4:	bf 93       	push	r27
    25c6:	ef 93       	push	r30
    25c8:	ff 93       	push	r31
    // Receive buffer
    gData_in[gData_count] = UDR2;
    25ca:	e0 91 17 1b 	lds	r30, 0x1B17	; 0x801b17 <gData_count>
    25ce:	f0 e0       	ldi	r31, 0x00	; 0
    25d0:	80 91 d6 00 	lds	r24, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    25d4:	e0 5e       	subi	r30, 0xE0	; 224
    25d6:	f4 4e       	sbci	r31, 0xE4	; 228
    25d8:	80 83       	st	Z, r24
    // All messages start with a {, so if we don't get an {, ignore the message
    if (gData_in[gData_count] == '{'){
    25da:	e0 91 17 1b 	lds	r30, 0x1B17	; 0x801b17 <gData_count>
    25de:	f0 e0       	ldi	r31, 0x00	; 0
    25e0:	e0 5e       	subi	r30, 0xE0	; 224
    25e2:	f4 4e       	sbci	r31, 0xE4	; 228
    25e4:	80 81       	ld	r24, Z
    25e6:	8b 37       	cpi	r24, 0x7B	; 123
    25e8:	29 f4       	brne	.+10     	; 0x25f4 <__vector_51+0x50>
        // Initialize data counter
        gData_count = 0;
    25ea:	10 92 17 1b 	sts	0x1B17, r1	; 0x801b17 <gData_count>
        gStoreString = TRUE;
    25ee:	81 e0       	ldi	r24, 0x01	; 1
    25f0:	80 93 7e 1a 	sts	0x1A7E, r24	; 0x801a7e <gStoreString>
    }
    if (gStoreString){
    25f4:	80 91 7e 1a 	lds	r24, 0x1A7E	; 0x801a7e <gStoreString>
    25f8:	88 23       	and	r24, r24
    25fa:	e9 f0       	breq	.+58     	; 0x2636 <__vector_51+0x92>
        // Check for end of line, or if the message is too long parse it anyways
        if (gData_in[gData_count] == '\n' || gData_count >= sizeof(gData_in)){
    25fc:	e0 91 17 1b 	lds	r30, 0x1B17	; 0x801b17 <gData_count>
    2600:	f0 e0       	ldi	r31, 0x00	; 0
    2602:	e0 5e       	subi	r30, 0xE0	; 224
    2604:	f4 4e       	sbci	r31, 0xE4	; 228
    2606:	80 81       	ld	r24, Z
    2608:	8a 30       	cpi	r24, 0x0A	; 10
    260a:	21 f0       	breq	.+8      	; 0x2614 <__vector_51+0x70>
    260c:	80 91 17 1b 	lds	r24, 0x1B17	; 0x801b17 <gData_count>
    2610:	84 31       	cpi	r24, 0x14	; 20
    2612:	60 f0       	brcs	.+24     	; 0x262c <__vector_51+0x88>
            xSemaphoreGiveFromISR(xCommandReadyBSem,0);
    2614:	60 e0       	ldi	r22, 0x00	; 0
    2616:	70 e0       	ldi	r23, 0x00	; 0
    2618:	80 91 1e 1b 	lds	r24, 0x1B1E	; 0x801b1e <xCommandReadyBSem>
    261c:	90 91 1f 1b 	lds	r25, 0x1B1F	; 0x801b1f <xCommandReadyBSem+0x1>
    2620:	f8 d7       	rcall	.+4080   	; 0x3612 <xQueueGiveFromISR>
            // Reset to 0, ready to go again
            gData_count = 0;
    2622:	10 92 17 1b 	sts	0x1B17, r1	; 0x801b17 <gData_count>
            gStoreString = FALSE;
    2626:	10 92 7e 1a 	sts	0x1A7E, r1	; 0x801a7e <gStoreString>
    262a:	05 c0       	rjmp	.+10     	; 0x2636 <__vector_51+0x92>
        }
        else{
            gData_count++;
    262c:	80 91 17 1b 	lds	r24, 0x1B17	; 0x801b17 <gData_count>
    2630:	8f 5f       	subi	r24, 0xFF	; 255
    2632:	80 93 17 1b 	sts	0x1B17, r24	; 0x801b17 <gData_count>
        }
    }
    2636:	ff 91       	pop	r31
    2638:	ef 91       	pop	r30
    263a:	bf 91       	pop	r27
    263c:	af 91       	pop	r26
    263e:	9f 91       	pop	r25
    2640:	8f 91       	pop	r24
    2642:	7f 91       	pop	r23
    2644:	6f 91       	pop	r22
    2646:	5f 91       	pop	r21
    2648:	4f 91       	pop	r20
    264a:	3f 91       	pop	r19
    264c:	2f 91       	pop	r18
    264e:	0f 90       	pop	r0
    2650:	0b be       	out	0x3b, r0	; 59
    2652:	0f 90       	pop	r0
    2654:	0f be       	out	0x3f, r0	; 63
    2656:	0f 90       	pop	r0
    2658:	1f 90       	pop	r1
    265a:	18 95       	reti

0000265c <vMotor_init>:

void vMotorGlideRight(){
    motorRightPWM = 0;
    //PORTH &= ~(1<<motorRightOn);
    PORTA &= ~(1<<motorRightForward);
    PORTA &= ~(1<<motorRightBackward);
    265c:	87 b1       	in	r24, 0x07	; 7
    265e:	80 6a       	ori	r24, 0xA0	; 160
    2660:	87 b9       	out	0x07, r24	; 7
    2662:	e1 e0       	ldi	r30, 0x01	; 1
    2664:	f1 e0       	ldi	r31, 0x01	; 1
    2666:	80 81       	ld	r24, Z
    2668:	80 68       	ori	r24, 0x80	; 128
    266a:	80 83       	st	Z, r24
    266c:	81 b1       	in	r24, 0x01	; 1
    266e:	84 61       	ori	r24, 0x14	; 20
    2670:	81 b9       	out	0x01, r24	; 1
    2672:	6d 9a       	sbi	0x0d, 5	; 13
    2674:	e2 e0       	ldi	r30, 0x02	; 2
    2676:	f1 e0       	ldi	r31, 0x01	; 1
    2678:	80 81       	ld	r24, Z
    267a:	8f 7d       	andi	r24, 0xDF	; 223
    267c:	80 83       	st	Z, r24
    267e:	77 98       	cbi	0x0e, 7	; 14
    2680:	82 b1       	in	r24, 0x02	; 2
    2682:	8b 7e       	andi	r24, 0xEB	; 235
    2684:	82 b9       	out	0x02, r24	; 2
    2686:	88 b1       	in	r24, 0x08	; 8
    2688:	8f 75       	andi	r24, 0x5F	; 95
    268a:	88 b9       	out	0x08, r24	; 8
    268c:	8a b1       	in	r24, 0x0a	; 10
    268e:	8a b9       	out	0x0a, r24	; 10
    2690:	8b b1       	in	r24, 0x0b	; 11
    2692:	8c 60       	ori	r24, 0x0C	; 12
    2694:	8b b9       	out	0x0b, r24	; 11
    2696:	6c 98       	cbi	0x0d, 4	; 13
    2698:	8d b3       	in	r24, 0x1d	; 29
    269a:	8d bb       	out	0x1d, r24	; 29
    269c:	e9 e6       	ldi	r30, 0x69	; 105
    269e:	f0 e0       	ldi	r31, 0x00	; 0
    26a0:	80 81       	ld	r24, Z
    26a2:	80 6f       	ori	r24, 0xF0	; 240
    26a4:	80 83       	st	Z, r24
    26a6:	ea e6       	ldi	r30, 0x6A	; 106
    26a8:	f0 e0       	ldi	r31, 0x00	; 0
    26aa:	80 81       	ld	r24, Z
    26ac:	81 60       	ori	r24, 0x01	; 1
    26ae:	80 83       	st	Z, r24
    26b0:	8c e1       	ldi	r24, 0x1C	; 28
    26b2:	8c bb       	out	0x1c, r24	; 28
    26b4:	8d b3       	in	r24, 0x1d	; 29
    26b6:	8c 61       	ori	r24, 0x1C	; 28
    26b8:	8d bb       	out	0x1d, r24	; 29
    26ba:	84 b5       	in	r24, 0x24	; 36
    26bc:	80 6a       	ori	r24, 0xA0	; 160
    26be:	84 bd       	out	0x24, r24	; 36
    26c0:	84 b5       	in	r24, 0x24	; 36
    26c2:	83 60       	ori	r24, 0x03	; 3
    26c4:	84 bd       	out	0x24, r24	; 36
    26c6:	85 b5       	in	r24, 0x25	; 37
    26c8:	85 bd       	out	0x25, r24	; 37
    26ca:	85 b5       	in	r24, 0x25	; 37
    26cc:	85 60       	ori	r24, 0x05	; 5
    26ce:	85 bd       	out	0x25, r24	; 37
    26d0:	27 9a       	sbi	0x04, 7	; 4
    26d2:	9d 9a       	sbi	0x13, 5	; 19
    26d4:	08 95       	ret

000026d6 <vMotorMoveLeftForward>:
    26d6:	88 bd       	out	0x28, r24	; 40
    26d8:	45 9a       	sbi	0x08, 5	; 8
    26da:	47 98       	cbi	0x08, 7	; 8
    26dc:	85 e0       	ldi	r24, 0x05	; 5
    26de:	fb 01       	movw	r30, r22
    26e0:	80 83       	st	Z, r24
    26e2:	08 95       	ret

000026e4 <vMotorMoveRightForward>:
    26e4:	87 bd       	out	0x27, r24	; 39
    26e6:	12 9a       	sbi	0x02, 2	; 2
    26e8:	14 98       	cbi	0x02, 4	; 2
    26ea:	82 e0       	ldi	r24, 0x02	; 2
    26ec:	fb 01       	movw	r30, r22
    26ee:	80 83       	st	Z, r24
    26f0:	08 95       	ret

000026f2 <vMotorMoveLeftBackward>:
    26f2:	88 bd       	out	0x28, r24	; 40
    26f4:	45 98       	cbi	0x08, 5	; 8
    26f6:	47 9a       	sbi	0x08, 7	; 8
    26f8:	87 e0       	ldi	r24, 0x07	; 7
    26fa:	fb 01       	movw	r30, r22
    26fc:	80 83       	st	Z, r24
    26fe:	08 95       	ret

00002700 <vMotorMoveRightBackward>:
    2700:	87 bd       	out	0x27, r24	; 39
    2702:	12 98       	cbi	0x02, 2	; 2
    2704:	14 9a       	sbi	0x02, 4	; 2
    2706:	84 e0       	ldi	r24, 0x04	; 4
    2708:	fb 01       	movw	r30, r22
    270a:	80 83       	st	Z, r24
    270c:	08 95       	ret

0000270e <vMotorBrakeLeft>:
    270e:	8f ef       	ldi	r24, 0xFF	; 255
    2710:	88 bd       	out	0x28, r24	; 40
    2712:	45 98       	cbi	0x08, 5	; 8
    2714:	47 98       	cbi	0x08, 7	; 8
    2716:	08 95       	ret

00002718 <vMotorBrakeRight>:
    2718:	8f ef       	ldi	r24, 0xFF	; 255
    271a:	87 bd       	out	0x27, r24	; 39
    271c:	12 98       	cbi	0x02, 2	; 2
    271e:	14 98       	cbi	0x02, 4	; 2
    2720:	08 95       	ret

00002722 <vMotorMovementSwitch>:
}

/* Switch for robot movement to abstract the logic away from main */
/* Comparing ticks ensures balanced movement */
void vMotorMovementSwitch(uint8_t movement, int16_t leftOutput, int16_t rightOutput, int16_t tmp_leftWheelTicks, int16_t tmp_rightWheelTicks, uint8_t *leftWheelDirection, uint8_t *rightWheelDirection){
    2722:	8f 92       	push	r8
    2724:	9f 92       	push	r9
    2726:	af 92       	push	r10
    2728:	bf 92       	push	r11
    272a:	cf 92       	push	r12
    272c:	df 92       	push	r13
    272e:	ef 92       	push	r14
    2730:	ff 92       	push	r15
    2732:	0f 93       	push	r16
    2734:	1f 93       	push	r17
    2736:	cf 93       	push	r28
    2738:	df 93       	push	r29
    273a:	c6 2f       	mov	r28, r22
    273c:	d4 2f       	mov	r29, r20
    switch (movement){
    273e:	88 2e       	mov	r8, r24
    2740:	91 2c       	mov	r9, r1
    2742:	f4 01       	movw	r30, r8
    2744:	31 97       	sbiw	r30, 0x01	; 1
    2746:	e8 30       	cpi	r30, 0x08	; 8
    2748:	f1 05       	cpc	r31, r1
    274a:	08 f0       	brcs	.+2      	; 0x274e <vMotorMovementSwitch+0x2c>
    274c:	7c c0       	rjmp	.+248    	; 0x2846 <vMotorMovementSwitch+0x124>
    274e:	88 27       	eor	r24, r24
    2750:	ee 58       	subi	r30, 0x8E	; 142
    2752:	ff 4f       	sbci	r31, 0xFF	; 255
    2754:	8f 4f       	sbci	r24, 0xFF	; 255
    2756:	0c 94 00 2e 	jmp	0x5c00	; 0x5c00 <__tablejump2__>
        case moveForward:{
            if (tmp_leftWheelTicks > tmp_rightWheelTicks){
    275a:	02 17       	cp	r16, r18
    275c:	13 07       	cpc	r17, r19
    275e:	2c f4       	brge	.+10     	; 0x276a <vMotorMovementSwitch+0x48>
                vMotorBrakeLeft();
    2760:	d6 df       	rcall	.-84     	; 0x270e <vMotorBrakeLeft>
                vMotorMoveRightForward(rightOutput, rightWheelDirection);
    2762:	b6 01       	movw	r22, r12
    2764:	8d 2f       	mov	r24, r29
    2766:	be df       	rcall	.-132    	; 0x26e4 <vMotorMoveRightForward>
    2768:	70 c0       	rjmp	.+224    	; 0x284a <vMotorMovementSwitch+0x128>
            }
            else if (tmp_rightWheelTicks > tmp_leftWheelTicks){
    276a:	20 17       	cp	r18, r16
    276c:	31 07       	cpc	r19, r17
    276e:	2c f4       	brge	.+10     	; 0x277a <vMotorMovementSwitch+0x58>
                vMotorBrakeRight();
    2770:	d3 df       	rcall	.-90     	; 0x2718 <vMotorBrakeRight>
                vMotorMoveLeftForward(leftOutput, leftWheelDirection);
    2772:	b7 01       	movw	r22, r14
    2774:	8c 2f       	mov	r24, r28
    2776:	af df       	rcall	.-162    	; 0x26d6 <vMotorMoveLeftForward>
    2778:	68 c0       	rjmp	.+208    	; 0x284a <vMotorMovementSwitch+0x128>
            }
            else{
                vMotorMoveLeftForward(leftOutput, leftWheelDirection);
    277a:	b7 01       	movw	r22, r14
    277c:	8c 2f       	mov	r24, r28
    277e:	ab df       	rcall	.-170    	; 0x26d6 <vMotorMoveLeftForward>
                vMotorMoveRightForward(rightOutput, rightWheelDirection);
    2780:	b6 01       	movw	r22, r12
    2782:	8d 2f       	mov	r24, r29
    2784:	af df       	rcall	.-162    	; 0x26e4 <vMotorMoveRightForward>
    2786:	61 c0       	rjmp	.+194    	; 0x284a <vMotorMovementSwitch+0x128>
            }                
            break;
        }
        case moveBackward:{
                if (tmp_leftWheelTicks < tmp_rightWheelTicks){
    2788:	20 17       	cp	r18, r16
    278a:	31 07       	cpc	r19, r17
    278c:	2c f4       	brge	.+10     	; 0x2798 <vMotorMovementSwitch+0x76>
                    vMotorBrakeLeft();
    278e:	bf df       	rcall	.-130    	; 0x270e <vMotorBrakeLeft>
                    vMotorMoveRightBackward(rightOutput, rightWheelDirection);
    2790:	b6 01       	movw	r22, r12
    2792:	8d 2f       	mov	r24, r29
    2794:	b5 df       	rcall	.-150    	; 0x2700 <vMotorMoveRightBackward>
    2796:	59 c0       	rjmp	.+178    	; 0x284a <vMotorMovementSwitch+0x128>
                }
                else if (tmp_rightWheelTicks < tmp_leftWheelTicks){
    2798:	02 17       	cp	r16, r18
    279a:	13 07       	cpc	r17, r19
    279c:	2c f4       	brge	.+10     	; 0x27a8 <vMotorMovementSwitch+0x86>
                    vMotorBrakeRight();
    279e:	bc df       	rcall	.-136    	; 0x2718 <vMotorBrakeRight>
                    vMotorMoveLeftBackward(leftOutput, leftWheelDirection);
    27a0:	b7 01       	movw	r22, r14
    27a2:	8c 2f       	mov	r24, r28
    27a4:	a6 df       	rcall	.-180    	; 0x26f2 <vMotorMoveLeftBackward>
    27a6:	51 c0       	rjmp	.+162    	; 0x284a <vMotorMovementSwitch+0x128>
                }
                else{
                vMotorMoveLeftBackward(leftOutput, leftWheelDirection);
    27a8:	b7 01       	movw	r22, r14
    27aa:	8c 2f       	mov	r24, r28
    27ac:	a2 df       	rcall	.-188    	; 0x26f2 <vMotorMoveLeftBackward>
                vMotorMoveRightBackward(rightOutput, rightWheelDirection);
    27ae:	b6 01       	movw	r22, r12
    27b0:	8d 2f       	mov	r24, r29
    27b2:	a6 df       	rcall	.-180    	; 0x2700 <vMotorMoveRightBackward>
    27b4:	4a c0       	rjmp	.+148    	; 0x284a <vMotorMovementSwitch+0x128>
                }                
            break;
        }
        case moveClockwise:{
            if(-tmp_rightWheelTicks > tmp_leftWheelTicks){
    27b6:	11 95       	neg	r17
    27b8:	01 95       	neg	r16
    27ba:	11 09       	sbc	r17, r1
    27bc:	20 17       	cp	r18, r16
    27be:	31 07       	cpc	r19, r17
    27c0:	2c f4       	brge	.+10     	; 0x27cc <vMotorMovementSwitch+0xaa>
                vMotorBrakeRight();
    27c2:	aa df       	rcall	.-172    	; 0x2718 <vMotorBrakeRight>
                vMotorMoveLeftForward(leftOutput, leftWheelDirection);
    27c4:	b7 01       	movw	r22, r14
    27c6:	8c 2f       	mov	r24, r28
    27c8:	86 df       	rcall	.-244    	; 0x26d6 <vMotorMoveLeftForward>
    27ca:	3f c0       	rjmp	.+126    	; 0x284a <vMotorMovementSwitch+0x128>
            }
            else if (tmp_leftWheelTicks > -tmp_rightWheelTicks){
    27cc:	02 17       	cp	r16, r18
    27ce:	13 07       	cpc	r17, r19
    27d0:	2c f4       	brge	.+10     	; 0x27dc <vMotorMovementSwitch+0xba>
                vMotorBrakeLeft();
    27d2:	9d df       	rcall	.-198    	; 0x270e <vMotorBrakeLeft>
                vMotorMoveRightBackward(rightOutput, rightWheelDirection);
    27d4:	b6 01       	movw	r22, r12
    27d6:	8d 2f       	mov	r24, r29
    27d8:	93 df       	rcall	.-218    	; 0x2700 <vMotorMoveRightBackward>
    27da:	37 c0       	rjmp	.+110    	; 0x284a <vMotorMovementSwitch+0x128>
            }
            else{
                vMotorMoveLeftForward(leftOutput, leftWheelDirection);
    27dc:	b7 01       	movw	r22, r14
    27de:	8c 2f       	mov	r24, r28
    27e0:	7a df       	rcall	.-268    	; 0x26d6 <vMotorMoveLeftForward>
                vMotorMoveRightBackward(rightOutput, rightWheelDirection);
    27e2:	b6 01       	movw	r22, r12
    27e4:	8d 2f       	mov	r24, r29
    27e6:	8c df       	rcall	.-232    	; 0x2700 <vMotorMoveRightBackward>
    27e8:	30 c0       	rjmp	.+96     	; 0x284a <vMotorMovementSwitch+0x128>
            }                
            break;
        }
        case moveCounterClockwise:{
            if(-tmp_leftWheelTicks > tmp_rightWheelTicks){
    27ea:	31 95       	neg	r19
    27ec:	21 95       	neg	r18
    27ee:	31 09       	sbc	r19, r1
    27f0:	02 17       	cp	r16, r18
    27f2:	13 07       	cpc	r17, r19
    27f4:	2c f4       	brge	.+10     	; 0x2800 <vMotorMovementSwitch+0xde>
                vMotorBrakeLeft();
    27f6:	8b df       	rcall	.-234    	; 0x270e <vMotorBrakeLeft>
                vMotorMoveRightForward(rightOutput, rightWheelDirection);
    27f8:	b6 01       	movw	r22, r12
    27fa:	8d 2f       	mov	r24, r29
    27fc:	73 df       	rcall	.-282    	; 0x26e4 <vMotorMoveRightForward>
    27fe:	25 c0       	rjmp	.+74     	; 0x284a <vMotorMovementSwitch+0x128>
            }
            else if (tmp_rightWheelTicks > -tmp_leftWheelTicks){
    2800:	20 17       	cp	r18, r16
    2802:	31 07       	cpc	r19, r17
    2804:	2c f4       	brge	.+10     	; 0x2810 <vMotorMovementSwitch+0xee>
                vMotorBrakeRight();
    2806:	88 df       	rcall	.-240    	; 0x2718 <vMotorBrakeRight>
                vMotorMoveLeftBackward(leftOutput, leftWheelDirection);
    2808:	b7 01       	movw	r22, r14
    280a:	8c 2f       	mov	r24, r28
    280c:	72 df       	rcall	.-284    	; 0x26f2 <vMotorMoveLeftBackward>
    280e:	1d c0       	rjmp	.+58     	; 0x284a <vMotorMovementSwitch+0x128>
            }
            else {
                vMotorMoveLeftBackward(leftOutput, leftWheelDirection);
    2810:	b7 01       	movw	r22, r14
    2812:	8c 2f       	mov	r24, r28
    2814:	6e df       	rcall	.-292    	; 0x26f2 <vMotorMoveLeftBackward>
                vMotorMoveRightForward(rightOutput, rightWheelDirection);
    2816:	b6 01       	movw	r22, r12
    2818:	8d 2f       	mov	r24, r29
    281a:	64 df       	rcall	.-312    	; 0x26e4 <vMotorMoveRightForward>
    281c:	16 c0       	rjmp	.+44     	; 0x284a <vMotorMovementSwitch+0x128>
            }                
            break;
        }
        case moveRightForward:{
            vMotorMoveRightForward(rightOutput, rightWheelDirection);
    281e:	b6 01       	movw	r22, r12
    2820:	84 2f       	mov	r24, r20
    2822:	60 df       	rcall	.-320    	; 0x26e4 <vMotorMoveRightForward>
            vMotorBrakeLeft();
    2824:	74 df       	rcall	.-280    	; 0x270e <vMotorBrakeLeft>
            break;
    2826:	11 c0       	rjmp	.+34     	; 0x284a <vMotorMovementSwitch+0x128>
        }
        case moveLeftForward:{
            vMotorMoveLeftForward(leftOutput, leftWheelDirection);
    2828:	b7 01       	movw	r22, r14
    282a:	8c 2f       	mov	r24, r28
    282c:	54 df       	rcall	.-344    	; 0x26d6 <vMotorMoveLeftForward>
            vMotorBrakeRight();
    282e:	74 df       	rcall	.-280    	; 0x2718 <vMotorBrakeRight>
            break;
    2830:	0c c0       	rjmp	.+24     	; 0x284a <vMotorMovementSwitch+0x128>
        }
        case moveRightBackward:{
            vMotorMoveRightBackward(rightOutput, rightWheelDirection);
    2832:	b6 01       	movw	r22, r12
    2834:	84 2f       	mov	r24, r20
    2836:	64 df       	rcall	.-312    	; 0x2700 <vMotorMoveRightBackward>
            vMotorBrakeLeft();
    2838:	6a df       	rcall	.-300    	; 0x270e <vMotorBrakeLeft>
            break;
    283a:	07 c0       	rjmp	.+14     	; 0x284a <vMotorMovementSwitch+0x128>
        }
        case moveLeftBackward:{
            vMotorMoveLeftBackward(leftOutput, leftWheelDirection);
    283c:	b7 01       	movw	r22, r14
    283e:	8c 2f       	mov	r24, r28
    2840:	58 df       	rcall	.-336    	; 0x26f2 <vMotorMoveLeftBackward>
            vMotorBrakeRight();
    2842:	6a df       	rcall	.-300    	; 0x2718 <vMotorBrakeRight>
            break;
    2844:	02 c0       	rjmp	.+4      	; 0x284a <vMotorMovementSwitch+0x128>
        }
        default:{
            vMotorBrakeLeft();
    2846:	63 df       	rcall	.-314    	; 0x270e <vMotorBrakeLeft>
            vMotorBrakeRight();
    2848:	67 df       	rcall	.-306    	; 0x2718 <vMotorBrakeRight>
            break;
        }
        
    }

}
    284a:	df 91       	pop	r29
    284c:	cf 91       	pop	r28
    284e:	1f 91       	pop	r17
    2850:	0f 91       	pop	r16
    2852:	ff 90       	pop	r15
    2854:	ef 90       	pop	r14
    2856:	df 90       	pop	r13
    2858:	cf 90       	pop	r12
    285a:	bf 90       	pop	r11
    285c:	af 90       	pop	r10
    285e:	9f 90       	pop	r9
    2860:	8f 90       	pop	r8
    2862:	08 95       	ret

00002864 <vMotorEncoderLeftTickFromISR>:

/* Handle ISR ticks from encoder, Please note that we are losing accuracy here due to division */
void vMotorEncoderLeftTickFromISR(uint8_t wheelDirection, int16_t *leftWheelTicks, uint8_t leftEncoderTicks){
    switch (wheelDirection){
    2864:	85 30       	cpi	r24, 0x05	; 5
    2866:	19 f0       	breq	.+6      	; 0x286e <vMotorEncoderLeftTickFromISR+0xa>
    2868:	87 30       	cpi	r24, 0x07	; 7
    286a:	51 f0       	breq	.+20     	; 0x2880 <vMotorEncoderLeftTickFromISR+0x1c>
    286c:	08 95       	ret
        case motorLeftForward:{
            *leftWheelTicks += leftEncoderTicks / 2;
    286e:	46 95       	lsr	r20
    2870:	fb 01       	movw	r30, r22
    2872:	80 81       	ld	r24, Z
    2874:	91 81       	ldd	r25, Z+1	; 0x01
    2876:	84 0f       	add	r24, r20
    2878:	91 1d       	adc	r25, r1
    287a:	91 83       	std	Z+1, r25	; 0x01
    287c:	80 83       	st	Z, r24
            break;
    287e:	08 95       	ret
        }
        case  motorLeftBackward:{
            *leftWheelTicks -= leftEncoderTicks / 2;
    2880:	46 95       	lsr	r20
    2882:	fb 01       	movw	r30, r22
    2884:	80 81       	ld	r24, Z
    2886:	91 81       	ldd	r25, Z+1	; 0x01
    2888:	84 1b       	sub	r24, r20
    288a:	91 09       	sbc	r25, r1
    288c:	91 83       	std	Z+1, r25	; 0x01
    288e:	80 83       	st	Z, r24
    2890:	08 95       	ret

00002892 <vMotorEncoderRightTickFromISR>:
        // We have a count when the robot is supposedly not moving.
        break;
    }
}
void vMotorEncoderRightTickFromISR(uint8_t wheelDirection, int16_t *rightWheelTicks, uint8_t rightEncoderTicks){
    switch (wheelDirection){
    2892:	82 30       	cpi	r24, 0x02	; 2
    2894:	19 f0       	breq	.+6      	; 0x289c <vMotorEncoderRightTickFromISR+0xa>
    2896:	84 30       	cpi	r24, 0x04	; 4
    2898:	51 f0       	breq	.+20     	; 0x28ae <vMotorEncoderRightTickFromISR+0x1c>
    289a:	08 95       	ret
        case motorRightForward:{
            *rightWheelTicks += rightEncoderTicks / 2;
    289c:	46 95       	lsr	r20
    289e:	fb 01       	movw	r30, r22
    28a0:	80 81       	ld	r24, Z
    28a2:	91 81       	ldd	r25, Z+1	; 0x01
    28a4:	84 0f       	add	r24, r20
    28a6:	91 1d       	adc	r25, r1
    28a8:	91 83       	std	Z+1, r25	; 0x01
    28aa:	80 83       	st	Z, r24
            break;
    28ac:	08 95       	ret
        }
        case  motorRightBackward:{
            *rightWheelTicks -= rightEncoderTicks / 2;
    28ae:	46 95       	lsr	r20
    28b0:	fb 01       	movw	r30, r22
    28b2:	80 81       	ld	r24, Z
    28b4:	91 81       	ldd	r25, Z+1	; 0x01
    28b6:	84 1b       	sub	r24, r20
    28b8:	91 09       	sbc	r25, r1
    28ba:	91 83       	std	Z+1, r25	; 0x01
    28bc:	80 83       	st	Z, r24
    28be:	08 95       	ret

000028c0 <pxPortInitialiseStack>:
#elif defined( portUSE_TIMER2 )
	portTIMSK &= ~( _BV(OCIE2B)|_BV(OCIE2A)|_BV(TOIE2) );	// disable all Timer2 interrupts
    ASSR = 0x00;              								// set Timer/Counter2 to be off

#elif defined( portUSE_TIMER3 )
	portTIMSK &= ~( _BV(OCIE3B)|_BV(OCIE3A)|_BV(TOIE3) );	// disable all Timer3 interrupts
    28c0:	31 e1       	ldi	r19, 0x11	; 17
    28c2:	fc 01       	movw	r30, r24
    28c4:	30 83       	st	Z, r19
    28c6:	31 97       	sbiw	r30, 0x01	; 1
    28c8:	22 e2       	ldi	r18, 0x22	; 34
    28ca:	20 83       	st	Z, r18
    28cc:	31 97       	sbiw	r30, 0x01	; 1
    28ce:	a3 e3       	ldi	r26, 0x33	; 51
    28d0:	a0 83       	st	Z, r26
    28d2:	31 97       	sbiw	r30, 0x01	; 1
    28d4:	60 83       	st	Z, r22
    28d6:	31 97       	sbiw	r30, 0x01	; 1
    28d8:	70 83       	st	Z, r23
    28da:	31 97       	sbiw	r30, 0x01	; 1
    28dc:	10 82       	st	Z, r1
    28de:	31 97       	sbiw	r30, 0x01	; 1
    28e0:	10 82       	st	Z, r1
    28e2:	31 97       	sbiw	r30, 0x01	; 1
    28e4:	60 e8       	ldi	r22, 0x80	; 128
    28e6:	60 83       	st	Z, r22
    28e8:	31 97       	sbiw	r30, 0x01	; 1
    28ea:	10 82       	st	Z, r1
    28ec:	31 97       	sbiw	r30, 0x01	; 1
    28ee:	10 82       	st	Z, r1
    28f0:	31 97       	sbiw	r30, 0x01	; 1
    28f2:	10 82       	st	Z, r1
    28f4:	31 97       	sbiw	r30, 0x01	; 1
    28f6:	62 e0       	ldi	r22, 0x02	; 2
    28f8:	60 83       	st	Z, r22
    28fa:	31 97       	sbiw	r30, 0x01	; 1
    28fc:	63 e0       	ldi	r22, 0x03	; 3
    28fe:	60 83       	st	Z, r22
    2900:	31 97       	sbiw	r30, 0x01	; 1
    2902:	64 e0       	ldi	r22, 0x04	; 4
    2904:	60 83       	st	Z, r22
    2906:	31 97       	sbiw	r30, 0x01	; 1
    2908:	65 e0       	ldi	r22, 0x05	; 5
    290a:	60 83       	st	Z, r22
    290c:	31 97       	sbiw	r30, 0x01	; 1
    290e:	66 e0       	ldi	r22, 0x06	; 6
    2910:	60 83       	st	Z, r22
    2912:	31 97       	sbiw	r30, 0x01	; 1
    2914:	67 e0       	ldi	r22, 0x07	; 7
    2916:	60 83       	st	Z, r22
    2918:	31 97       	sbiw	r30, 0x01	; 1
    291a:	68 e0       	ldi	r22, 0x08	; 8
    291c:	60 83       	st	Z, r22
    291e:	31 97       	sbiw	r30, 0x01	; 1
    2920:	69 e0       	ldi	r22, 0x09	; 9
    2922:	60 83       	st	Z, r22
    2924:	31 97       	sbiw	r30, 0x01	; 1
    2926:	60 e1       	ldi	r22, 0x10	; 16
    2928:	60 83       	st	Z, r22
    292a:	31 97       	sbiw	r30, 0x01	; 1
    292c:	30 83       	st	Z, r19
    292e:	31 97       	sbiw	r30, 0x01	; 1
    2930:	32 e1       	ldi	r19, 0x12	; 18
    2932:	30 83       	st	Z, r19
    2934:	31 97       	sbiw	r30, 0x01	; 1
    2936:	33 e1       	ldi	r19, 0x13	; 19
    2938:	30 83       	st	Z, r19
    293a:	31 97       	sbiw	r30, 0x01	; 1
    293c:	34 e1       	ldi	r19, 0x14	; 20
    293e:	30 83       	st	Z, r19
    2940:	31 97       	sbiw	r30, 0x01	; 1
    2942:	35 e1       	ldi	r19, 0x15	; 21
    2944:	30 83       	st	Z, r19
    2946:	31 97       	sbiw	r30, 0x01	; 1
    2948:	36 e1       	ldi	r19, 0x16	; 22
    294a:	30 83       	st	Z, r19
    294c:	31 97       	sbiw	r30, 0x01	; 1
    294e:	37 e1       	ldi	r19, 0x17	; 23
    2950:	30 83       	st	Z, r19
    2952:	31 97       	sbiw	r30, 0x01	; 1
    2954:	38 e1       	ldi	r19, 0x18	; 24
    2956:	30 83       	st	Z, r19
    2958:	31 97       	sbiw	r30, 0x01	; 1
    295a:	39 e1       	ldi	r19, 0x19	; 25
    295c:	30 83       	st	Z, r19
    295e:	31 97       	sbiw	r30, 0x01	; 1
    2960:	30 e2       	ldi	r19, 0x20	; 32
    2962:	30 83       	st	Z, r19
    2964:	31 97       	sbiw	r30, 0x01	; 1
    2966:	31 e2       	ldi	r19, 0x21	; 33
    2968:	30 83       	st	Z, r19
    296a:	31 97       	sbiw	r30, 0x01	; 1
    296c:	20 83       	st	Z, r18
    296e:	31 97       	sbiw	r30, 0x01	; 1
    2970:	23 e2       	ldi	r18, 0x23	; 35
    2972:	20 83       	st	Z, r18
    2974:	31 97       	sbiw	r30, 0x01	; 1
    2976:	40 83       	st	Z, r20
    2978:	31 97       	sbiw	r30, 0x01	; 1
    297a:	50 83       	st	Z, r21
    297c:	31 97       	sbiw	r30, 0x01	; 1
    297e:	26 e2       	ldi	r18, 0x26	; 38
    2980:	20 83       	st	Z, r18
    2982:	31 97       	sbiw	r30, 0x01	; 1
    2984:	27 e2       	ldi	r18, 0x27	; 39
    2986:	20 83       	st	Z, r18
    2988:	31 97       	sbiw	r30, 0x01	; 1
    298a:	28 e2       	ldi	r18, 0x28	; 40
    298c:	20 83       	st	Z, r18
    298e:	31 97       	sbiw	r30, 0x01	; 1
    2990:	29 e2       	ldi	r18, 0x29	; 41
    2992:	20 83       	st	Z, r18
    2994:	31 97       	sbiw	r30, 0x01	; 1
    2996:	20 e3       	ldi	r18, 0x30	; 48
    2998:	20 83       	st	Z, r18
    299a:	31 97       	sbiw	r30, 0x01	; 1
    299c:	21 e3       	ldi	r18, 0x31	; 49
    299e:	20 83       	st	Z, r18
    29a0:	89 97       	sbiw	r24, 0x29	; 41
    29a2:	08 95       	ret

000029a4 <xPortStartScheduler>:
    29a4:	88 ee       	ldi	r24, 0xE8	; 232
    29a6:	93 e0       	ldi	r25, 0x03	; 3
    29a8:	90 93 37 1b 	sts	0x1B37, r25	; 0x801b37 <portTickRateHz+0x1>
    29ac:	80 93 36 1b 	sts	0x1B36, r24	; 0x801b36 <portTickRateHz>
    29b0:	90 93 39 1b 	sts	0x1B39, r25	; 0x801b39 <ticksRemainingInSec+0x1>
    29b4:	80 93 38 1b 	sts	0x1B38, r24	; 0x801b38 <ticksRemainingInSec>
    29b8:	10 92 99 00 	sts	0x0099, r1	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
    29bc:	89 ef       	ldi	r24, 0xF9	; 249
    29be:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
    29c2:	8b e0       	ldi	r24, 0x0B	; 11
    29c4:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
    29c8:	e1 e7       	ldi	r30, 0x71	; 113
    29ca:	f0 e0       	ldi	r31, 0x00	; 0
    29cc:	80 81       	ld	r24, Z
    29ce:	82 60       	ori	r24, 0x02	; 2
    29d0:	80 83       	st	Z, r24
    29d2:	a0 91 f5 1a 	lds	r26, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    29d6:	b0 91 f6 1a 	lds	r27, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    29da:	cd 91       	ld	r28, X+
    29dc:	cd bf       	out	0x3d, r28	; 61
    29de:	dd 91       	ld	r29, X+
    29e0:	de bf       	out	0x3e, r29	; 62
    29e2:	ff 91       	pop	r31
    29e4:	ef 91       	pop	r30
    29e6:	df 91       	pop	r29
    29e8:	cf 91       	pop	r28
    29ea:	bf 91       	pop	r27
    29ec:	af 91       	pop	r26
    29ee:	9f 91       	pop	r25
    29f0:	8f 91       	pop	r24
    29f2:	7f 91       	pop	r23
    29f4:	6f 91       	pop	r22
    29f6:	5f 91       	pop	r21
    29f8:	4f 91       	pop	r20
    29fa:	3f 91       	pop	r19
    29fc:	2f 91       	pop	r18
    29fe:	1f 91       	pop	r17
    2a00:	0f 91       	pop	r16
    2a02:	ff 90       	pop	r15
    2a04:	ef 90       	pop	r14
    2a06:	df 90       	pop	r13
    2a08:	cf 90       	pop	r12
    2a0a:	bf 90       	pop	r11
    2a0c:	af 90       	pop	r10
    2a0e:	9f 90       	pop	r9
    2a10:	8f 90       	pop	r8
    2a12:	7f 90       	pop	r7
    2a14:	6f 90       	pop	r6
    2a16:	5f 90       	pop	r5
    2a18:	4f 90       	pop	r4
    2a1a:	3f 90       	pop	r3
    2a1c:	2f 90       	pop	r2
    2a1e:	1f 90       	pop	r1
    2a20:	0f 90       	pop	r0
    2a22:	0c be       	out	0x3c, r0	; 60
    2a24:	0f 90       	pop	r0
    2a26:	0b be       	out	0x3b, r0	; 59
    2a28:	0f 90       	pop	r0
    2a2a:	0f be       	out	0x3f, r0	; 63
    2a2c:	0f 90       	pop	r0
    2a2e:	08 95       	ret
    2a30:	81 e0       	ldi	r24, 0x01	; 1
    2a32:	08 95       	ret

00002a34 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2a34:	0f 92       	push	r0
    2a36:	0f b6       	in	r0, 0x3f	; 63
    2a38:	f8 94       	cli
    2a3a:	0f 92       	push	r0
    2a3c:	0b b6       	in	r0, 0x3b	; 59
    2a3e:	0f 92       	push	r0
    2a40:	0c b6       	in	r0, 0x3c	; 60
    2a42:	0f 92       	push	r0
    2a44:	1f 92       	push	r1
    2a46:	11 24       	eor	r1, r1
    2a48:	2f 92       	push	r2
    2a4a:	3f 92       	push	r3
    2a4c:	4f 92       	push	r4
    2a4e:	5f 92       	push	r5
    2a50:	6f 92       	push	r6
    2a52:	7f 92       	push	r7
    2a54:	8f 92       	push	r8
    2a56:	9f 92       	push	r9
    2a58:	af 92       	push	r10
    2a5a:	bf 92       	push	r11
    2a5c:	cf 92       	push	r12
    2a5e:	df 92       	push	r13
    2a60:	ef 92       	push	r14
    2a62:	ff 92       	push	r15
    2a64:	0f 93       	push	r16
    2a66:	1f 93       	push	r17
    2a68:	2f 93       	push	r18
    2a6a:	3f 93       	push	r19
    2a6c:	4f 93       	push	r20
    2a6e:	5f 93       	push	r21
    2a70:	6f 93       	push	r22
    2a72:	7f 93       	push	r23
    2a74:	8f 93       	push	r24
    2a76:	9f 93       	push	r25
    2a78:	af 93       	push	r26
    2a7a:	bf 93       	push	r27
    2a7c:	cf 93       	push	r28
    2a7e:	df 93       	push	r29
    2a80:	ef 93       	push	r30
    2a82:	ff 93       	push	r31
    2a84:	a0 91 f5 1a 	lds	r26, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    2a88:	b0 91 f6 1a 	lds	r27, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    2a8c:	0d b6       	in	r0, 0x3d	; 61
    2a8e:	0d 92       	st	X+, r0
    2a90:	0e b6       	in	r0, 0x3e	; 62
    2a92:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2a94:	0e 94 3b 24 	call	0x4876	; 0x4876 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2a98:	a0 91 f5 1a 	lds	r26, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    2a9c:	b0 91 f6 1a 	lds	r27, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    2aa0:	cd 91       	ld	r28, X+
    2aa2:	cd bf       	out	0x3d, r28	; 61
    2aa4:	dd 91       	ld	r29, X+
    2aa6:	de bf       	out	0x3e, r29	; 62
    2aa8:	ff 91       	pop	r31
    2aaa:	ef 91       	pop	r30
    2aac:	df 91       	pop	r29
    2aae:	cf 91       	pop	r28
    2ab0:	bf 91       	pop	r27
    2ab2:	af 91       	pop	r26
    2ab4:	9f 91       	pop	r25
    2ab6:	8f 91       	pop	r24
    2ab8:	7f 91       	pop	r23
    2aba:	6f 91       	pop	r22
    2abc:	5f 91       	pop	r21
    2abe:	4f 91       	pop	r20
    2ac0:	3f 91       	pop	r19
    2ac2:	2f 91       	pop	r18
    2ac4:	1f 91       	pop	r17
    2ac6:	0f 91       	pop	r16
    2ac8:	ff 90       	pop	r15
    2aca:	ef 90       	pop	r14
    2acc:	df 90       	pop	r13
    2ace:	cf 90       	pop	r12
    2ad0:	bf 90       	pop	r11
    2ad2:	af 90       	pop	r10
    2ad4:	9f 90       	pop	r9
    2ad6:	8f 90       	pop	r8
    2ad8:	7f 90       	pop	r7
    2ada:	6f 90       	pop	r6
    2adc:	5f 90       	pop	r5
    2ade:	4f 90       	pop	r4
    2ae0:	3f 90       	pop	r3
    2ae2:	2f 90       	pop	r2
    2ae4:	1f 90       	pop	r1
    2ae6:	0f 90       	pop	r0
    2ae8:	0c be       	out	0x3c, r0	; 60
    2aea:	0f 90       	pop	r0
    2aec:	0b be       	out	0x3b, r0	; 59
    2aee:	0f 90       	pop	r0
    2af0:	0f be       	out	0x3f, r0	; 63
    2af2:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    2af4:	08 95       	ret

00002af6 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2af6:	0f 92       	push	r0
    2af8:	0f b6       	in	r0, 0x3f	; 63
    2afa:	f8 94       	cli
    2afc:	0f 92       	push	r0
    2afe:	0b b6       	in	r0, 0x3b	; 59
    2b00:	0f 92       	push	r0
    2b02:	0c b6       	in	r0, 0x3c	; 60
    2b04:	0f 92       	push	r0
    2b06:	1f 92       	push	r1
    2b08:	11 24       	eor	r1, r1
    2b0a:	2f 92       	push	r2
    2b0c:	3f 92       	push	r3
    2b0e:	4f 92       	push	r4
    2b10:	5f 92       	push	r5
    2b12:	6f 92       	push	r6
    2b14:	7f 92       	push	r7
    2b16:	8f 92       	push	r8
    2b18:	9f 92       	push	r9
    2b1a:	af 92       	push	r10
    2b1c:	bf 92       	push	r11
    2b1e:	cf 92       	push	r12
    2b20:	df 92       	push	r13
    2b22:	ef 92       	push	r14
    2b24:	ff 92       	push	r15
    2b26:	0f 93       	push	r16
    2b28:	1f 93       	push	r17
    2b2a:	2f 93       	push	r18
    2b2c:	3f 93       	push	r19
    2b2e:	4f 93       	push	r20
    2b30:	5f 93       	push	r21
    2b32:	6f 93       	push	r22
    2b34:	7f 93       	push	r23
    2b36:	8f 93       	push	r24
    2b38:	9f 93       	push	r25
    2b3a:	af 93       	push	r26
    2b3c:	bf 93       	push	r27
    2b3e:	cf 93       	push	r28
    2b40:	df 93       	push	r29
    2b42:	ef 93       	push	r30
    2b44:	ff 93       	push	r31
    2b46:	a0 91 f5 1a 	lds	r26, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    2b4a:	b0 91 f6 1a 	lds	r27, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    2b4e:	0d b6       	in	r0, 0x3d	; 61
    2b50:	0d 92       	st	X+, r0
    2b52:	0e b6       	in	r0, 0x3e	; 62
    2b54:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    2b56:	13 be       	out	0x33, r1	; 51
	// start mark - check for start of interrupt - for debugging only
	PORTD |=  _BV(PORTD7);				// Ping IO line.
#endif

#if !defined(portUSE_TIMER2_RTC)
	if (--ticksRemainingInSec == 0)
    2b58:	80 91 38 1b 	lds	r24, 0x1B38	; 0x801b38 <ticksRemainingInSec>
    2b5c:	90 91 39 1b 	lds	r25, 0x1B39	; 0x801b39 <ticksRemainingInSec+0x1>
    2b60:	01 97       	sbiw	r24, 0x01	; 1
    2b62:	90 93 39 1b 	sts	0x1B39, r25	; 0x801b39 <ticksRemainingInSec+0x1>
    2b66:	80 93 38 1b 	sts	0x1B38, r24	; 0x801b38 <ticksRemainingInSec>
    2b6a:	89 2b       	or	r24, r25
    2b6c:	41 f4       	brne	.+16     	; 0x2b7e <vPortYieldFromTick+0x88>
	{
		//system_tick();
		ticksRemainingInSec = portTickRateHz;
    2b6e:	80 91 36 1b 	lds	r24, 0x1B36	; 0x801b36 <portTickRateHz>
    2b72:	90 91 37 1b 	lds	r25, 0x1B37	; 0x801b37 <portTickRateHz+0x1>
    2b76:	90 93 39 1b 	sts	0x1B39, r25	; 0x801b39 <ticksRemainingInSec+0x1>
    2b7a:	80 93 38 1b 	sts	0x1B38, r24	; 0x801b38 <ticksRemainingInSec>
	}
#endif

	if( xTaskIncrementTick() != pdFALSE )
    2b7e:	0e 94 7a 23 	call	0x46f4	; 0x46f4 <xTaskIncrementTick>
    2b82:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    2b84:	0e 94 3b 24 	call	0x4876	; 0x4876 <vTaskSwitchContext>
#if defined(DEBUG_PING)
	// end mark - check for end of interrupt - for debugging only
	PORTD &= ~_BV(PORTD7);
#endif

	portRESTORE_CONTEXT();
    2b88:	a0 91 f5 1a 	lds	r26, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    2b8c:	b0 91 f6 1a 	lds	r27, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    2b90:	cd 91       	ld	r28, X+
    2b92:	cd bf       	out	0x3d, r28	; 61
    2b94:	dd 91       	ld	r29, X+
    2b96:	de bf       	out	0x3e, r29	; 62
    2b98:	ff 91       	pop	r31
    2b9a:	ef 91       	pop	r30
    2b9c:	df 91       	pop	r29
    2b9e:	cf 91       	pop	r28
    2ba0:	bf 91       	pop	r27
    2ba2:	af 91       	pop	r26
    2ba4:	9f 91       	pop	r25
    2ba6:	8f 91       	pop	r24
    2ba8:	7f 91       	pop	r23
    2baa:	6f 91       	pop	r22
    2bac:	5f 91       	pop	r21
    2bae:	4f 91       	pop	r20
    2bb0:	3f 91       	pop	r19
    2bb2:	2f 91       	pop	r18
    2bb4:	1f 91       	pop	r17
    2bb6:	0f 91       	pop	r16
    2bb8:	ff 90       	pop	r15
    2bba:	ef 90       	pop	r14
    2bbc:	df 90       	pop	r13
    2bbe:	cf 90       	pop	r12
    2bc0:	bf 90       	pop	r11
    2bc2:	af 90       	pop	r10
    2bc4:	9f 90       	pop	r9
    2bc6:	8f 90       	pop	r8
    2bc8:	7f 90       	pop	r7
    2bca:	6f 90       	pop	r6
    2bcc:	5f 90       	pop	r5
    2bce:	4f 90       	pop	r4
    2bd0:	3f 90       	pop	r3
    2bd2:	2f 90       	pop	r2
    2bd4:	1f 90       	pop	r1
    2bd6:	0f 90       	pop	r0
    2bd8:	0c be       	out	0x3c, r0	; 60
    2bda:	0f 90       	pop	r0
    2bdc:	0b be       	out	0x3b, r0	; 59
    2bde:	0f 90       	pop	r0
    2be0:	0f be       	out	0x3f, r0	; 63
    2be2:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    2be4:	08 95       	ret

00002be6 <__vector_32>:
	 */
//	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK)
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
    2be6:	87 df       	rcall	.-242    	; 0x2af6 <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
    2be8:	18 95       	reti

00002bea <xQueueGenericCreate>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2bea:	0f 93       	push	r16
    2bec:	1f 93       	push	r17
    2bee:	cf 93       	push	r28
    2bf0:	df 93       	push	r29
    2bf2:	08 2f       	mov	r16, r24
    2bf4:	16 2f       	mov	r17, r22
    2bf6:	66 23       	and	r22, r22
    2bf8:	09 f4       	brne	.+2      	; 0x2bfc <xQueueGenericCreate+0x12>
    2bfa:	3b c0       	rjmp	.+118    	; 0x2c72 <xQueueGenericCreate+0x88>
    2bfc:	86 9f       	mul	r24, r22
    2bfe:	c0 01       	movw	r24, r0
    2c00:	11 24       	eor	r1, r1
    2c02:	80 96       	adiw	r24, 0x20	; 32
    2c04:	0e 94 8f 02 	call	0x51e	; 0x51e <pvPortMalloc>
    2c08:	ec 01       	movw	r28, r24
    2c0a:	00 97       	sbiw	r24, 0x00	; 0
    2c0c:	21 f4       	brne	.+8      	; 0x2c16 <xQueueGenericCreate+0x2c>
    2c0e:	39 c0       	rjmp	.+114    	; 0x2c82 <xQueueGenericCreate+0x98>
    2c10:	d9 83       	std	Y+1, r29	; 0x01
    2c12:	c8 83       	st	Y, r28
    2c14:	03 c0       	rjmp	.+6      	; 0x2c1c <xQueueGenericCreate+0x32>
    2c16:	4f 96       	adiw	r24, 0x1f	; 31
    2c18:	99 83       	std	Y+1, r25	; 0x01
    2c1a:	88 83       	st	Y, r24
    2c1c:	0b 8f       	std	Y+27, r16	; 0x1b
    2c1e:	1c 8f       	std	Y+28, r17	; 0x1c
    2c20:	0f b6       	in	r0, 0x3f	; 63
    2c22:	f8 94       	cli
    2c24:	0f 92       	push	r0
    2c26:	48 81       	ld	r20, Y
    2c28:	59 81       	ldd	r21, Y+1	; 0x01
    2c2a:	2c 8d       	ldd	r18, Y+28	; 0x1c
    2c2c:	30 e0       	ldi	r19, 0x00	; 0
    2c2e:	6b 8d       	ldd	r22, Y+27	; 0x1b
    2c30:	62 9f       	mul	r22, r18
    2c32:	c0 01       	movw	r24, r0
    2c34:	63 9f       	mul	r22, r19
    2c36:	90 0d       	add	r25, r0
    2c38:	11 24       	eor	r1, r1
    2c3a:	ba 01       	movw	r22, r20
    2c3c:	68 0f       	add	r22, r24
    2c3e:	79 1f       	adc	r23, r25
    2c40:	7b 83       	std	Y+3, r23	; 0x03
    2c42:	6a 83       	std	Y+2, r22	; 0x02
    2c44:	1a 8e       	std	Y+26, r1	; 0x1a
    2c46:	5d 83       	std	Y+5, r21	; 0x05
    2c48:	4c 83       	std	Y+4, r20	; 0x04
    2c4a:	82 1b       	sub	r24, r18
    2c4c:	93 0b       	sbc	r25, r19
    2c4e:	84 0f       	add	r24, r20
    2c50:	95 1f       	adc	r25, r21
    2c52:	9f 83       	std	Y+7, r25	; 0x07
    2c54:	8e 83       	std	Y+6, r24	; 0x06
    2c56:	8f ef       	ldi	r24, 0xFF	; 255
    2c58:	8d 8f       	std	Y+29, r24	; 0x1d
    2c5a:	8e 8f       	std	Y+30, r24	; 0x1e
    2c5c:	ce 01       	movw	r24, r28
    2c5e:	08 96       	adiw	r24, 0x08	; 8
    2c60:	0e 94 ee 05 	call	0xbdc	; 0xbdc <vListInitialise>
    2c64:	ce 01       	movw	r24, r28
    2c66:	41 96       	adiw	r24, 0x11	; 17
    2c68:	0e 94 ee 05 	call	0xbdc	; 0xbdc <vListInitialise>
    2c6c:	0f 90       	pop	r0
    2c6e:	0f be       	out	0x3f, r0	; 63
    2c70:	08 c0       	rjmp	.+16     	; 0x2c82 <xQueueGenericCreate+0x98>
    2c72:	8f e1       	ldi	r24, 0x1F	; 31
    2c74:	90 e0       	ldi	r25, 0x00	; 0
    2c76:	0e 94 8f 02 	call	0x51e	; 0x51e <pvPortMalloc>
    2c7a:	ec 01       	movw	r28, r24
    2c7c:	89 2b       	or	r24, r25
    2c7e:	09 f0       	breq	.+2      	; 0x2c82 <xQueueGenericCreate+0x98>
    2c80:	c7 cf       	rjmp	.-114    	; 0x2c10 <xQueueGenericCreate+0x26>
    2c82:	ce 01       	movw	r24, r28
    2c84:	df 91       	pop	r29
    2c86:	cf 91       	pop	r28
    2c88:	1f 91       	pop	r17
    2c8a:	0f 91       	pop	r16
    2c8c:	08 95       	ret

00002c8e <xQueueCreateMutex>:
    2c8e:	9f 92       	push	r9
    2c90:	af 92       	push	r10
    2c92:	bf 92       	push	r11
    2c94:	cf 92       	push	r12
    2c96:	df 92       	push	r13
    2c98:	ef 92       	push	r14
    2c9a:	ff 92       	push	r15
    2c9c:	0f 93       	push	r16
    2c9e:	1f 93       	push	r17
    2ca0:	cf 93       	push	r28
    2ca2:	df 93       	push	r29
    2ca4:	00 d0       	rcall	.+0      	; 0x2ca6 <xQueueCreateMutex+0x18>
    2ca6:	1f 92       	push	r1
    2ca8:	1f 92       	push	r1
    2caa:	cd b7       	in	r28, 0x3d	; 61
    2cac:	de b7       	in	r29, 0x3e	; 62
    2cae:	8f e1       	ldi	r24, 0x1F	; 31
    2cb0:	90 e0       	ldi	r25, 0x00	; 0
    2cb2:	0e 94 8f 02 	call	0x51e	; 0x51e <pvPortMalloc>
    2cb6:	8c 01       	movw	r16, r24
    2cb8:	00 97       	sbiw	r24, 0x00	; 0
    2cba:	09 f4       	brne	.+2      	; 0x2cbe <xQueueCreateMutex+0x30>
    2cbc:	58 c1       	rjmp	.+688    	; 0x2f6e <xQueueCreateMutex+0x2e0>
    2cbe:	fc 01       	movw	r30, r24
    2cc0:	13 82       	std	Z+3, r1	; 0x03
    2cc2:	12 82       	std	Z+2, r1	; 0x02
    2cc4:	11 82       	std	Z+1, r1	; 0x01
    2cc6:	10 82       	st	Z, r1
    2cc8:	15 82       	std	Z+5, r1	; 0x05
    2cca:	14 82       	std	Z+4, r1	; 0x04
    2ccc:	17 82       	std	Z+7, r1	; 0x07
    2cce:	16 82       	std	Z+6, r1	; 0x06
    2cd0:	12 8e       	std	Z+26, r1	; 0x1a
    2cd2:	81 e0       	ldi	r24, 0x01	; 1
    2cd4:	83 8f       	std	Z+27, r24	; 0x1b
    2cd6:	14 8e       	std	Z+28, r1	; 0x1c
    2cd8:	8f ef       	ldi	r24, 0xFF	; 255
    2cda:	85 8f       	std	Z+29, r24	; 0x1d
    2cdc:	86 8f       	std	Z+30, r24	; 0x1e
    2cde:	78 01       	movw	r14, r16
    2ce0:	f8 e0       	ldi	r31, 0x08	; 8
    2ce2:	ef 0e       	add	r14, r31
    2ce4:	f1 1c       	adc	r15, r1
    2ce6:	c7 01       	movw	r24, r14
    2ce8:	0e 94 ee 05 	call	0xbdc	; 0xbdc <vListInitialise>
    2cec:	68 01       	movw	r12, r16
    2cee:	81 e1       	ldi	r24, 0x11	; 17
    2cf0:	c8 0e       	add	r12, r24
    2cf2:	d1 1c       	adc	r13, r1
    2cf4:	c6 01       	movw	r24, r12
    2cf6:	0e 94 ee 05 	call	0xbdc	; 0xbdc <vListInitialise>
    2cfa:	1d 82       	std	Y+5, r1	; 0x05
    2cfc:	1c 82       	std	Y+4, r1	; 0x04
    2cfe:	a1 2c       	mov	r10, r1
    2d00:	99 24       	eor	r9, r9
    2d02:	93 94       	inc	r9
    2d04:	bb 24       	eor	r11, r11
    2d06:	ba 94       	dec	r11
    2d08:	0f b6       	in	r0, 0x3f	; 63
    2d0a:	f8 94       	cli
    2d0c:	0f 92       	push	r0
    2d0e:	f8 01       	movw	r30, r16
    2d10:	92 8d       	ldd	r25, Z+26	; 0x1a
    2d12:	83 8d       	ldd	r24, Z+27	; 0x1b
    2d14:	98 17       	cp	r25, r24
    2d16:	f0 f4       	brcc	.+60     	; 0x2d54 <xQueueCreateMutex+0xc6>
    2d18:	80 81       	ld	r24, Z
    2d1a:	91 81       	ldd	r25, Z+1	; 0x01
    2d1c:	89 2b       	or	r24, r25
    2d1e:	09 f0       	breq	.+2      	; 0x2d22 <xQueueCreateMutex+0x94>
    2d20:	1d c1       	rjmp	.+570    	; 0x2f5c <xQueueCreateMutex+0x2ce>
    2d22:	82 81       	ldd	r24, Z+2	; 0x02
    2d24:	93 81       	ldd	r25, Z+3	; 0x03
    2d26:	0e 94 13 26 	call	0x4c26	; 0x4c26 <xTaskPriorityDisinherit>
    2d2a:	f8 01       	movw	r30, r16
    2d2c:	13 82       	std	Z+3, r1	; 0x03
    2d2e:	12 82       	std	Z+2, r1	; 0x02
    2d30:	92 8d       	ldd	r25, Z+26	; 0x1a
    2d32:	9f 5f       	subi	r25, 0xFF	; 255
    2d34:	92 8f       	std	Z+26, r25	; 0x1a
    2d36:	91 89       	ldd	r25, Z+17	; 0x11
    2d38:	99 23       	and	r25, r25
    2d3a:	39 f0       	breq	.+14     	; 0x2d4a <xQueueCreateMutex+0xbc>
    2d3c:	c6 01       	movw	r24, r12
    2d3e:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <xTaskRemoveFromEventList>
    2d42:	81 30       	cpi	r24, 0x01	; 1
    2d44:	21 f4       	brne	.+8      	; 0x2d4e <xQueueCreateMutex+0xc0>
    2d46:	76 de       	rcall	.-788    	; 0x2a34 <vPortYield>
    2d48:	02 c0       	rjmp	.+4      	; 0x2d4e <xQueueCreateMutex+0xc0>
    2d4a:	81 11       	cpse	r24, r1
    2d4c:	73 de       	rcall	.-794    	; 0x2a34 <vPortYield>
    2d4e:	0f 90       	pop	r0
    2d50:	0f be       	out	0x3f, r0	; 63
    2d52:	0d c1       	rjmp	.+538    	; 0x2f6e <xQueueCreateMutex+0x2e0>
    2d54:	8c 81       	ldd	r24, Y+4	; 0x04
    2d56:	9d 81       	ldd	r25, Y+5	; 0x05
    2d58:	89 2b       	or	r24, r25
    2d5a:	19 f4       	brne	.+6      	; 0x2d62 <xQueueCreateMutex+0xd4>
    2d5c:	0f 90       	pop	r0
    2d5e:	0f be       	out	0x3f, r0	; 63
    2d60:	06 c1       	rjmp	.+524    	; 0x2f6e <xQueueCreateMutex+0x2e0>
    2d62:	a1 10       	cpse	r10, r1
    2d64:	05 c0       	rjmp	.+10     	; 0x2d70 <xQueueCreateMutex+0xe2>
    2d66:	ce 01       	movw	r24, r28
    2d68:	01 96       	adiw	r24, 0x01	; 1
    2d6a:	0e 94 67 25 	call	0x4ace	; 0x4ace <vTaskSetTimeOutState>
    2d6e:	a9 2c       	mov	r10, r9
    2d70:	0f 90       	pop	r0
    2d72:	0f be       	out	0x3f, r0	; 63
    2d74:	0e 94 2f 22 	call	0x445e	; 0x445e <vTaskSuspendAll>
    2d78:	0f b6       	in	r0, 0x3f	; 63
    2d7a:	f8 94       	cli
    2d7c:	0f 92       	push	r0
    2d7e:	f8 01       	movw	r30, r16
    2d80:	85 8d       	ldd	r24, Z+29	; 0x1d
    2d82:	8f 3f       	cpi	r24, 0xFF	; 255
    2d84:	09 f4       	brne	.+2      	; 0x2d88 <xQueueCreateMutex+0xfa>
    2d86:	15 8e       	std	Z+29, r1	; 0x1d
    2d88:	f8 01       	movw	r30, r16
    2d8a:	86 8d       	ldd	r24, Z+30	; 0x1e
    2d8c:	8f 3f       	cpi	r24, 0xFF	; 255
    2d8e:	09 f4       	brne	.+2      	; 0x2d92 <xQueueCreateMutex+0x104>
    2d90:	16 8e       	std	Z+30, r1	; 0x1e
    2d92:	0f 90       	pop	r0
    2d94:	0f be       	out	0x3f, r0	; 63
    2d96:	be 01       	movw	r22, r28
    2d98:	6c 5f       	subi	r22, 0xFC	; 252
    2d9a:	7f 4f       	sbci	r23, 0xFF	; 255
    2d9c:	ce 01       	movw	r24, r28
    2d9e:	01 96       	adiw	r24, 0x01	; 1
    2da0:	0e 94 72 25 	call	0x4ae4	; 0x4ae4 <xTaskCheckForTimeOut>
    2da4:	81 11       	cpse	r24, r1
    2da6:	96 c0       	rjmp	.+300    	; 0x2ed4 <xQueueCreateMutex+0x246>
    2da8:	0f b6       	in	r0, 0x3f	; 63
    2daa:	f8 94       	cli
    2dac:	0f 92       	push	r0
    2dae:	f8 01       	movw	r30, r16
    2db0:	92 8d       	ldd	r25, Z+26	; 0x1a
    2db2:	83 8d       	ldd	r24, Z+27	; 0x1b
    2db4:	0f 90       	pop	r0
    2db6:	0f be       	out	0x3f, r0	; 63
    2db8:	98 13       	cpse	r25, r24
    2dba:	4a c0       	rjmp	.+148    	; 0x2e50 <xQueueCreateMutex+0x1c2>
    2dbc:	6c 81       	ldd	r22, Y+4	; 0x04
    2dbe:	7d 81       	ldd	r23, Y+5	; 0x05
    2dc0:	c7 01       	movw	r24, r14
    2dc2:	0e 94 c3 24 	call	0x4986	; 0x4986 <vTaskPlaceOnEventList>
    2dc6:	0f b6       	in	r0, 0x3f	; 63
    2dc8:	f8 94       	cli
    2dca:	0f 92       	push	r0
    2dcc:	f8 01       	movw	r30, r16
    2dce:	86 8d       	ldd	r24, Z+30	; 0x1e
    2dd0:	18 16       	cp	r1, r24
    2dd2:	ac f4       	brge	.+42     	; 0x2dfe <xQueueCreateMutex+0x170>
    2dd4:	81 89       	ldd	r24, Z+17	; 0x11
    2dd6:	81 11       	cpse	r24, r1
    2dd8:	05 c0       	rjmp	.+10     	; 0x2de4 <xQueueCreateMutex+0x156>
    2dda:	11 c0       	rjmp	.+34     	; 0x2dfe <xQueueCreateMutex+0x170>
    2ddc:	f8 01       	movw	r30, r16
    2dde:	81 89       	ldd	r24, Z+17	; 0x11
    2de0:	88 23       	and	r24, r24
    2de2:	69 f0       	breq	.+26     	; 0x2dfe <xQueueCreateMutex+0x170>
    2de4:	c6 01       	movw	r24, r12
    2de6:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <xTaskRemoveFromEventList>
    2dea:	81 11       	cpse	r24, r1
    2dec:	0e 94 ad 25 	call	0x4b5a	; 0x4b5a <vTaskMissedYield>
    2df0:	f8 01       	movw	r30, r16
    2df2:	86 8d       	ldd	r24, Z+30	; 0x1e
    2df4:	81 50       	subi	r24, 0x01	; 1
    2df6:	86 8f       	std	Z+30, r24	; 0x1e
    2df8:	86 8d       	ldd	r24, Z+30	; 0x1e
    2dfa:	18 16       	cp	r1, r24
    2dfc:	7c f3       	brlt	.-34     	; 0x2ddc <xQueueCreateMutex+0x14e>
    2dfe:	f8 01       	movw	r30, r16
    2e00:	b6 8e       	std	Z+30, r11	; 0x1e
    2e02:	0f 90       	pop	r0
    2e04:	0f be       	out	0x3f, r0	; 63
    2e06:	0f b6       	in	r0, 0x3f	; 63
    2e08:	f8 94       	cli
    2e0a:	0f 92       	push	r0
    2e0c:	85 8d       	ldd	r24, Z+29	; 0x1d
    2e0e:	18 16       	cp	r1, r24
    2e10:	ac f4       	brge	.+42     	; 0x2e3c <xQueueCreateMutex+0x1ae>
    2e12:	80 85       	ldd	r24, Z+8	; 0x08
    2e14:	81 11       	cpse	r24, r1
    2e16:	05 c0       	rjmp	.+10     	; 0x2e22 <xQueueCreateMutex+0x194>
    2e18:	11 c0       	rjmp	.+34     	; 0x2e3c <xQueueCreateMutex+0x1ae>
    2e1a:	f8 01       	movw	r30, r16
    2e1c:	80 85       	ldd	r24, Z+8	; 0x08
    2e1e:	88 23       	and	r24, r24
    2e20:	69 f0       	breq	.+26     	; 0x2e3c <xQueueCreateMutex+0x1ae>
    2e22:	c7 01       	movw	r24, r14
    2e24:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <xTaskRemoveFromEventList>
    2e28:	81 11       	cpse	r24, r1
    2e2a:	0e 94 ad 25 	call	0x4b5a	; 0x4b5a <vTaskMissedYield>
    2e2e:	f8 01       	movw	r30, r16
    2e30:	85 8d       	ldd	r24, Z+29	; 0x1d
    2e32:	81 50       	subi	r24, 0x01	; 1
    2e34:	85 8f       	std	Z+29, r24	; 0x1d
    2e36:	85 8d       	ldd	r24, Z+29	; 0x1d
    2e38:	18 16       	cp	r1, r24
    2e3a:	7c f3       	brlt	.-34     	; 0x2e1a <xQueueCreateMutex+0x18c>
    2e3c:	f8 01       	movw	r30, r16
    2e3e:	b5 8e       	std	Z+29, r11	; 0x1d
    2e40:	0f 90       	pop	r0
    2e42:	0f be       	out	0x3f, r0	; 63
    2e44:	0e 94 35 22 	call	0x446a	; 0x446a <xTaskResumeAll>
    2e48:	81 11       	cpse	r24, r1
    2e4a:	5e cf       	rjmp	.-324    	; 0x2d08 <xQueueCreateMutex+0x7a>
    2e4c:	f3 dd       	rcall	.-1050   	; 0x2a34 <vPortYield>
    2e4e:	5c cf       	rjmp	.-328    	; 0x2d08 <xQueueCreateMutex+0x7a>
    2e50:	0f b6       	in	r0, 0x3f	; 63
    2e52:	f8 94       	cli
    2e54:	0f 92       	push	r0
    2e56:	f8 01       	movw	r30, r16
    2e58:	86 8d       	ldd	r24, Z+30	; 0x1e
    2e5a:	18 16       	cp	r1, r24
    2e5c:	ac f4       	brge	.+42     	; 0x2e88 <xQueueCreateMutex+0x1fa>
    2e5e:	81 89       	ldd	r24, Z+17	; 0x11
    2e60:	81 11       	cpse	r24, r1
    2e62:	05 c0       	rjmp	.+10     	; 0x2e6e <xQueueCreateMutex+0x1e0>
    2e64:	11 c0       	rjmp	.+34     	; 0x2e88 <xQueueCreateMutex+0x1fa>
    2e66:	f8 01       	movw	r30, r16
    2e68:	81 89       	ldd	r24, Z+17	; 0x11
    2e6a:	88 23       	and	r24, r24
    2e6c:	69 f0       	breq	.+26     	; 0x2e88 <xQueueCreateMutex+0x1fa>
    2e6e:	c6 01       	movw	r24, r12
    2e70:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <xTaskRemoveFromEventList>
    2e74:	81 11       	cpse	r24, r1
    2e76:	0e 94 ad 25 	call	0x4b5a	; 0x4b5a <vTaskMissedYield>
    2e7a:	f8 01       	movw	r30, r16
    2e7c:	96 8d       	ldd	r25, Z+30	; 0x1e
    2e7e:	91 50       	subi	r25, 0x01	; 1
    2e80:	96 8f       	std	Z+30, r25	; 0x1e
    2e82:	86 8d       	ldd	r24, Z+30	; 0x1e
    2e84:	18 16       	cp	r1, r24
    2e86:	7c f3       	brlt	.-34     	; 0x2e66 <xQueueCreateMutex+0x1d8>
    2e88:	f8 01       	movw	r30, r16
    2e8a:	b6 8e       	std	Z+30, r11	; 0x1e
    2e8c:	0f 90       	pop	r0
    2e8e:	0f be       	out	0x3f, r0	; 63
    2e90:	0f b6       	in	r0, 0x3f	; 63
    2e92:	f8 94       	cli
    2e94:	0f 92       	push	r0
    2e96:	85 8d       	ldd	r24, Z+29	; 0x1d
    2e98:	18 16       	cp	r1, r24
    2e9a:	ac f4       	brge	.+42     	; 0x2ec6 <xQueueCreateMutex+0x238>
    2e9c:	80 85       	ldd	r24, Z+8	; 0x08
    2e9e:	81 11       	cpse	r24, r1
    2ea0:	05 c0       	rjmp	.+10     	; 0x2eac <xQueueCreateMutex+0x21e>
    2ea2:	11 c0       	rjmp	.+34     	; 0x2ec6 <xQueueCreateMutex+0x238>
    2ea4:	f8 01       	movw	r30, r16
    2ea6:	80 85       	ldd	r24, Z+8	; 0x08
    2ea8:	88 23       	and	r24, r24
    2eaa:	69 f0       	breq	.+26     	; 0x2ec6 <xQueueCreateMutex+0x238>
    2eac:	c7 01       	movw	r24, r14
    2eae:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <xTaskRemoveFromEventList>
    2eb2:	81 11       	cpse	r24, r1
    2eb4:	0e 94 ad 25 	call	0x4b5a	; 0x4b5a <vTaskMissedYield>
    2eb8:	f8 01       	movw	r30, r16
    2eba:	95 8d       	ldd	r25, Z+29	; 0x1d
    2ebc:	91 50       	subi	r25, 0x01	; 1
    2ebe:	95 8f       	std	Z+29, r25	; 0x1d
    2ec0:	85 8d       	ldd	r24, Z+29	; 0x1d
    2ec2:	18 16       	cp	r1, r24
    2ec4:	7c f3       	brlt	.-34     	; 0x2ea4 <xQueueCreateMutex+0x216>
    2ec6:	f8 01       	movw	r30, r16
    2ec8:	b5 8e       	std	Z+29, r11	; 0x1d
    2eca:	0f 90       	pop	r0
    2ecc:	0f be       	out	0x3f, r0	; 63
    2ece:	0e 94 35 22 	call	0x446a	; 0x446a <xTaskResumeAll>
    2ed2:	1a cf       	rjmp	.-460    	; 0x2d08 <xQueueCreateMutex+0x7a>
    2ed4:	0f b6       	in	r0, 0x3f	; 63
    2ed6:	f8 94       	cli
    2ed8:	0f 92       	push	r0
    2eda:	f8 01       	movw	r30, r16
    2edc:	86 8d       	ldd	r24, Z+30	; 0x1e
    2ede:	18 16       	cp	r1, r24
    2ee0:	ac f4       	brge	.+42     	; 0x2f0c <xQueueCreateMutex+0x27e>
    2ee2:	81 89       	ldd	r24, Z+17	; 0x11
    2ee4:	81 11       	cpse	r24, r1
    2ee6:	05 c0       	rjmp	.+10     	; 0x2ef2 <xQueueCreateMutex+0x264>
    2ee8:	11 c0       	rjmp	.+34     	; 0x2f0c <xQueueCreateMutex+0x27e>
    2eea:	f8 01       	movw	r30, r16
    2eec:	81 89       	ldd	r24, Z+17	; 0x11
    2eee:	88 23       	and	r24, r24
    2ef0:	69 f0       	breq	.+26     	; 0x2f0c <xQueueCreateMutex+0x27e>
    2ef2:	c6 01       	movw	r24, r12
    2ef4:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <xTaskRemoveFromEventList>
    2ef8:	81 11       	cpse	r24, r1
    2efa:	0e 94 ad 25 	call	0x4b5a	; 0x4b5a <vTaskMissedYield>
    2efe:	f8 01       	movw	r30, r16
    2f00:	86 8d       	ldd	r24, Z+30	; 0x1e
    2f02:	81 50       	subi	r24, 0x01	; 1
    2f04:	86 8f       	std	Z+30, r24	; 0x1e
    2f06:	86 8d       	ldd	r24, Z+30	; 0x1e
    2f08:	18 16       	cp	r1, r24
    2f0a:	7c f3       	brlt	.-34     	; 0x2eea <xQueueCreateMutex+0x25c>
    2f0c:	8f ef       	ldi	r24, 0xFF	; 255
    2f0e:	f8 01       	movw	r30, r16
    2f10:	86 8f       	std	Z+30, r24	; 0x1e
    2f12:	0f 90       	pop	r0
    2f14:	0f be       	out	0x3f, r0	; 63
    2f16:	0f b6       	in	r0, 0x3f	; 63
    2f18:	f8 94       	cli
    2f1a:	0f 92       	push	r0
    2f1c:	85 8d       	ldd	r24, Z+29	; 0x1d
    2f1e:	18 16       	cp	r1, r24
    2f20:	ac f4       	brge	.+42     	; 0x2f4c <xQueueCreateMutex+0x2be>
    2f22:	80 85       	ldd	r24, Z+8	; 0x08
    2f24:	81 11       	cpse	r24, r1
    2f26:	05 c0       	rjmp	.+10     	; 0x2f32 <xQueueCreateMutex+0x2a4>
    2f28:	11 c0       	rjmp	.+34     	; 0x2f4c <xQueueCreateMutex+0x2be>
    2f2a:	f8 01       	movw	r30, r16
    2f2c:	80 85       	ldd	r24, Z+8	; 0x08
    2f2e:	88 23       	and	r24, r24
    2f30:	69 f0       	breq	.+26     	; 0x2f4c <xQueueCreateMutex+0x2be>
    2f32:	c7 01       	movw	r24, r14
    2f34:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <xTaskRemoveFromEventList>
    2f38:	81 11       	cpse	r24, r1
    2f3a:	0e 94 ad 25 	call	0x4b5a	; 0x4b5a <vTaskMissedYield>
    2f3e:	f8 01       	movw	r30, r16
    2f40:	85 8d       	ldd	r24, Z+29	; 0x1d
    2f42:	81 50       	subi	r24, 0x01	; 1
    2f44:	85 8f       	std	Z+29, r24	; 0x1d
    2f46:	85 8d       	ldd	r24, Z+29	; 0x1d
    2f48:	18 16       	cp	r1, r24
    2f4a:	7c f3       	brlt	.-34     	; 0x2f2a <xQueueCreateMutex+0x29c>
    2f4c:	8f ef       	ldi	r24, 0xFF	; 255
    2f4e:	f8 01       	movw	r30, r16
    2f50:	85 8f       	std	Z+29, r24	; 0x1d
    2f52:	0f 90       	pop	r0
    2f54:	0f be       	out	0x3f, r0	; 63
    2f56:	0e 94 35 22 	call	0x446a	; 0x446a <xTaskResumeAll>
    2f5a:	09 c0       	rjmp	.+18     	; 0x2f6e <xQueueCreateMutex+0x2e0>
    2f5c:	f8 01       	movw	r30, r16
    2f5e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2f60:	8f 5f       	subi	r24, 0xFF	; 255
    2f62:	82 8f       	std	Z+26, r24	; 0x1a
    2f64:	81 89       	ldd	r24, Z+17	; 0x11
    2f66:	88 23       	and	r24, r24
    2f68:	09 f4       	brne	.+2      	; 0x2f6c <xQueueCreateMutex+0x2de>
    2f6a:	f1 ce       	rjmp	.-542    	; 0x2d4e <xQueueCreateMutex+0xc0>
    2f6c:	e7 ce       	rjmp	.-562    	; 0x2d3c <xQueueCreateMutex+0xae>
    2f6e:	c8 01       	movw	r24, r16
    2f70:	0f 90       	pop	r0
    2f72:	0f 90       	pop	r0
    2f74:	0f 90       	pop	r0
    2f76:	0f 90       	pop	r0
    2f78:	0f 90       	pop	r0
    2f7a:	df 91       	pop	r29
    2f7c:	cf 91       	pop	r28
    2f7e:	1f 91       	pop	r17
    2f80:	0f 91       	pop	r16
    2f82:	ff 90       	pop	r15
    2f84:	ef 90       	pop	r14
    2f86:	df 90       	pop	r13
    2f88:	cf 90       	pop	r12
    2f8a:	bf 90       	pop	r11
    2f8c:	af 90       	pop	r10
    2f8e:	9f 90       	pop	r9
    2f90:	08 95       	ret

00002f92 <xQueueGenericSend>:
    2f92:	6f 92       	push	r6
    2f94:	7f 92       	push	r7
    2f96:	8f 92       	push	r8
    2f98:	9f 92       	push	r9
    2f9a:	af 92       	push	r10
    2f9c:	bf 92       	push	r11
    2f9e:	cf 92       	push	r12
    2fa0:	df 92       	push	r13
    2fa2:	ef 92       	push	r14
    2fa4:	ff 92       	push	r15
    2fa6:	0f 93       	push	r16
    2fa8:	1f 93       	push	r17
    2faa:	cf 93       	push	r28
    2fac:	df 93       	push	r29
    2fae:	00 d0       	rcall	.+0      	; 0x2fb0 <xQueueGenericSend+0x1e>
    2fb0:	1f 92       	push	r1
    2fb2:	1f 92       	push	r1
    2fb4:	cd b7       	in	r28, 0x3d	; 61
    2fb6:	de b7       	in	r29, 0x3e	; 62
    2fb8:	8c 01       	movw	r16, r24
    2fba:	5b 01       	movw	r10, r22
    2fbc:	5d 83       	std	Y+5, r21	; 0x05
    2fbe:	4c 83       	std	Y+4, r20	; 0x04
    2fc0:	72 2e       	mov	r7, r18
    2fc2:	81 2c       	mov	r8, r1
    2fc4:	66 24       	eor	r6, r6
    2fc6:	63 94       	inc	r6
    2fc8:	99 24       	eor	r9, r9
    2fca:	9a 94       	dec	r9
    2fcc:	7c 01       	movw	r14, r24
    2fce:	88 e0       	ldi	r24, 0x08	; 8
    2fd0:	e8 0e       	add	r14, r24
    2fd2:	f1 1c       	adc	r15, r1
    2fd4:	68 01       	movw	r12, r16
    2fd6:	e1 e1       	ldi	r30, 0x11	; 17
    2fd8:	ce 0e       	add	r12, r30
    2fda:	d1 1c       	adc	r13, r1
    2fdc:	0f b6       	in	r0, 0x3f	; 63
    2fde:	f8 94       	cli
    2fe0:	0f 92       	push	r0
    2fe2:	f8 01       	movw	r30, r16
    2fe4:	92 8d       	ldd	r25, Z+26	; 0x1a
    2fe6:	83 8d       	ldd	r24, Z+27	; 0x1b
    2fe8:	98 17       	cp	r25, r24
    2fea:	20 f0       	brcs	.+8      	; 0x2ff4 <xQueueGenericSend+0x62>
    2fec:	f2 e0       	ldi	r31, 0x02	; 2
    2fee:	7f 12       	cpse	r7, r31
    2ff0:	6e c0       	rjmp	.+220    	; 0x30ce <xQueueGenericSend+0x13c>
    2ff2:	7d c1       	rjmp	.+762    	; 0x32ee <xQueueGenericSend+0x35c>
    2ff4:	f8 01       	movw	r30, r16
    2ff6:	44 8d       	ldd	r20, Z+28	; 0x1c
    2ff8:	41 11       	cpse	r20, r1
    2ffa:	15 c0       	rjmp	.+42     	; 0x3026 <xQueueGenericSend+0x94>
    2ffc:	f8 01       	movw	r30, r16
    2ffe:	80 81       	ld	r24, Z
    3000:	91 81       	ldd	r25, Z+1	; 0x01
    3002:	89 2b       	or	r24, r25
    3004:	09 f0       	breq	.+2      	; 0x3008 <xQueueGenericSend+0x76>
    3006:	79 c1       	rjmp	.+754    	; 0x32fa <xQueueGenericSend+0x368>
    3008:	82 81       	ldd	r24, Z+2	; 0x02
    300a:	93 81       	ldd	r25, Z+3	; 0x03
    300c:	0e 94 13 26 	call	0x4c26	; 0x4c26 <xTaskPriorityDisinherit>
    3010:	f8 01       	movw	r30, r16
    3012:	13 82       	std	Z+3, r1	; 0x03
    3014:	12 82       	std	Z+2, r1	; 0x02
    3016:	92 8d       	ldd	r25, Z+26	; 0x1a
    3018:	9f 5f       	subi	r25, 0xFF	; 255
    301a:	92 8f       	std	Z+26, r25	; 0x1a
    301c:	91 89       	ldd	r25, Z+17	; 0x11
    301e:	99 23       	and	r25, r25
    3020:	09 f4       	brne	.+2      	; 0x3024 <xQueueGenericSend+0x92>
    3022:	4f c0       	rjmp	.+158    	; 0x30c2 <xQueueGenericSend+0x130>
    3024:	46 c0       	rjmp	.+140    	; 0x30b2 <xQueueGenericSend+0x120>
    3026:	71 10       	cpse	r7, r1
    3028:	1a c0       	rjmp	.+52     	; 0x305e <xQueueGenericSend+0xcc>
    302a:	50 e0       	ldi	r21, 0x00	; 0
    302c:	b5 01       	movw	r22, r10
    302e:	f8 01       	movw	r30, r16
    3030:	84 81       	ldd	r24, Z+4	; 0x04
    3032:	95 81       	ldd	r25, Z+5	; 0x05
    3034:	0e 94 2e 2f 	call	0x5e5c	; 0x5e5c <memcpy>
    3038:	f8 01       	movw	r30, r16
    303a:	24 8d       	ldd	r18, Z+28	; 0x1c
    303c:	84 81       	ldd	r24, Z+4	; 0x04
    303e:	95 81       	ldd	r25, Z+5	; 0x05
    3040:	82 0f       	add	r24, r18
    3042:	91 1d       	adc	r25, r1
    3044:	95 83       	std	Z+5, r25	; 0x05
    3046:	84 83       	std	Z+4, r24	; 0x04
    3048:	22 81       	ldd	r18, Z+2	; 0x02
    304a:	33 81       	ldd	r19, Z+3	; 0x03
    304c:	82 17       	cp	r24, r18
    304e:	93 07       	cpc	r25, r19
    3050:	08 f4       	brcc	.+2      	; 0x3054 <xQueueGenericSend+0xc2>
    3052:	53 c1       	rjmp	.+678    	; 0x32fa <xQueueGenericSend+0x368>
    3054:	80 81       	ld	r24, Z
    3056:	91 81       	ldd	r25, Z+1	; 0x01
    3058:	95 83       	std	Z+5, r25	; 0x05
    305a:	84 83       	std	Z+4, r24	; 0x04
    305c:	4e c1       	rjmp	.+668    	; 0x32fa <xQueueGenericSend+0x368>
    305e:	50 e0       	ldi	r21, 0x00	; 0
    3060:	b5 01       	movw	r22, r10
    3062:	f8 01       	movw	r30, r16
    3064:	86 81       	ldd	r24, Z+6	; 0x06
    3066:	97 81       	ldd	r25, Z+7	; 0x07
    3068:	0e 94 2e 2f 	call	0x5e5c	; 0x5e5c <memcpy>
    306c:	f8 01       	movw	r30, r16
    306e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3070:	90 e0       	ldi	r25, 0x00	; 0
    3072:	91 95       	neg	r25
    3074:	81 95       	neg	r24
    3076:	91 09       	sbc	r25, r1
    3078:	26 81       	ldd	r18, Z+6	; 0x06
    307a:	37 81       	ldd	r19, Z+7	; 0x07
    307c:	28 0f       	add	r18, r24
    307e:	39 1f       	adc	r19, r25
    3080:	37 83       	std	Z+7, r19	; 0x07
    3082:	26 83       	std	Z+6, r18	; 0x06
    3084:	40 81       	ld	r20, Z
    3086:	51 81       	ldd	r21, Z+1	; 0x01
    3088:	24 17       	cp	r18, r20
    308a:	35 07       	cpc	r19, r21
    308c:	30 f4       	brcc	.+12     	; 0x309a <xQueueGenericSend+0x108>
    308e:	22 81       	ldd	r18, Z+2	; 0x02
    3090:	33 81       	ldd	r19, Z+3	; 0x03
    3092:	82 0f       	add	r24, r18
    3094:	93 1f       	adc	r25, r19
    3096:	97 83       	std	Z+7, r25	; 0x07
    3098:	86 83       	std	Z+6, r24	; 0x06
    309a:	f2 e0       	ldi	r31, 0x02	; 2
    309c:	7f 12       	cpse	r7, r31
    309e:	2d c1       	rjmp	.+602    	; 0x32fa <xQueueGenericSend+0x368>
    30a0:	f8 01       	movw	r30, r16
    30a2:	82 8d       	ldd	r24, Z+26	; 0x1a
    30a4:	88 23       	and	r24, r24
    30a6:	09 f4       	brne	.+2      	; 0x30aa <xQueueGenericSend+0x118>
    30a8:	28 c1       	rjmp	.+592    	; 0x32fa <xQueueGenericSend+0x368>
    30aa:	82 8d       	ldd	r24, Z+26	; 0x1a
    30ac:	81 50       	subi	r24, 0x01	; 1
    30ae:	82 8f       	std	Z+26, r24	; 0x1a
    30b0:	24 c1       	rjmp	.+584    	; 0x32fa <xQueueGenericSend+0x368>
    30b2:	c8 01       	movw	r24, r16
    30b4:	41 96       	adiw	r24, 0x11	; 17
    30b6:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <xTaskRemoveFromEventList>
    30ba:	81 30       	cpi	r24, 0x01	; 1
    30bc:	21 f4       	brne	.+8      	; 0x30c6 <xQueueGenericSend+0x134>
    30be:	ba dc       	rcall	.-1676   	; 0x2a34 <vPortYield>
    30c0:	02 c0       	rjmp	.+4      	; 0x30c6 <xQueueGenericSend+0x134>
    30c2:	81 11       	cpse	r24, r1
    30c4:	b7 dc       	rcall	.-1682   	; 0x2a34 <vPortYield>
    30c6:	0f 90       	pop	r0
    30c8:	0f be       	out	0x3f, r0	; 63
    30ca:	81 e0       	ldi	r24, 0x01	; 1
    30cc:	1f c1       	rjmp	.+574    	; 0x330c <xQueueGenericSend+0x37a>
    30ce:	8c 81       	ldd	r24, Y+4	; 0x04
    30d0:	9d 81       	ldd	r25, Y+5	; 0x05
    30d2:	89 2b       	or	r24, r25
    30d4:	21 f4       	brne	.+8      	; 0x30de <xQueueGenericSend+0x14c>
    30d6:	0f 90       	pop	r0
    30d8:	0f be       	out	0x3f, r0	; 63
    30da:	80 e0       	ldi	r24, 0x00	; 0
    30dc:	17 c1       	rjmp	.+558    	; 0x330c <xQueueGenericSend+0x37a>
    30de:	81 10       	cpse	r8, r1
    30e0:	05 c0       	rjmp	.+10     	; 0x30ec <xQueueGenericSend+0x15a>
    30e2:	ce 01       	movw	r24, r28
    30e4:	01 96       	adiw	r24, 0x01	; 1
    30e6:	0e 94 67 25 	call	0x4ace	; 0x4ace <vTaskSetTimeOutState>
    30ea:	86 2c       	mov	r8, r6
    30ec:	0f 90       	pop	r0
    30ee:	0f be       	out	0x3f, r0	; 63
    30f0:	0e 94 2f 22 	call	0x445e	; 0x445e <vTaskSuspendAll>
    30f4:	0f b6       	in	r0, 0x3f	; 63
    30f6:	f8 94       	cli
    30f8:	0f 92       	push	r0
    30fa:	f8 01       	movw	r30, r16
    30fc:	85 8d       	ldd	r24, Z+29	; 0x1d
    30fe:	8f 3f       	cpi	r24, 0xFF	; 255
    3100:	09 f4       	brne	.+2      	; 0x3104 <xQueueGenericSend+0x172>
    3102:	15 8e       	std	Z+29, r1	; 0x1d
    3104:	f8 01       	movw	r30, r16
    3106:	86 8d       	ldd	r24, Z+30	; 0x1e
    3108:	8f 3f       	cpi	r24, 0xFF	; 255
    310a:	09 f4       	brne	.+2      	; 0x310e <xQueueGenericSend+0x17c>
    310c:	16 8e       	std	Z+30, r1	; 0x1e
    310e:	0f 90       	pop	r0
    3110:	0f be       	out	0x3f, r0	; 63
    3112:	be 01       	movw	r22, r28
    3114:	6c 5f       	subi	r22, 0xFC	; 252
    3116:	7f 4f       	sbci	r23, 0xFF	; 255
    3118:	ce 01       	movw	r24, r28
    311a:	01 96       	adiw	r24, 0x01	; 1
    311c:	0e 94 72 25 	call	0x4ae4	; 0x4ae4 <xTaskCheckForTimeOut>
    3120:	81 11       	cpse	r24, r1
    3122:	96 c0       	rjmp	.+300    	; 0x3250 <xQueueGenericSend+0x2be>
    3124:	0f b6       	in	r0, 0x3f	; 63
    3126:	f8 94       	cli
    3128:	0f 92       	push	r0
    312a:	f8 01       	movw	r30, r16
    312c:	92 8d       	ldd	r25, Z+26	; 0x1a
    312e:	83 8d       	ldd	r24, Z+27	; 0x1b
    3130:	0f 90       	pop	r0
    3132:	0f be       	out	0x3f, r0	; 63
    3134:	98 13       	cpse	r25, r24
    3136:	4a c0       	rjmp	.+148    	; 0x31cc <xQueueGenericSend+0x23a>
    3138:	6c 81       	ldd	r22, Y+4	; 0x04
    313a:	7d 81       	ldd	r23, Y+5	; 0x05
    313c:	c7 01       	movw	r24, r14
    313e:	0e 94 c3 24 	call	0x4986	; 0x4986 <vTaskPlaceOnEventList>
    3142:	0f b6       	in	r0, 0x3f	; 63
    3144:	f8 94       	cli
    3146:	0f 92       	push	r0
    3148:	f8 01       	movw	r30, r16
    314a:	86 8d       	ldd	r24, Z+30	; 0x1e
    314c:	18 16       	cp	r1, r24
    314e:	ac f4       	brge	.+42     	; 0x317a <xQueueGenericSend+0x1e8>
    3150:	81 89       	ldd	r24, Z+17	; 0x11
    3152:	81 11       	cpse	r24, r1
    3154:	05 c0       	rjmp	.+10     	; 0x3160 <xQueueGenericSend+0x1ce>
    3156:	11 c0       	rjmp	.+34     	; 0x317a <xQueueGenericSend+0x1e8>
    3158:	f8 01       	movw	r30, r16
    315a:	81 89       	ldd	r24, Z+17	; 0x11
    315c:	88 23       	and	r24, r24
    315e:	69 f0       	breq	.+26     	; 0x317a <xQueueGenericSend+0x1e8>
    3160:	c6 01       	movw	r24, r12
    3162:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <xTaskRemoveFromEventList>
    3166:	81 11       	cpse	r24, r1
    3168:	0e 94 ad 25 	call	0x4b5a	; 0x4b5a <vTaskMissedYield>
    316c:	f8 01       	movw	r30, r16
    316e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3170:	81 50       	subi	r24, 0x01	; 1
    3172:	86 8f       	std	Z+30, r24	; 0x1e
    3174:	86 8d       	ldd	r24, Z+30	; 0x1e
    3176:	18 16       	cp	r1, r24
    3178:	7c f3       	brlt	.-34     	; 0x3158 <xQueueGenericSend+0x1c6>
    317a:	f8 01       	movw	r30, r16
    317c:	96 8e       	std	Z+30, r9	; 0x1e
    317e:	0f 90       	pop	r0
    3180:	0f be       	out	0x3f, r0	; 63
    3182:	0f b6       	in	r0, 0x3f	; 63
    3184:	f8 94       	cli
    3186:	0f 92       	push	r0
    3188:	85 8d       	ldd	r24, Z+29	; 0x1d
    318a:	18 16       	cp	r1, r24
    318c:	ac f4       	brge	.+42     	; 0x31b8 <xQueueGenericSend+0x226>
    318e:	80 85       	ldd	r24, Z+8	; 0x08
    3190:	81 11       	cpse	r24, r1
    3192:	05 c0       	rjmp	.+10     	; 0x319e <xQueueGenericSend+0x20c>
    3194:	11 c0       	rjmp	.+34     	; 0x31b8 <xQueueGenericSend+0x226>
    3196:	f8 01       	movw	r30, r16
    3198:	80 85       	ldd	r24, Z+8	; 0x08
    319a:	88 23       	and	r24, r24
    319c:	69 f0       	breq	.+26     	; 0x31b8 <xQueueGenericSend+0x226>
    319e:	c7 01       	movw	r24, r14
    31a0:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <xTaskRemoveFromEventList>
    31a4:	81 11       	cpse	r24, r1
    31a6:	0e 94 ad 25 	call	0x4b5a	; 0x4b5a <vTaskMissedYield>
    31aa:	f8 01       	movw	r30, r16
    31ac:	85 8d       	ldd	r24, Z+29	; 0x1d
    31ae:	81 50       	subi	r24, 0x01	; 1
    31b0:	85 8f       	std	Z+29, r24	; 0x1d
    31b2:	85 8d       	ldd	r24, Z+29	; 0x1d
    31b4:	18 16       	cp	r1, r24
    31b6:	7c f3       	brlt	.-34     	; 0x3196 <xQueueGenericSend+0x204>
    31b8:	f8 01       	movw	r30, r16
    31ba:	95 8e       	std	Z+29, r9	; 0x1d
    31bc:	0f 90       	pop	r0
    31be:	0f be       	out	0x3f, r0	; 63
    31c0:	0e 94 35 22 	call	0x446a	; 0x446a <xTaskResumeAll>
    31c4:	81 11       	cpse	r24, r1
    31c6:	0a cf       	rjmp	.-492    	; 0x2fdc <xQueueGenericSend+0x4a>
    31c8:	35 dc       	rcall	.-1942   	; 0x2a34 <vPortYield>
    31ca:	08 cf       	rjmp	.-496    	; 0x2fdc <xQueueGenericSend+0x4a>
    31cc:	0f b6       	in	r0, 0x3f	; 63
    31ce:	f8 94       	cli
    31d0:	0f 92       	push	r0
    31d2:	f8 01       	movw	r30, r16
    31d4:	86 8d       	ldd	r24, Z+30	; 0x1e
    31d6:	18 16       	cp	r1, r24
    31d8:	ac f4       	brge	.+42     	; 0x3204 <xQueueGenericSend+0x272>
    31da:	81 89       	ldd	r24, Z+17	; 0x11
    31dc:	81 11       	cpse	r24, r1
    31de:	05 c0       	rjmp	.+10     	; 0x31ea <xQueueGenericSend+0x258>
    31e0:	11 c0       	rjmp	.+34     	; 0x3204 <xQueueGenericSend+0x272>
    31e2:	f8 01       	movw	r30, r16
    31e4:	81 89       	ldd	r24, Z+17	; 0x11
    31e6:	88 23       	and	r24, r24
    31e8:	69 f0       	breq	.+26     	; 0x3204 <xQueueGenericSend+0x272>
    31ea:	c6 01       	movw	r24, r12
    31ec:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <xTaskRemoveFromEventList>
    31f0:	81 11       	cpse	r24, r1
    31f2:	0e 94 ad 25 	call	0x4b5a	; 0x4b5a <vTaskMissedYield>
    31f6:	f8 01       	movw	r30, r16
    31f8:	86 8d       	ldd	r24, Z+30	; 0x1e
    31fa:	81 50       	subi	r24, 0x01	; 1
    31fc:	86 8f       	std	Z+30, r24	; 0x1e
    31fe:	86 8d       	ldd	r24, Z+30	; 0x1e
    3200:	18 16       	cp	r1, r24
    3202:	7c f3       	brlt	.-34     	; 0x31e2 <xQueueGenericSend+0x250>
    3204:	f8 01       	movw	r30, r16
    3206:	96 8e       	std	Z+30, r9	; 0x1e
    3208:	0f 90       	pop	r0
    320a:	0f be       	out	0x3f, r0	; 63
    320c:	0f b6       	in	r0, 0x3f	; 63
    320e:	f8 94       	cli
    3210:	0f 92       	push	r0
    3212:	85 8d       	ldd	r24, Z+29	; 0x1d
    3214:	18 16       	cp	r1, r24
    3216:	ac f4       	brge	.+42     	; 0x3242 <xQueueGenericSend+0x2b0>
    3218:	80 85       	ldd	r24, Z+8	; 0x08
    321a:	81 11       	cpse	r24, r1
    321c:	05 c0       	rjmp	.+10     	; 0x3228 <xQueueGenericSend+0x296>
    321e:	11 c0       	rjmp	.+34     	; 0x3242 <xQueueGenericSend+0x2b0>
    3220:	f8 01       	movw	r30, r16
    3222:	80 85       	ldd	r24, Z+8	; 0x08
    3224:	88 23       	and	r24, r24
    3226:	69 f0       	breq	.+26     	; 0x3242 <xQueueGenericSend+0x2b0>
    3228:	c7 01       	movw	r24, r14
    322a:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <xTaskRemoveFromEventList>
    322e:	81 11       	cpse	r24, r1
    3230:	0e 94 ad 25 	call	0x4b5a	; 0x4b5a <vTaskMissedYield>
    3234:	f8 01       	movw	r30, r16
    3236:	95 8d       	ldd	r25, Z+29	; 0x1d
    3238:	91 50       	subi	r25, 0x01	; 1
    323a:	95 8f       	std	Z+29, r25	; 0x1d
    323c:	85 8d       	ldd	r24, Z+29	; 0x1d
    323e:	18 16       	cp	r1, r24
    3240:	7c f3       	brlt	.-34     	; 0x3220 <xQueueGenericSend+0x28e>
    3242:	f8 01       	movw	r30, r16
    3244:	95 8e       	std	Z+29, r9	; 0x1d
    3246:	0f 90       	pop	r0
    3248:	0f be       	out	0x3f, r0	; 63
    324a:	0e 94 35 22 	call	0x446a	; 0x446a <xTaskResumeAll>
    324e:	c6 ce       	rjmp	.-628    	; 0x2fdc <xQueueGenericSend+0x4a>
    3250:	0f b6       	in	r0, 0x3f	; 63
    3252:	f8 94       	cli
    3254:	0f 92       	push	r0
    3256:	f8 01       	movw	r30, r16
    3258:	86 8d       	ldd	r24, Z+30	; 0x1e
    325a:	18 16       	cp	r1, r24
    325c:	d4 f4       	brge	.+52     	; 0x3292 <xQueueGenericSend+0x300>
    325e:	81 89       	ldd	r24, Z+17	; 0x11
    3260:	81 11       	cpse	r24, r1
    3262:	06 c0       	rjmp	.+12     	; 0x3270 <xQueueGenericSend+0x2de>
    3264:	16 c0       	rjmp	.+44     	; 0x3292 <xQueueGenericSend+0x300>
    3266:	f8 01       	movw	r30, r16
    3268:	91 89       	ldd	r25, Z+17	; 0x11
    326a:	91 11       	cpse	r25, r1
    326c:	05 c0       	rjmp	.+10     	; 0x3278 <xQueueGenericSend+0x2e6>
    326e:	11 c0       	rjmp	.+34     	; 0x3292 <xQueueGenericSend+0x300>
    3270:	78 01       	movw	r14, r16
    3272:	f1 e1       	ldi	r31, 0x11	; 17
    3274:	ef 0e       	add	r14, r31
    3276:	f1 1c       	adc	r15, r1
    3278:	c7 01       	movw	r24, r14
    327a:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <xTaskRemoveFromEventList>
    327e:	81 11       	cpse	r24, r1
    3280:	0e 94 ad 25 	call	0x4b5a	; 0x4b5a <vTaskMissedYield>
    3284:	f8 01       	movw	r30, r16
    3286:	96 8d       	ldd	r25, Z+30	; 0x1e
    3288:	91 50       	subi	r25, 0x01	; 1
    328a:	96 8f       	std	Z+30, r25	; 0x1e
    328c:	96 8d       	ldd	r25, Z+30	; 0x1e
    328e:	19 16       	cp	r1, r25
    3290:	54 f3       	brlt	.-44     	; 0x3266 <xQueueGenericSend+0x2d4>
    3292:	8f ef       	ldi	r24, 0xFF	; 255
    3294:	f8 01       	movw	r30, r16
    3296:	86 8f       	std	Z+30, r24	; 0x1e
    3298:	0f 90       	pop	r0
    329a:	0f be       	out	0x3f, r0	; 63
    329c:	0f b6       	in	r0, 0x3f	; 63
    329e:	f8 94       	cli
    32a0:	0f 92       	push	r0
    32a2:	85 8d       	ldd	r24, Z+29	; 0x1d
    32a4:	18 16       	cp	r1, r24
    32a6:	d4 f4       	brge	.+52     	; 0x32dc <xQueueGenericSend+0x34a>
    32a8:	80 85       	ldd	r24, Z+8	; 0x08
    32aa:	81 11       	cpse	r24, r1
    32ac:	06 c0       	rjmp	.+12     	; 0x32ba <xQueueGenericSend+0x328>
    32ae:	16 c0       	rjmp	.+44     	; 0x32dc <xQueueGenericSend+0x34a>
    32b0:	f8 01       	movw	r30, r16
    32b2:	90 85       	ldd	r25, Z+8	; 0x08
    32b4:	91 11       	cpse	r25, r1
    32b6:	05 c0       	rjmp	.+10     	; 0x32c2 <xQueueGenericSend+0x330>
    32b8:	11 c0       	rjmp	.+34     	; 0x32dc <xQueueGenericSend+0x34a>
    32ba:	78 01       	movw	r14, r16
    32bc:	f8 e0       	ldi	r31, 0x08	; 8
    32be:	ef 0e       	add	r14, r31
    32c0:	f1 1c       	adc	r15, r1
    32c2:	c7 01       	movw	r24, r14
    32c4:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <xTaskRemoveFromEventList>
    32c8:	81 11       	cpse	r24, r1
    32ca:	0e 94 ad 25 	call	0x4b5a	; 0x4b5a <vTaskMissedYield>
    32ce:	f8 01       	movw	r30, r16
    32d0:	95 8d       	ldd	r25, Z+29	; 0x1d
    32d2:	91 50       	subi	r25, 0x01	; 1
    32d4:	95 8f       	std	Z+29, r25	; 0x1d
    32d6:	95 8d       	ldd	r25, Z+29	; 0x1d
    32d8:	19 16       	cp	r1, r25
    32da:	54 f3       	brlt	.-44     	; 0x32b0 <xQueueGenericSend+0x31e>
    32dc:	8f ef       	ldi	r24, 0xFF	; 255
    32de:	f8 01       	movw	r30, r16
    32e0:	85 8f       	std	Z+29, r24	; 0x1d
    32e2:	0f 90       	pop	r0
    32e4:	0f be       	out	0x3f, r0	; 63
    32e6:	0e 94 35 22 	call	0x446a	; 0x446a <xTaskResumeAll>
    32ea:	80 e0       	ldi	r24, 0x00	; 0
    32ec:	0f c0       	rjmp	.+30     	; 0x330c <xQueueGenericSend+0x37a>
    32ee:	f8 01       	movw	r30, r16
    32f0:	44 8d       	ldd	r20, Z+28	; 0x1c
    32f2:	44 23       	and	r20, r20
    32f4:	09 f4       	brne	.+2      	; 0x32f8 <xQueueGenericSend+0x366>
    32f6:	82 ce       	rjmp	.-764    	; 0x2ffc <xQueueGenericSend+0x6a>
    32f8:	b2 ce       	rjmp	.-668    	; 0x305e <xQueueGenericSend+0xcc>
    32fa:	f8 01       	movw	r30, r16
    32fc:	82 8d       	ldd	r24, Z+26	; 0x1a
    32fe:	8f 5f       	subi	r24, 0xFF	; 255
    3300:	82 8f       	std	Z+26, r24	; 0x1a
    3302:	81 89       	ldd	r24, Z+17	; 0x11
    3304:	88 23       	and	r24, r24
    3306:	09 f4       	brne	.+2      	; 0x330a <xQueueGenericSend+0x378>
    3308:	de ce       	rjmp	.-580    	; 0x30c6 <xQueueGenericSend+0x134>
    330a:	d3 ce       	rjmp	.-602    	; 0x30b2 <xQueueGenericSend+0x120>
    330c:	0f 90       	pop	r0
    330e:	0f 90       	pop	r0
    3310:	0f 90       	pop	r0
    3312:	0f 90       	pop	r0
    3314:	0f 90       	pop	r0
    3316:	df 91       	pop	r29
    3318:	cf 91       	pop	r28
    331a:	1f 91       	pop	r17
    331c:	0f 91       	pop	r16
    331e:	ff 90       	pop	r15
    3320:	ef 90       	pop	r14
    3322:	df 90       	pop	r13
    3324:	cf 90       	pop	r12
    3326:	bf 90       	pop	r11
    3328:	af 90       	pop	r10
    332a:	9f 90       	pop	r9
    332c:	8f 90       	pop	r8
    332e:	7f 90       	pop	r7
    3330:	6f 90       	pop	r6
    3332:	08 95       	ret

00003334 <xQueueGive>:
    3334:	9f 92       	push	r9
    3336:	af 92       	push	r10
    3338:	bf 92       	push	r11
    333a:	cf 92       	push	r12
    333c:	df 92       	push	r13
    333e:	ef 92       	push	r14
    3340:	ff 92       	push	r15
    3342:	0f 93       	push	r16
    3344:	1f 93       	push	r17
    3346:	cf 93       	push	r28
    3348:	df 93       	push	r29
    334a:	00 d0       	rcall	.+0      	; 0x334c <xQueueGive+0x18>
    334c:	1f 92       	push	r1
    334e:	1f 92       	push	r1
    3350:	cd b7       	in	r28, 0x3d	; 61
    3352:	de b7       	in	r29, 0x3e	; 62
    3354:	8c 01       	movw	r16, r24
    3356:	7d 83       	std	Y+5, r23	; 0x05
    3358:	6c 83       	std	Y+4, r22	; 0x04
    335a:	a1 2c       	mov	r10, r1
    335c:	99 24       	eor	r9, r9
    335e:	93 94       	inc	r9
    3360:	bb 24       	eor	r11, r11
    3362:	ba 94       	dec	r11
    3364:	7c 01       	movw	r14, r24
    3366:	88 e0       	ldi	r24, 0x08	; 8
    3368:	e8 0e       	add	r14, r24
    336a:	f1 1c       	adc	r15, r1
    336c:	68 01       	movw	r12, r16
    336e:	e1 e1       	ldi	r30, 0x11	; 17
    3370:	ce 0e       	add	r12, r30
    3372:	d1 1c       	adc	r13, r1
    3374:	0f b6       	in	r0, 0x3f	; 63
    3376:	f8 94       	cli
    3378:	0f 92       	push	r0
    337a:	f8 01       	movw	r30, r16
    337c:	92 8d       	ldd	r25, Z+26	; 0x1a
    337e:	83 8d       	ldd	r24, Z+27	; 0x1b
    3380:	98 17       	cp	r25, r24
    3382:	00 f5       	brcc	.+64     	; 0x33c4 <xQueueGive+0x90>
    3384:	80 81       	ld	r24, Z
    3386:	91 81       	ldd	r25, Z+1	; 0x01
    3388:	89 2b       	or	r24, r25
    338a:	09 f0       	breq	.+2      	; 0x338e <xQueueGive+0x5a>
    338c:	28 c1       	rjmp	.+592    	; 0x35de <xQueueGive+0x2aa>
    338e:	82 81       	ldd	r24, Z+2	; 0x02
    3390:	93 81       	ldd	r25, Z+3	; 0x03
    3392:	0e 94 13 26 	call	0x4c26	; 0x4c26 <xTaskPriorityDisinherit>
    3396:	f8 01       	movw	r30, r16
    3398:	13 82       	std	Z+3, r1	; 0x03
    339a:	12 82       	std	Z+2, r1	; 0x02
    339c:	92 8d       	ldd	r25, Z+26	; 0x1a
    339e:	9f 5f       	subi	r25, 0xFF	; 255
    33a0:	92 8f       	std	Z+26, r25	; 0x1a
    33a2:	91 89       	ldd	r25, Z+17	; 0x11
    33a4:	99 23       	and	r25, r25
    33a6:	41 f0       	breq	.+16     	; 0x33b8 <xQueueGive+0x84>
    33a8:	c8 01       	movw	r24, r16
    33aa:	41 96       	adiw	r24, 0x11	; 17
    33ac:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <xTaskRemoveFromEventList>
    33b0:	81 30       	cpi	r24, 0x01	; 1
    33b2:	21 f4       	brne	.+8      	; 0x33bc <xQueueGive+0x88>
    33b4:	3f db       	rcall	.-2434   	; 0x2a34 <vPortYield>
    33b6:	02 c0       	rjmp	.+4      	; 0x33bc <xQueueGive+0x88>
    33b8:	81 11       	cpse	r24, r1
    33ba:	3c db       	rcall	.-2440   	; 0x2a34 <vPortYield>
    33bc:	0f 90       	pop	r0
    33be:	0f be       	out	0x3f, r0	; 63
    33c0:	81 e0       	ldi	r24, 0x01	; 1
    33c2:	16 c1       	rjmp	.+556    	; 0x35f0 <xQueueGive+0x2bc>
    33c4:	8c 81       	ldd	r24, Y+4	; 0x04
    33c6:	9d 81       	ldd	r25, Y+5	; 0x05
    33c8:	89 2b       	or	r24, r25
    33ca:	21 f4       	brne	.+8      	; 0x33d4 <xQueueGive+0xa0>
    33cc:	0f 90       	pop	r0
    33ce:	0f be       	out	0x3f, r0	; 63
    33d0:	80 e0       	ldi	r24, 0x00	; 0
    33d2:	0e c1       	rjmp	.+540    	; 0x35f0 <xQueueGive+0x2bc>
    33d4:	a1 10       	cpse	r10, r1
    33d6:	05 c0       	rjmp	.+10     	; 0x33e2 <xQueueGive+0xae>
    33d8:	ce 01       	movw	r24, r28
    33da:	01 96       	adiw	r24, 0x01	; 1
    33dc:	0e 94 67 25 	call	0x4ace	; 0x4ace <vTaskSetTimeOutState>
    33e0:	a9 2c       	mov	r10, r9
    33e2:	0f 90       	pop	r0
    33e4:	0f be       	out	0x3f, r0	; 63
    33e6:	0e 94 2f 22 	call	0x445e	; 0x445e <vTaskSuspendAll>
    33ea:	0f b6       	in	r0, 0x3f	; 63
    33ec:	f8 94       	cli
    33ee:	0f 92       	push	r0
    33f0:	f8 01       	movw	r30, r16
    33f2:	85 8d       	ldd	r24, Z+29	; 0x1d
    33f4:	8f 3f       	cpi	r24, 0xFF	; 255
    33f6:	09 f4       	brne	.+2      	; 0x33fa <xQueueGive+0xc6>
    33f8:	15 8e       	std	Z+29, r1	; 0x1d
    33fa:	f8 01       	movw	r30, r16
    33fc:	86 8d       	ldd	r24, Z+30	; 0x1e
    33fe:	8f 3f       	cpi	r24, 0xFF	; 255
    3400:	09 f4       	brne	.+2      	; 0x3404 <xQueueGive+0xd0>
    3402:	16 8e       	std	Z+30, r1	; 0x1e
    3404:	0f 90       	pop	r0
    3406:	0f be       	out	0x3f, r0	; 63
    3408:	be 01       	movw	r22, r28
    340a:	6c 5f       	subi	r22, 0xFC	; 252
    340c:	7f 4f       	sbci	r23, 0xFF	; 255
    340e:	ce 01       	movw	r24, r28
    3410:	01 96       	adiw	r24, 0x01	; 1
    3412:	0e 94 72 25 	call	0x4ae4	; 0x4ae4 <xTaskCheckForTimeOut>
    3416:	81 11       	cpse	r24, r1
    3418:	94 c0       	rjmp	.+296    	; 0x3542 <xQueueGive+0x20e>
    341a:	0f b6       	in	r0, 0x3f	; 63
    341c:	f8 94       	cli
    341e:	0f 92       	push	r0
    3420:	f8 01       	movw	r30, r16
    3422:	92 8d       	ldd	r25, Z+26	; 0x1a
    3424:	83 8d       	ldd	r24, Z+27	; 0x1b
    3426:	0f 90       	pop	r0
    3428:	0f be       	out	0x3f, r0	; 63
    342a:	98 13       	cpse	r25, r24
    342c:	49 c0       	rjmp	.+146    	; 0x34c0 <xQueueGive+0x18c>
    342e:	6c 81       	ldd	r22, Y+4	; 0x04
    3430:	7d 81       	ldd	r23, Y+5	; 0x05
    3432:	c7 01       	movw	r24, r14
    3434:	0e 94 c3 24 	call	0x4986	; 0x4986 <vTaskPlaceOnEventList>
    3438:	0f b6       	in	r0, 0x3f	; 63
    343a:	f8 94       	cli
    343c:	0f 92       	push	r0
    343e:	f8 01       	movw	r30, r16
    3440:	86 8d       	ldd	r24, Z+30	; 0x1e
    3442:	18 16       	cp	r1, r24
    3444:	ac f4       	brge	.+42     	; 0x3470 <xQueueGive+0x13c>
    3446:	81 89       	ldd	r24, Z+17	; 0x11
    3448:	81 11       	cpse	r24, r1
    344a:	05 c0       	rjmp	.+10     	; 0x3456 <xQueueGive+0x122>
    344c:	11 c0       	rjmp	.+34     	; 0x3470 <xQueueGive+0x13c>
    344e:	f8 01       	movw	r30, r16
    3450:	81 89       	ldd	r24, Z+17	; 0x11
    3452:	88 23       	and	r24, r24
    3454:	69 f0       	breq	.+26     	; 0x3470 <xQueueGive+0x13c>
    3456:	c6 01       	movw	r24, r12
    3458:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <xTaskRemoveFromEventList>
    345c:	81 11       	cpse	r24, r1
    345e:	0e 94 ad 25 	call	0x4b5a	; 0x4b5a <vTaskMissedYield>
    3462:	f8 01       	movw	r30, r16
    3464:	86 8d       	ldd	r24, Z+30	; 0x1e
    3466:	81 50       	subi	r24, 0x01	; 1
    3468:	86 8f       	std	Z+30, r24	; 0x1e
    346a:	86 8d       	ldd	r24, Z+30	; 0x1e
    346c:	18 16       	cp	r1, r24
    346e:	7c f3       	brlt	.-34     	; 0x344e <xQueueGive+0x11a>
    3470:	f8 01       	movw	r30, r16
    3472:	b6 8e       	std	Z+30, r11	; 0x1e
    3474:	0f 90       	pop	r0
    3476:	0f be       	out	0x3f, r0	; 63
    3478:	0f b6       	in	r0, 0x3f	; 63
    347a:	f8 94       	cli
    347c:	0f 92       	push	r0
    347e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3480:	18 16       	cp	r1, r24
    3482:	ac f4       	brge	.+42     	; 0x34ae <xQueueGive+0x17a>
    3484:	80 85       	ldd	r24, Z+8	; 0x08
    3486:	81 11       	cpse	r24, r1
    3488:	05 c0       	rjmp	.+10     	; 0x3494 <xQueueGive+0x160>
    348a:	11 c0       	rjmp	.+34     	; 0x34ae <xQueueGive+0x17a>
    348c:	f8 01       	movw	r30, r16
    348e:	80 85       	ldd	r24, Z+8	; 0x08
    3490:	88 23       	and	r24, r24
    3492:	69 f0       	breq	.+26     	; 0x34ae <xQueueGive+0x17a>
    3494:	c7 01       	movw	r24, r14
    3496:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <xTaskRemoveFromEventList>
    349a:	81 11       	cpse	r24, r1
    349c:	0e 94 ad 25 	call	0x4b5a	; 0x4b5a <vTaskMissedYield>
    34a0:	f8 01       	movw	r30, r16
    34a2:	85 8d       	ldd	r24, Z+29	; 0x1d
    34a4:	81 50       	subi	r24, 0x01	; 1
    34a6:	85 8f       	std	Z+29, r24	; 0x1d
    34a8:	85 8d       	ldd	r24, Z+29	; 0x1d
    34aa:	18 16       	cp	r1, r24
    34ac:	7c f3       	brlt	.-34     	; 0x348c <xQueueGive+0x158>
    34ae:	f8 01       	movw	r30, r16
    34b0:	b5 8e       	std	Z+29, r11	; 0x1d
    34b2:	0f 90       	pop	r0
    34b4:	0f be       	out	0x3f, r0	; 63
    34b6:	d9 d7       	rcall	.+4018   	; 0x446a <xTaskResumeAll>
    34b8:	81 11       	cpse	r24, r1
    34ba:	5c cf       	rjmp	.-328    	; 0x3374 <xQueueGive+0x40>
    34bc:	bb da       	rcall	.-2698   	; 0x2a34 <vPortYield>
    34be:	5a cf       	rjmp	.-332    	; 0x3374 <xQueueGive+0x40>
    34c0:	0f b6       	in	r0, 0x3f	; 63
    34c2:	f8 94       	cli
    34c4:	0f 92       	push	r0
    34c6:	f8 01       	movw	r30, r16
    34c8:	86 8d       	ldd	r24, Z+30	; 0x1e
    34ca:	18 16       	cp	r1, r24
    34cc:	ac f4       	brge	.+42     	; 0x34f8 <xQueueGive+0x1c4>
    34ce:	81 89       	ldd	r24, Z+17	; 0x11
    34d0:	81 11       	cpse	r24, r1
    34d2:	05 c0       	rjmp	.+10     	; 0x34de <xQueueGive+0x1aa>
    34d4:	11 c0       	rjmp	.+34     	; 0x34f8 <xQueueGive+0x1c4>
    34d6:	f8 01       	movw	r30, r16
    34d8:	81 89       	ldd	r24, Z+17	; 0x11
    34da:	88 23       	and	r24, r24
    34dc:	69 f0       	breq	.+26     	; 0x34f8 <xQueueGive+0x1c4>
    34de:	c6 01       	movw	r24, r12
    34e0:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <xTaskRemoveFromEventList>
    34e4:	81 11       	cpse	r24, r1
    34e6:	0e 94 ad 25 	call	0x4b5a	; 0x4b5a <vTaskMissedYield>
    34ea:	f8 01       	movw	r30, r16
    34ec:	96 8d       	ldd	r25, Z+30	; 0x1e
    34ee:	91 50       	subi	r25, 0x01	; 1
    34f0:	96 8f       	std	Z+30, r25	; 0x1e
    34f2:	86 8d       	ldd	r24, Z+30	; 0x1e
    34f4:	18 16       	cp	r1, r24
    34f6:	7c f3       	brlt	.-34     	; 0x34d6 <xQueueGive+0x1a2>
    34f8:	f8 01       	movw	r30, r16
    34fa:	b6 8e       	std	Z+30, r11	; 0x1e
    34fc:	0f 90       	pop	r0
    34fe:	0f be       	out	0x3f, r0	; 63
    3500:	0f b6       	in	r0, 0x3f	; 63
    3502:	f8 94       	cli
    3504:	0f 92       	push	r0
    3506:	85 8d       	ldd	r24, Z+29	; 0x1d
    3508:	18 16       	cp	r1, r24
    350a:	ac f4       	brge	.+42     	; 0x3536 <xQueueGive+0x202>
    350c:	80 85       	ldd	r24, Z+8	; 0x08
    350e:	81 11       	cpse	r24, r1
    3510:	05 c0       	rjmp	.+10     	; 0x351c <xQueueGive+0x1e8>
    3512:	11 c0       	rjmp	.+34     	; 0x3536 <xQueueGive+0x202>
    3514:	f8 01       	movw	r30, r16
    3516:	80 85       	ldd	r24, Z+8	; 0x08
    3518:	88 23       	and	r24, r24
    351a:	69 f0       	breq	.+26     	; 0x3536 <xQueueGive+0x202>
    351c:	c7 01       	movw	r24, r14
    351e:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <xTaskRemoveFromEventList>
    3522:	81 11       	cpse	r24, r1
    3524:	0e 94 ad 25 	call	0x4b5a	; 0x4b5a <vTaskMissedYield>
    3528:	f8 01       	movw	r30, r16
    352a:	95 8d       	ldd	r25, Z+29	; 0x1d
    352c:	91 50       	subi	r25, 0x01	; 1
    352e:	95 8f       	std	Z+29, r25	; 0x1d
    3530:	85 8d       	ldd	r24, Z+29	; 0x1d
    3532:	18 16       	cp	r1, r24
    3534:	7c f3       	brlt	.-34     	; 0x3514 <xQueueGive+0x1e0>
    3536:	f8 01       	movw	r30, r16
    3538:	b5 8e       	std	Z+29, r11	; 0x1d
    353a:	0f 90       	pop	r0
    353c:	0f be       	out	0x3f, r0	; 63
    353e:	95 d7       	rcall	.+3882   	; 0x446a <xTaskResumeAll>
    3540:	19 cf       	rjmp	.-462    	; 0x3374 <xQueueGive+0x40>
    3542:	0f b6       	in	r0, 0x3f	; 63
    3544:	f8 94       	cli
    3546:	0f 92       	push	r0
    3548:	f8 01       	movw	r30, r16
    354a:	86 8d       	ldd	r24, Z+30	; 0x1e
    354c:	18 16       	cp	r1, r24
    354e:	d4 f4       	brge	.+52     	; 0x3584 <xQueueGive+0x250>
    3550:	81 89       	ldd	r24, Z+17	; 0x11
    3552:	81 11       	cpse	r24, r1
    3554:	06 c0       	rjmp	.+12     	; 0x3562 <xQueueGive+0x22e>
    3556:	16 c0       	rjmp	.+44     	; 0x3584 <xQueueGive+0x250>
    3558:	f8 01       	movw	r30, r16
    355a:	91 89       	ldd	r25, Z+17	; 0x11
    355c:	91 11       	cpse	r25, r1
    355e:	05 c0       	rjmp	.+10     	; 0x356a <xQueueGive+0x236>
    3560:	11 c0       	rjmp	.+34     	; 0x3584 <xQueueGive+0x250>
    3562:	78 01       	movw	r14, r16
    3564:	f1 e1       	ldi	r31, 0x11	; 17
    3566:	ef 0e       	add	r14, r31
    3568:	f1 1c       	adc	r15, r1
    356a:	c7 01       	movw	r24, r14
    356c:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <xTaskRemoveFromEventList>
    3570:	81 11       	cpse	r24, r1
    3572:	0e 94 ad 25 	call	0x4b5a	; 0x4b5a <vTaskMissedYield>
    3576:	f8 01       	movw	r30, r16
    3578:	96 8d       	ldd	r25, Z+30	; 0x1e
    357a:	91 50       	subi	r25, 0x01	; 1
    357c:	96 8f       	std	Z+30, r25	; 0x1e
    357e:	96 8d       	ldd	r25, Z+30	; 0x1e
    3580:	19 16       	cp	r1, r25
    3582:	54 f3       	brlt	.-44     	; 0x3558 <xQueueGive+0x224>
    3584:	8f ef       	ldi	r24, 0xFF	; 255
    3586:	f8 01       	movw	r30, r16
    3588:	86 8f       	std	Z+30, r24	; 0x1e
    358a:	0f 90       	pop	r0
    358c:	0f be       	out	0x3f, r0	; 63
    358e:	0f b6       	in	r0, 0x3f	; 63
    3590:	f8 94       	cli
    3592:	0f 92       	push	r0
    3594:	85 8d       	ldd	r24, Z+29	; 0x1d
    3596:	18 16       	cp	r1, r24
    3598:	d4 f4       	brge	.+52     	; 0x35ce <xQueueGive+0x29a>
    359a:	80 85       	ldd	r24, Z+8	; 0x08
    359c:	81 11       	cpse	r24, r1
    359e:	06 c0       	rjmp	.+12     	; 0x35ac <xQueueGive+0x278>
    35a0:	16 c0       	rjmp	.+44     	; 0x35ce <xQueueGive+0x29a>
    35a2:	f8 01       	movw	r30, r16
    35a4:	90 85       	ldd	r25, Z+8	; 0x08
    35a6:	91 11       	cpse	r25, r1
    35a8:	05 c0       	rjmp	.+10     	; 0x35b4 <xQueueGive+0x280>
    35aa:	11 c0       	rjmp	.+34     	; 0x35ce <xQueueGive+0x29a>
    35ac:	78 01       	movw	r14, r16
    35ae:	f8 e0       	ldi	r31, 0x08	; 8
    35b0:	ef 0e       	add	r14, r31
    35b2:	f1 1c       	adc	r15, r1
    35b4:	c7 01       	movw	r24, r14
    35b6:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <xTaskRemoveFromEventList>
    35ba:	81 11       	cpse	r24, r1
    35bc:	0e 94 ad 25 	call	0x4b5a	; 0x4b5a <vTaskMissedYield>
    35c0:	f8 01       	movw	r30, r16
    35c2:	95 8d       	ldd	r25, Z+29	; 0x1d
    35c4:	91 50       	subi	r25, 0x01	; 1
    35c6:	95 8f       	std	Z+29, r25	; 0x1d
    35c8:	95 8d       	ldd	r25, Z+29	; 0x1d
    35ca:	19 16       	cp	r1, r25
    35cc:	54 f3       	brlt	.-44     	; 0x35a2 <xQueueGive+0x26e>
    35ce:	8f ef       	ldi	r24, 0xFF	; 255
    35d0:	f8 01       	movw	r30, r16
    35d2:	85 8f       	std	Z+29, r24	; 0x1d
    35d4:	0f 90       	pop	r0
    35d6:	0f be       	out	0x3f, r0	; 63
    35d8:	48 d7       	rcall	.+3728   	; 0x446a <xTaskResumeAll>
    35da:	80 e0       	ldi	r24, 0x00	; 0
    35dc:	09 c0       	rjmp	.+18     	; 0x35f0 <xQueueGive+0x2bc>
    35de:	f8 01       	movw	r30, r16
    35e0:	82 8d       	ldd	r24, Z+26	; 0x1a
    35e2:	8f 5f       	subi	r24, 0xFF	; 255
    35e4:	82 8f       	std	Z+26, r24	; 0x1a
    35e6:	81 89       	ldd	r24, Z+17	; 0x11
    35e8:	88 23       	and	r24, r24
    35ea:	09 f4       	brne	.+2      	; 0x35ee <xQueueGive+0x2ba>
    35ec:	e7 ce       	rjmp	.-562    	; 0x33bc <xQueueGive+0x88>
    35ee:	dc ce       	rjmp	.-584    	; 0x33a8 <xQueueGive+0x74>
    35f0:	0f 90       	pop	r0
    35f2:	0f 90       	pop	r0
    35f4:	0f 90       	pop	r0
    35f6:	0f 90       	pop	r0
    35f8:	0f 90       	pop	r0
    35fa:	df 91       	pop	r29
    35fc:	cf 91       	pop	r28
    35fe:	1f 91       	pop	r17
    3600:	0f 91       	pop	r16
    3602:	ff 90       	pop	r15
    3604:	ef 90       	pop	r14
    3606:	df 90       	pop	r13
    3608:	cf 90       	pop	r12
    360a:	bf 90       	pop	r11
    360c:	af 90       	pop	r10
    360e:	9f 90       	pop	r9
    3610:	08 95       	ret

00003612 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    3612:	cf 93       	push	r28
    3614:	df 93       	push	r29
    3616:	fc 01       	movw	r30, r24
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    3618:	92 8d       	ldd	r25, Z+26	; 0x1a
    361a:	83 8d       	ldd	r24, Z+27	; 0x1b
    361c:	98 17       	cp	r25, r24
    361e:	d0 f4       	brcc	.+52     	; 0x3654 <xQueueGiveFromISR+0x42>
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			++( pxQueue->uxMessagesWaiting );
    3620:	82 8d       	ldd	r24, Z+26	; 0x1a
    3622:	8f 5f       	subi	r24, 0xFF	; 255
    3624:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    3626:	86 8d       	ldd	r24, Z+30	; 0x1e
    3628:	8f 3f       	cpi	r24, 0xFF	; 255
    362a:	79 f4       	brne	.+30     	; 0x364a <xQueueGiveFromISR+0x38>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    362c:	81 89       	ldd	r24, Z+17	; 0x11
    362e:	88 23       	and	r24, r24
    3630:	99 f0       	breq	.+38     	; 0x3658 <xQueueGiveFromISR+0x46>
    3632:	eb 01       	movw	r28, r22
    3634:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3636:	41 96       	adiw	r24, 0x11	; 17
    3638:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <xTaskRemoveFromEventList>
    363c:	88 23       	and	r24, r24
    363e:	71 f0       	breq	.+28     	; 0x365c <xQueueGiveFromISR+0x4a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    3640:	20 97       	sbiw	r28, 0x00	; 0
    3642:	71 f0       	breq	.+28     	; 0x3660 <xQueueGiveFromISR+0x4e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    3644:	81 e0       	ldi	r24, 0x01	; 1
    3646:	88 83       	st	Y, r24
    3648:	0c c0       	rjmp	.+24     	; 0x3662 <xQueueGiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    364a:	86 8d       	ldd	r24, Z+30	; 0x1e
    364c:	8f 5f       	subi	r24, 0xFF	; 255
    364e:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    3650:	81 e0       	ldi	r24, 0x01	; 1
    3652:	07 c0       	rjmp	.+14     	; 0x3662 <xQueueGiveFromISR+0x50>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    3654:	80 e0       	ldi	r24, 0x00	; 0
    3656:	05 c0       	rjmp	.+10     	; 0x3662 <xQueueGiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    3658:	81 e0       	ldi	r24, 0x01	; 1
    365a:	03 c0       	rjmp	.+6      	; 0x3662 <xQueueGiveFromISR+0x50>
    365c:	81 e0       	ldi	r24, 0x01	; 1
    365e:	01 c0       	rjmp	.+2      	; 0x3662 <xQueueGiveFromISR+0x50>
    3660:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    3662:	df 91       	pop	r29
    3664:	cf 91       	pop	r28
    3666:	08 95       	ret

00003668 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    3668:	6f 92       	push	r6
    366a:	7f 92       	push	r7
    366c:	8f 92       	push	r8
    366e:	9f 92       	push	r9
    3670:	af 92       	push	r10
    3672:	bf 92       	push	r11
    3674:	cf 92       	push	r12
    3676:	df 92       	push	r13
    3678:	ef 92       	push	r14
    367a:	ff 92       	push	r15
    367c:	0f 93       	push	r16
    367e:	1f 93       	push	r17
    3680:	cf 93       	push	r28
    3682:	df 93       	push	r29
    3684:	00 d0       	rcall	.+0      	; 0x3686 <xQueueGenericReceive+0x1e>
    3686:	1f 92       	push	r1
    3688:	1f 92       	push	r1
    368a:	cd b7       	in	r28, 0x3d	; 61
    368c:	de b7       	in	r29, 0x3e	; 62
    368e:	8c 01       	movw	r16, r24
    3690:	5b 01       	movw	r10, r22
    3692:	5d 83       	std	Y+5, r21	; 0x05
    3694:	4c 83       	std	Y+4, r20	; 0x04
    3696:	62 2e       	mov	r6, r18
BaseType_t xEntryTimeSet = pdFALSE;
    3698:	81 2c       	mov	r8, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    369a:	77 24       	eor	r7, r7
    369c:	73 94       	inc	r7
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    369e:	99 24       	eor	r9, r9
    36a0:	9a 94       	dec	r9
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    36a2:	6c 01       	movw	r12, r24
    36a4:	88 e0       	ldi	r24, 0x08	; 8
    36a6:	c8 0e       	add	r12, r24
    36a8:	d1 1c       	adc	r13, r1
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    36aa:	78 01       	movw	r14, r16
    36ac:	e1 e1       	ldi	r30, 0x11	; 17
    36ae:	ee 0e       	add	r14, r30
    36b0:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    36b2:	0f b6       	in	r0, 0x3f	; 63
    36b4:	f8 94       	cli
    36b6:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    36b8:	f8 01       	movw	r30, r16
    36ba:	82 8d       	ldd	r24, Z+26	; 0x1a
    36bc:	88 23       	and	r24, r24
    36be:	09 f4       	brne	.+2      	; 0x36c2 <xQueueGenericReceive+0x5a>
    36c0:	45 c0       	rjmp	.+138    	; 0x374c <xQueueGenericReceive+0xe4>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    36c2:	e6 80       	ldd	r14, Z+6	; 0x06
    36c4:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    36c6:	44 8d       	ldd	r20, Z+28	; 0x1c
    36c8:	44 23       	and	r20, r20
    36ca:	a9 f0       	breq	.+42     	; 0x36f6 <xQueueGenericReceive+0x8e>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    36cc:	50 e0       	ldi	r21, 0x00	; 0
    36ce:	c7 01       	movw	r24, r14
    36d0:	84 0f       	add	r24, r20
    36d2:	95 1f       	adc	r25, r21
    36d4:	97 83       	std	Z+7, r25	; 0x07
    36d6:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    36d8:	22 81       	ldd	r18, Z+2	; 0x02
    36da:	33 81       	ldd	r19, Z+3	; 0x03
    36dc:	82 17       	cp	r24, r18
    36de:	93 07       	cpc	r25, r19
    36e0:	20 f0       	brcs	.+8      	; 0x36ea <xQueueGenericReceive+0x82>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    36e2:	80 81       	ld	r24, Z
    36e4:	91 81       	ldd	r25, Z+1	; 0x01
    36e6:	97 83       	std	Z+7, r25	; 0x07
    36e8:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    36ea:	f8 01       	movw	r30, r16
    36ec:	66 81       	ldd	r22, Z+6	; 0x06
    36ee:	77 81       	ldd	r23, Z+7	; 0x07
    36f0:	c5 01       	movw	r24, r10
    36f2:	0e 94 2e 2f 	call	0x5e5c	; 0x5e5c <memcpy>
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    36f6:	61 10       	cpse	r6, r1
    36f8:	19 c0       	rjmp	.+50     	; 0x372c <xQueueGenericReceive+0xc4>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    36fa:	f8 01       	movw	r30, r16
    36fc:	82 8d       	ldd	r24, Z+26	; 0x1a
    36fe:	81 50       	subi	r24, 0x01	; 1
    3700:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    3702:	80 81       	ld	r24, Z
    3704:	91 81       	ldd	r25, Z+1	; 0x01
    3706:	89 2b       	or	r24, r25
    3708:	29 f4       	brne	.+10     	; 0x3714 <xQueueGenericReceive+0xac>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    370a:	0e 94 53 26 	call	0x4ca6	; 0x4ca6 <pvTaskIncrementMutexHeldCount>
    370e:	f8 01       	movw	r30, r16
    3710:	93 83       	std	Z+3, r25	; 0x03
    3712:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3714:	f8 01       	movw	r30, r16
    3716:	80 85       	ldd	r24, Z+8	; 0x08
    3718:	88 23       	and	r24, r24
    371a:	a1 f0       	breq	.+40     	; 0x3744 <xQueueGenericReceive+0xdc>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    371c:	c8 01       	movw	r24, r16
    371e:	08 96       	adiw	r24, 0x08	; 8
    3720:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <xTaskRemoveFromEventList>
    3724:	81 30       	cpi	r24, 0x01	; 1
    3726:	71 f4       	brne	.+28     	; 0x3744 <xQueueGenericReceive+0xdc>
						{
							queueYIELD_IF_USING_PREEMPTION();
    3728:	85 d9       	rcall	.-3318   	; 0x2a34 <vPortYield>
    372a:	0c c0       	rjmp	.+24     	; 0x3744 <xQueueGenericReceive+0xdc>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    372c:	f8 01       	movw	r30, r16
    372e:	f7 82       	std	Z+7, r15	; 0x07
    3730:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3732:	81 89       	ldd	r24, Z+17	; 0x11
    3734:	88 23       	and	r24, r24
    3736:	31 f0       	breq	.+12     	; 0x3744 <xQueueGenericReceive+0xdc>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3738:	c8 01       	movw	r24, r16
    373a:	41 96       	adiw	r24, 0x11	; 17
    373c:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <xTaskRemoveFromEventList>
    3740:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    3742:	78 d9       	rcall	.-3344   	; 0x2a34 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    3744:	0f 90       	pop	r0
    3746:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3748:	81 e0       	ldi	r24, 0x01	; 1
    374a:	17 c1       	rjmp	.+558    	; 0x397a <xQueueGenericReceive+0x312>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    374c:	8c 81       	ldd	r24, Y+4	; 0x04
    374e:	9d 81       	ldd	r25, Y+5	; 0x05
    3750:	89 2b       	or	r24, r25
    3752:	21 f4       	brne	.+8      	; 0x375c <xQueueGenericReceive+0xf4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3754:	0f 90       	pop	r0
    3756:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    3758:	80 e0       	ldi	r24, 0x00	; 0
    375a:	0f c1       	rjmp	.+542    	; 0x397a <xQueueGenericReceive+0x312>
				}
				else if( xEntryTimeSet == pdFALSE )
    375c:	81 10       	cpse	r8, r1
    375e:	05 c0       	rjmp	.+10     	; 0x376a <xQueueGenericReceive+0x102>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    3760:	ce 01       	movw	r24, r28
    3762:	01 96       	adiw	r24, 0x01	; 1
    3764:	0e 94 67 25 	call	0x4ace	; 0x4ace <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3768:	87 2c       	mov	r8, r7
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    376a:	0f 90       	pop	r0
    376c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    376e:	77 d6       	rcall	.+3310   	; 0x445e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3770:	0f b6       	in	r0, 0x3f	; 63
    3772:	f8 94       	cli
    3774:	0f 92       	push	r0
    3776:	f8 01       	movw	r30, r16
    3778:	85 8d       	ldd	r24, Z+29	; 0x1d
    377a:	8f 3f       	cpi	r24, 0xFF	; 255
    377c:	09 f4       	brne	.+2      	; 0x3780 <xQueueGenericReceive+0x118>
    377e:	15 8e       	std	Z+29, r1	; 0x1d
    3780:	f8 01       	movw	r30, r16
    3782:	86 8d       	ldd	r24, Z+30	; 0x1e
    3784:	8f 3f       	cpi	r24, 0xFF	; 255
    3786:	09 f4       	brne	.+2      	; 0x378a <xQueueGenericReceive+0x122>
    3788:	16 8e       	std	Z+30, r1	; 0x1e
    378a:	0f 90       	pop	r0
    378c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    378e:	be 01       	movw	r22, r28
    3790:	6c 5f       	subi	r22, 0xFC	; 252
    3792:	7f 4f       	sbci	r23, 0xFF	; 255
    3794:	ce 01       	movw	r24, r28
    3796:	01 96       	adiw	r24, 0x01	; 1
    3798:	0e 94 72 25 	call	0x4ae4	; 0x4ae4 <xTaskCheckForTimeOut>
    379c:	81 11       	cpse	r24, r1
    379e:	a0 c0       	rjmp	.+320    	; 0x38e0 <xQueueGenericReceive+0x278>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    37a0:	0f b6       	in	r0, 0x3f	; 63
    37a2:	f8 94       	cli
    37a4:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    37a6:	f8 01       	movw	r30, r16
    37a8:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    37aa:	0f 90       	pop	r0
    37ac:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    37ae:	81 11       	cpse	r24, r1
    37b0:	56 c0       	rjmp	.+172    	; 0x385e <xQueueGenericReceive+0x1f6>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    37b2:	80 81       	ld	r24, Z
    37b4:	91 81       	ldd	r25, Z+1	; 0x01
    37b6:	89 2b       	or	r24, r25
    37b8:	49 f4       	brne	.+18     	; 0x37cc <xQueueGenericReceive+0x164>
					{
						taskENTER_CRITICAL();
    37ba:	0f b6       	in	r0, 0x3f	; 63
    37bc:	f8 94       	cli
    37be:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    37c0:	82 81       	ldd	r24, Z+2	; 0x02
    37c2:	93 81       	ldd	r25, Z+3	; 0x03
    37c4:	0e 94 b1 25 	call	0x4b62	; 0x4b62 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    37c8:	0f 90       	pop	r0
    37ca:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    37cc:	6c 81       	ldd	r22, Y+4	; 0x04
    37ce:	7d 81       	ldd	r23, Y+5	; 0x05
    37d0:	c7 01       	movw	r24, r14
    37d2:	0e 94 c3 24 	call	0x4986	; 0x4986 <vTaskPlaceOnEventList>

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    37d6:	0f b6       	in	r0, 0x3f	; 63
    37d8:	f8 94       	cli
    37da:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    37dc:	f8 01       	movw	r30, r16
    37de:	86 8d       	ldd	r24, Z+30	; 0x1e
    37e0:	18 16       	cp	r1, r24
    37e2:	ac f4       	brge	.+42     	; 0x380e <xQueueGenericReceive+0x1a6>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    37e4:	81 89       	ldd	r24, Z+17	; 0x11
    37e6:	81 11       	cpse	r24, r1
    37e8:	05 c0       	rjmp	.+10     	; 0x37f4 <xQueueGenericReceive+0x18c>
    37ea:	11 c0       	rjmp	.+34     	; 0x380e <xQueueGenericReceive+0x1a6>
    37ec:	f8 01       	movw	r30, r16
    37ee:	81 89       	ldd	r24, Z+17	; 0x11
    37f0:	88 23       	and	r24, r24
    37f2:	69 f0       	breq	.+26     	; 0x380e <xQueueGenericReceive+0x1a6>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    37f4:	c7 01       	movw	r24, r14
    37f6:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <xTaskRemoveFromEventList>
    37fa:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    37fc:	0e 94 ad 25 	call	0x4b5a	; 0x4b5a <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    3800:	f8 01       	movw	r30, r16
    3802:	86 8d       	ldd	r24, Z+30	; 0x1e
    3804:	81 50       	subi	r24, 0x01	; 1
    3806:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    3808:	86 8d       	ldd	r24, Z+30	; 0x1e
    380a:	18 16       	cp	r1, r24
    380c:	7c f3       	brlt	.-34     	; 0x37ec <xQueueGenericReceive+0x184>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    380e:	f8 01       	movw	r30, r16
    3810:	96 8e       	std	Z+30, r9	; 0x1e
	}
	taskEXIT_CRITICAL();
    3812:	0f 90       	pop	r0
    3814:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    3816:	0f b6       	in	r0, 0x3f	; 63
    3818:	f8 94       	cli
    381a:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    381c:	85 8d       	ldd	r24, Z+29	; 0x1d
    381e:	18 16       	cp	r1, r24
    3820:	ac f4       	brge	.+42     	; 0x384c <xQueueGenericReceive+0x1e4>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3822:	80 85       	ldd	r24, Z+8	; 0x08
    3824:	81 11       	cpse	r24, r1
    3826:	05 c0       	rjmp	.+10     	; 0x3832 <xQueueGenericReceive+0x1ca>
    3828:	11 c0       	rjmp	.+34     	; 0x384c <xQueueGenericReceive+0x1e4>
    382a:	f8 01       	movw	r30, r16
    382c:	80 85       	ldd	r24, Z+8	; 0x08
    382e:	88 23       	and	r24, r24
    3830:	69 f0       	breq	.+26     	; 0x384c <xQueueGenericReceive+0x1e4>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3832:	c6 01       	movw	r24, r12
    3834:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <xTaskRemoveFromEventList>
    3838:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    383a:	0e 94 ad 25 	call	0x4b5a	; 0x4b5a <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    383e:	f8 01       	movw	r30, r16
    3840:	85 8d       	ldd	r24, Z+29	; 0x1d
    3842:	81 50       	subi	r24, 0x01	; 1
    3844:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    3846:	85 8d       	ldd	r24, Z+29	; 0x1d
    3848:	18 16       	cp	r1, r24
    384a:	7c f3       	brlt	.-34     	; 0x382a <xQueueGenericReceive+0x1c2>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    384c:	f8 01       	movw	r30, r16
    384e:	95 8e       	std	Z+29, r9	; 0x1d
	}
	taskEXIT_CRITICAL();
    3850:	0f 90       	pop	r0
    3852:	0f be       	out	0x3f, r0	; 63
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
				prvUnlockQueue( pxQueue );
				if( xTaskResumeAll() == pdFALSE )
    3854:	0a d6       	rcall	.+3092   	; 0x446a <xTaskResumeAll>
    3856:	81 11       	cpse	r24, r1
    3858:	2c cf       	rjmp	.-424    	; 0x36b2 <xQueueGenericReceive+0x4a>
				{
					portYIELD_WITHIN_API();
    385a:	ec d8       	rcall	.-3624   	; 0x2a34 <vPortYield>
    385c:	2a cf       	rjmp	.-428    	; 0x36b2 <xQueueGenericReceive+0x4a>

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    385e:	0f b6       	in	r0, 0x3f	; 63
    3860:	f8 94       	cli
    3862:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    3864:	f8 01       	movw	r30, r16
    3866:	86 8d       	ldd	r24, Z+30	; 0x1e
    3868:	18 16       	cp	r1, r24
    386a:	ac f4       	brge	.+42     	; 0x3896 <xQueueGenericReceive+0x22e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    386c:	81 89       	ldd	r24, Z+17	; 0x11
    386e:	81 11       	cpse	r24, r1
    3870:	05 c0       	rjmp	.+10     	; 0x387c <xQueueGenericReceive+0x214>
    3872:	11 c0       	rjmp	.+34     	; 0x3896 <xQueueGenericReceive+0x22e>
    3874:	f8 01       	movw	r30, r16
    3876:	81 89       	ldd	r24, Z+17	; 0x11
    3878:	88 23       	and	r24, r24
    387a:	69 f0       	breq	.+26     	; 0x3896 <xQueueGenericReceive+0x22e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    387c:	c7 01       	movw	r24, r14
    387e:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <xTaskRemoveFromEventList>
    3882:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    3884:	0e 94 ad 25 	call	0x4b5a	; 0x4b5a <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    3888:	f8 01       	movw	r30, r16
    388a:	86 8d       	ldd	r24, Z+30	; 0x1e
    388c:	81 50       	subi	r24, 0x01	; 1
    388e:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    3890:	86 8d       	ldd	r24, Z+30	; 0x1e
    3892:	18 16       	cp	r1, r24
    3894:	7c f3       	brlt	.-34     	; 0x3874 <xQueueGenericReceive+0x20c>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    3896:	f8 01       	movw	r30, r16
    3898:	96 8e       	std	Z+30, r9	; 0x1e
	}
	taskEXIT_CRITICAL();
    389a:	0f 90       	pop	r0
    389c:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    389e:	0f b6       	in	r0, 0x3f	; 63
    38a0:	f8 94       	cli
    38a2:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    38a4:	85 8d       	ldd	r24, Z+29	; 0x1d
    38a6:	18 16       	cp	r1, r24
    38a8:	ac f4       	brge	.+42     	; 0x38d4 <xQueueGenericReceive+0x26c>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    38aa:	80 85       	ldd	r24, Z+8	; 0x08
    38ac:	81 11       	cpse	r24, r1
    38ae:	05 c0       	rjmp	.+10     	; 0x38ba <xQueueGenericReceive+0x252>
    38b0:	11 c0       	rjmp	.+34     	; 0x38d4 <xQueueGenericReceive+0x26c>
    38b2:	f8 01       	movw	r30, r16
    38b4:	80 85       	ldd	r24, Z+8	; 0x08
    38b6:	88 23       	and	r24, r24
    38b8:	69 f0       	breq	.+26     	; 0x38d4 <xQueueGenericReceive+0x26c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    38ba:	c6 01       	movw	r24, r12
    38bc:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <xTaskRemoveFromEventList>
    38c0:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    38c2:	0e 94 ad 25 	call	0x4b5a	; 0x4b5a <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    38c6:	f8 01       	movw	r30, r16
    38c8:	95 8d       	ldd	r25, Z+29	; 0x1d
    38ca:	91 50       	subi	r25, 0x01	; 1
    38cc:	95 8f       	std	Z+29, r25	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    38ce:	85 8d       	ldd	r24, Z+29	; 0x1d
    38d0:	18 16       	cp	r1, r24
    38d2:	7c f3       	brlt	.-34     	; 0x38b2 <xQueueGenericReceive+0x24a>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    38d4:	f8 01       	movw	r30, r16
    38d6:	95 8e       	std	Z+29, r9	; 0x1d
	}
	taskEXIT_CRITICAL();
    38d8:	0f 90       	pop	r0
    38da:	0f be       	out	0x3f, r0	; 63
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
				( void ) xTaskResumeAll();
    38dc:	c6 d5       	rcall	.+2956   	; 0x446a <xTaskResumeAll>
    38de:	e9 ce       	rjmp	.-558    	; 0x36b2 <xQueueGenericReceive+0x4a>

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    38e0:	0f b6       	in	r0, 0x3f	; 63
    38e2:	f8 94       	cli
    38e4:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    38e6:	f8 01       	movw	r30, r16
    38e8:	86 8d       	ldd	r24, Z+30	; 0x1e
    38ea:	18 16       	cp	r1, r24
    38ec:	d4 f4       	brge	.+52     	; 0x3922 <xQueueGenericReceive+0x2ba>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    38ee:	81 89       	ldd	r24, Z+17	; 0x11
    38f0:	81 11       	cpse	r24, r1
    38f2:	06 c0       	rjmp	.+12     	; 0x3900 <xQueueGenericReceive+0x298>
    38f4:	16 c0       	rjmp	.+44     	; 0x3922 <xQueueGenericReceive+0x2ba>
    38f6:	f8 01       	movw	r30, r16
    38f8:	91 89       	ldd	r25, Z+17	; 0x11
    38fa:	91 11       	cpse	r25, r1
    38fc:	05 c0       	rjmp	.+10     	; 0x3908 <xQueueGenericReceive+0x2a0>
    38fe:	11 c0       	rjmp	.+34     	; 0x3922 <xQueueGenericReceive+0x2ba>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3900:	78 01       	movw	r14, r16
    3902:	f1 e1       	ldi	r31, 0x11	; 17
    3904:	ef 0e       	add	r14, r31
    3906:	f1 1c       	adc	r15, r1
    3908:	c7 01       	movw	r24, r14
    390a:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <xTaskRemoveFromEventList>
    390e:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    3910:	0e 94 ad 25 	call	0x4b5a	; 0x4b5a <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    3914:	f8 01       	movw	r30, r16
    3916:	96 8d       	ldd	r25, Z+30	; 0x1e
    3918:	91 50       	subi	r25, 0x01	; 1
    391a:	96 8f       	std	Z+30, r25	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    391c:	96 8d       	ldd	r25, Z+30	; 0x1e
    391e:	19 16       	cp	r1, r25
    3920:	54 f3       	brlt	.-44     	; 0x38f6 <xQueueGenericReceive+0x28e>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    3922:	8f ef       	ldi	r24, 0xFF	; 255
    3924:	f8 01       	movw	r30, r16
    3926:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    3928:	0f 90       	pop	r0
    392a:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    392c:	0f b6       	in	r0, 0x3f	; 63
    392e:	f8 94       	cli
    3930:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    3932:	85 8d       	ldd	r24, Z+29	; 0x1d
    3934:	18 16       	cp	r1, r24
    3936:	d4 f4       	brge	.+52     	; 0x396c <xQueueGenericReceive+0x304>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3938:	80 85       	ldd	r24, Z+8	; 0x08
    393a:	81 11       	cpse	r24, r1
    393c:	06 c0       	rjmp	.+12     	; 0x394a <xQueueGenericReceive+0x2e2>
    393e:	16 c0       	rjmp	.+44     	; 0x396c <xQueueGenericReceive+0x304>
    3940:	f8 01       	movw	r30, r16
    3942:	90 85       	ldd	r25, Z+8	; 0x08
    3944:	91 11       	cpse	r25, r1
    3946:	05 c0       	rjmp	.+10     	; 0x3952 <xQueueGenericReceive+0x2ea>
    3948:	11 c0       	rjmp	.+34     	; 0x396c <xQueueGenericReceive+0x304>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    394a:	78 01       	movw	r14, r16
    394c:	f8 e0       	ldi	r31, 0x08	; 8
    394e:	ef 0e       	add	r14, r31
    3950:	f1 1c       	adc	r15, r1
    3952:	c7 01       	movw	r24, r14
    3954:	0e 94 1f 25 	call	0x4a3e	; 0x4a3e <xTaskRemoveFromEventList>
    3958:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    395a:	0e 94 ad 25 	call	0x4b5a	; 0x4b5a <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    395e:	f8 01       	movw	r30, r16
    3960:	95 8d       	ldd	r25, Z+29	; 0x1d
    3962:	91 50       	subi	r25, 0x01	; 1
    3964:	95 8f       	std	Z+29, r25	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    3966:	95 8d       	ldd	r25, Z+29	; 0x1d
    3968:	19 16       	cp	r1, r25
    396a:	54 f3       	brlt	.-44     	; 0x3940 <xQueueGenericReceive+0x2d8>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    396c:	8f ef       	ldi	r24, 0xFF	; 255
    396e:	f8 01       	movw	r30, r16
    3970:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    3972:	0f 90       	pop	r0
    3974:	0f be       	out	0x3f, r0	; 63
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
    3976:	79 d5       	rcall	.+2802   	; 0x446a <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    3978:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    397a:	0f 90       	pop	r0
    397c:	0f 90       	pop	r0
    397e:	0f 90       	pop	r0
    3980:	0f 90       	pop	r0
    3982:	0f 90       	pop	r0
    3984:	df 91       	pop	r29
    3986:	cf 91       	pop	r28
    3988:	1f 91       	pop	r17
    398a:	0f 91       	pop	r16
    398c:	ff 90       	pop	r15
    398e:	ef 90       	pop	r14
    3990:	df 90       	pop	r13
    3992:	cf 90       	pop	r12
    3994:	bf 90       	pop	r11
    3996:	af 90       	pop	r10
    3998:	9f 90       	pop	r9
    399a:	8f 90       	pop	r8
    399c:	7f 90       	pop	r7
    399e:	6f 90       	pop	r6
    39a0:	08 95       	ret

000039a2 <vServo_setAngle>:
}

/* Sets servo angle to a specific degree */
void vServo_setAngle(uint8_t ServoAngleDeg){
    /* Ensure feasible values */
    if (ServoAngleDeg >= 90){
    39a2:	8a 35       	cpi	r24, 0x5A	; 90
    39a4:	08 f0       	brcs	.+2      	; 0x39a8 <vServo_setAngle+0x6>
        ServoAngleDeg = 90;
    39a6:	8a e5       	ldi	r24, 0x5A	; 90
    }
    else if(ServoAngleDeg <= 0){
        ServoAngleDeg = 0;
    }
    /* Fetch pulse width from array and set to output */
    servoOCR = DEG_TO_PWM[ServoAngleDeg];
    39a8:	e8 2f       	mov	r30, r24
    39aa:	f0 e0       	ldi	r31, 0x00	; 0
    39ac:	ee 0f       	add	r30, r30
    39ae:	ff 1f       	adc	r31, r31
    39b0:	ee 5b       	subi	r30, 0xBE	; 190
    39b2:	f8 4f       	sbci	r31, 0xF8	; 248
    39b4:	80 81       	ld	r24, Z
    39b6:	91 81       	ldd	r25, Z+1	; 0x01
    39b8:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    39bc:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
    39c0:	08 95       	ret

000039c2 <vServo_init>:
/************************************************************************/
void vServo_init(uint8_t servoAngleDeg){
    /* Clear OCnA/OCnB on Compare Match, set */
    /* OCnA/OCnB at BOTTOM (non-inverting mode) */
    /* Datasheet p.132 Table 14-3 */
    TCCR1A |= (1<<COM1A1) | (0<<COM0A0);
    39c2:	a0 e8       	ldi	r26, 0x80	; 128
    39c4:	b0 e0       	ldi	r27, 0x00	; 0
    39c6:	9c 91       	ld	r25, X
    39c8:	90 68       	ori	r25, 0x80	; 128
    39ca:	9c 93       	st	X, r25
    
    /* Waveform generation mode 14: Fast PWM */
    /* top: ICRn, Update bottom, flag set on top */
    /* Datasheet p.133 Table 14-5 */
    TCCR1B |= (1<<WGM13) | (1<<WGM12);
    39cc:	e1 e8       	ldi	r30, 0x81	; 129
    39ce:	f0 e0       	ldi	r31, 0x00	; 0
    39d0:	90 81       	ld	r25, Z
    39d2:	98 61       	ori	r25, 0x18	; 24
    39d4:	90 83       	st	Z, r25
    TCCR1A |= (1<<WGM11) | (0<<WGM10);
    39d6:	9c 91       	ld	r25, X
    39d8:	92 60       	ori	r25, 0x02	; 2
    39da:	9c 93       	st	X, r25

    /* Clock select bit description: */
    /* clkI/O/8 (From prescaler) - Datasheet p.134 Table 14-6*/
    TCCR1B |= (0<<CS12) | (1<<CS11) | (0<<CS10);
    39dc:	90 81       	ld	r25, Z
    39de:	92 60       	ori	r25, 0x02	; 2
    39e0:	90 83       	st	Z, r25
    
    /* 50Hz 20ms period => 16Mhz/(8clk*50Hz) - 1 = ICR1] */
    /* Datasheet p.125 */
    ICR1 = 39999; // 49999 for 20mhz, 39 999 for 16mhz
    39e2:	2f e3       	ldi	r18, 0x3F	; 63
    39e4:	3c e9       	ldi	r19, 0x9C	; 156
    39e6:	30 93 87 00 	sts	0x0087, r19	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
    39ea:	20 93 86 00 	sts	0x0086, r18	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
    
    /*PortB Pin 5 as servo PWM Output (OC1A)*/
    servoReg |= (1<<servoPin);
    39ee:	25 9a       	sbi	0x04, 5	; 4
    
    /*  Set angle to desired start angle (usually 0)*/
    vServo_setAngle(servoAngleDeg);
    39f0:	d8 cf       	rjmp	.-80     	; 0x39a2 <vServo_setAngle>
    39f2:	08 95       	ret

000039f4 <vSPI_MasterInit>:

#include "defines.h"

void vSPI_MasterInit(){
    /* Set MOSI SCK and slave select pin as output */
    DDR_SPI |= (1<<DD_MOSI) | (1<<DD_SCK) | (1<<IMU_SS);
    39f4:	84 b1       	in	r24, 0x04	; 4
    39f6:	87 60       	ori	r24, 0x07	; 7
    39f8:	84 b9       	out	0x04, r24	; 4
    DDR_SPI &= ~(1 << DD_MISO); // Set MISO as input
    39fa:	23 98       	cbi	0x04, 3	; 4
    
    /* Enable SPI, master, set clockrate at fck/128, MSB first */
    /* Max frequency for LSM6DS3 is 10Mhz, we use 156 250Hz */
    // Data is captured on rising edge of clock (CPHA = 0)
    // Base value of the clock is HIGH (CPOL = 1)
    SPCR |= (1<<SPI2X) | (0<<SPR1) | (0<<SPR0);
    39fc:	8c b5       	in	r24, 0x2c	; 44
    39fe:	81 60       	ori	r24, 0x01	; 1
    3a00:	8c bd       	out	0x2c, r24	; 44
    SPCR |= (1<<SPE) | (1<<MSTR) | (1<<CPOL) | (1<<CPHA);
    3a02:	8c b5       	in	r24, 0x2c	; 44
    3a04:	8c 65       	ori	r24, 0x5C	; 92
    3a06:	8c bd       	out	0x2c, r24	; 44
    SPCR &= ~(1<<DORD); // MSB first
    3a08:	8c b5       	in	r24, 0x2c	; 44
    3a0a:	8f 7d       	andi	r24, 0xDF	; 223
    3a0c:	8c bd       	out	0x2c, r24	; 44
    3a0e:	08 95       	ret

00003a10 <ui8SPI_MasterTransmit>:
}

uint8_t ui8SPI_MasterTransmit(char cData){
    /* Start transmission */
    SPDR = cData;
    3a10:	8e bd       	out	0x2e, r24	; 46
    /* Wait for transmission complete */
    asm volatile("nop");
    3a12:	00 00       	nop
    while(!(SPSR & (1<<SPIF)));
    3a14:	0d b4       	in	r0, 0x2d	; 45
    3a16:	07 fe       	sbrs	r0, 7
    3a18:	fd cf       	rjmp	.-6      	; 0x3a14 <ui8SPI_MasterTransmit+0x4>
    /* Return anything recieved */
    return SPDR;
    3a1a:	8e b5       	in	r24, 0x2e	; 46
}
    3a1c:	08 95       	ret

00003a1e <xTaskGenericCreate>:
    3a1e:	4f 92       	push	r4
    3a20:	5f 92       	push	r5
    3a22:	6f 92       	push	r6
    3a24:	7f 92       	push	r7
    3a26:	8f 92       	push	r8
    3a28:	9f 92       	push	r9
    3a2a:	af 92       	push	r10
    3a2c:	bf 92       	push	r11
    3a2e:	cf 92       	push	r12
    3a30:	df 92       	push	r13
    3a32:	ef 92       	push	r14
    3a34:	ff 92       	push	r15
    3a36:	0f 93       	push	r16
    3a38:	1f 93       	push	r17
    3a3a:	cf 93       	push	r28
    3a3c:	df 93       	push	r29
    3a3e:	4c 01       	movw	r8, r24
    3a40:	eb 01       	movw	r28, r22
    3a42:	5a 01       	movw	r10, r20
    3a44:	29 01       	movw	r4, r18
    3a46:	c1 14       	cp	r12, r1
    3a48:	d1 04       	cpc	r13, r1
    3a4a:	39 f4       	brne	.+14     	; 0x3a5a <xTaskGenericCreate+0x3c>
    3a4c:	ca 01       	movw	r24, r20
    3a4e:	0e 94 8f 02 	call	0x51e	; 0x51e <pvPortMalloc>
    3a52:	6c 01       	movw	r12, r24
    3a54:	89 2b       	or	r24, r25
    3a56:	09 f4       	brne	.+2      	; 0x3a5a <xTaskGenericCreate+0x3c>
    3a58:	e4 c0       	rjmp	.+456    	; 0x3c22 <xTaskGenericCreate+0x204>
    3a5a:	88 e2       	ldi	r24, 0x28	; 40
    3a5c:	90 e0       	ldi	r25, 0x00	; 0
    3a5e:	0e 94 8f 02 	call	0x51e	; 0x51e <pvPortMalloc>
    3a62:	3c 01       	movw	r6, r24
    3a64:	00 97       	sbiw	r24, 0x00	; 0
    3a66:	79 f0       	breq	.+30     	; 0x3a86 <xTaskGenericCreate+0x68>
    3a68:	fc 01       	movw	r30, r24
    3a6a:	d0 8e       	std	Z+24, r13	; 0x18
    3a6c:	c7 8a       	std	Z+23, r12	; 0x17
    3a6e:	f1 e0       	ldi	r31, 0x01	; 1
    3a70:	af 1a       	sub	r10, r31
    3a72:	b1 08       	sbc	r11, r1
    3a74:	ca 0c       	add	r12, r10
    3a76:	db 1c       	adc	r13, r11
    3a78:	88 81       	ld	r24, Y
    3a7a:	f3 01       	movw	r30, r6
    3a7c:	81 8f       	std	Z+25, r24	; 0x19
    3a7e:	88 81       	ld	r24, Y
    3a80:	81 11       	cpse	r24, r1
    3a82:	05 c0       	rjmp	.+10     	; 0x3a8e <xTaskGenericCreate+0x70>
    3a84:	14 c0       	rjmp	.+40     	; 0x3aae <xTaskGenericCreate+0x90>
    3a86:	c6 01       	movw	r24, r12
    3a88:	0e 94 c4 02 	call	0x588	; 0x588 <vPortFree>
    3a8c:	ca c0       	rjmp	.+404    	; 0x3c22 <xTaskGenericCreate+0x204>
    3a8e:	d3 01       	movw	r26, r6
    3a90:	5a 96       	adiw	r26, 0x1a	; 26
    3a92:	fe 01       	movw	r30, r28
    3a94:	31 96       	adiw	r30, 0x01	; 1
    3a96:	9e 01       	movw	r18, r28
    3a98:	28 5f       	subi	r18, 0xF8	; 248
    3a9a:	3f 4f       	sbci	r19, 0xFF	; 255
    3a9c:	ef 01       	movw	r28, r30
    3a9e:	81 91       	ld	r24, Z+
    3aa0:	8d 93       	st	X+, r24
    3aa2:	88 81       	ld	r24, Y
    3aa4:	88 23       	and	r24, r24
    3aa6:	19 f0       	breq	.+6      	; 0x3aae <xTaskGenericCreate+0x90>
    3aa8:	e2 17       	cp	r30, r18
    3aaa:	f3 07       	cpc	r31, r19
    3aac:	b9 f7       	brne	.-18     	; 0x3a9c <xTaskGenericCreate+0x7e>
    3aae:	f3 01       	movw	r30, r6
    3ab0:	10 a2       	std	Z+32, r1	; 0x20
    3ab2:	10 2f       	mov	r17, r16
    3ab4:	06 30       	cpi	r16, 0x06	; 6
    3ab6:	08 f0       	brcs	.+2      	; 0x3aba <xTaskGenericCreate+0x9c>
    3ab8:	15 e0       	ldi	r17, 0x05	; 5
    3aba:	f3 01       	movw	r30, r6
    3abc:	16 8b       	std	Z+22, r17	; 0x16
    3abe:	11 a3       	std	Z+33, r17	; 0x21
    3ac0:	12 a2       	std	Z+34, r1	; 0x22
    3ac2:	e3 01       	movw	r28, r6
    3ac4:	22 96       	adiw	r28, 0x02	; 2
    3ac6:	ce 01       	movw	r24, r28
    3ac8:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <vListInitialiseItem>
    3acc:	c3 01       	movw	r24, r6
    3ace:	0c 96       	adiw	r24, 0x0c	; 12
    3ad0:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <vListInitialiseItem>
    3ad4:	f3 01       	movw	r30, r6
    3ad6:	71 86       	std	Z+9, r7	; 0x09
    3ad8:	60 86       	std	Z+8, r6	; 0x08
    3ada:	86 e0       	ldi	r24, 0x06	; 6
    3adc:	90 e0       	ldi	r25, 0x00	; 0
    3ade:	81 1b       	sub	r24, r17
    3ae0:	91 09       	sbc	r25, r1
    3ae2:	95 87       	std	Z+13, r25	; 0x0d
    3ae4:	84 87       	std	Z+12, r24	; 0x0c
    3ae6:	73 8a       	std	Z+19, r7	; 0x13
    3ae8:	62 8a       	std	Z+18, r6	; 0x12
    3aea:	13 a2       	std	Z+35, r1	; 0x23
    3aec:	14 a2       	std	Z+36, r1	; 0x24
    3aee:	15 a2       	std	Z+37, r1	; 0x25
    3af0:	16 a2       	std	Z+38, r1	; 0x26
    3af2:	17 a2       	std	Z+39, r1	; 0x27
    3af4:	a2 01       	movw	r20, r4
    3af6:	b4 01       	movw	r22, r8
    3af8:	c6 01       	movw	r24, r12
    3afa:	0e 94 60 14 	call	0x28c0	; 0x28c0 <pxPortInitialiseStack>
    3afe:	f3 01       	movw	r30, r6
    3b00:	91 83       	std	Z+1, r25	; 0x01
    3b02:	80 83       	st	Z, r24
    3b04:	e1 14       	cp	r14, r1
    3b06:	f1 04       	cpc	r15, r1
    3b08:	19 f0       	breq	.+6      	; 0x3b10 <xTaskGenericCreate+0xf2>
    3b0a:	f7 01       	movw	r30, r14
    3b0c:	71 82       	std	Z+1, r7	; 0x01
    3b0e:	60 82       	st	Z, r6
    3b10:	0f b6       	in	r0, 0x3f	; 63
    3b12:	f8 94       	cli
    3b14:	0f 92       	push	r0
    3b16:	80 91 96 1a 	lds	r24, 0x1A96	; 0x801a96 <uxCurrentNumberOfTasks>
    3b1a:	8f 5f       	subi	r24, 0xFF	; 255
    3b1c:	80 93 96 1a 	sts	0x1A96, r24	; 0x801a96 <uxCurrentNumberOfTasks>
    3b20:	80 91 f5 1a 	lds	r24, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    3b24:	90 91 f6 1a 	lds	r25, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    3b28:	89 2b       	or	r24, r25
    3b2a:	d9 f5       	brne	.+118    	; 0x3ba2 <xTaskGenericCreate+0x184>
    3b2c:	70 92 f6 1a 	sts	0x1AF6, r7	; 0x801af6 <pxCurrentTCB+0x1>
    3b30:	60 92 f5 1a 	sts	0x1AF5, r6	; 0x801af5 <pxCurrentTCB>
    3b34:	80 91 96 1a 	lds	r24, 0x1A96	; 0x801a96 <uxCurrentNumberOfTasks>
    3b38:	81 30       	cpi	r24, 0x01	; 1
    3b3a:	09 f0       	breq	.+2      	; 0x3b3e <xTaskGenericCreate+0x120>
    3b3c:	41 c0       	rjmp	.+130    	; 0x3bc0 <xTaskGenericCreate+0x1a2>
    3b3e:	0f 2e       	mov	r0, r31
    3b40:	ff eb       	ldi	r31, 0xBF	; 191
    3b42:	ef 2e       	mov	r14, r31
    3b44:	fa e1       	ldi	r31, 0x1A	; 26
    3b46:	ff 2e       	mov	r15, r31
    3b48:	f0 2d       	mov	r31, r0
    3b4a:	0f 2e       	mov	r0, r31
    3b4c:	f5 ef       	ldi	r31, 0xF5	; 245
    3b4e:	cf 2e       	mov	r12, r31
    3b50:	fa e1       	ldi	r31, 0x1A	; 26
    3b52:	df 2e       	mov	r13, r31
    3b54:	f0 2d       	mov	r31, r0
    3b56:	c7 01       	movw	r24, r14
    3b58:	0e 94 ee 05 	call	0xbdc	; 0xbdc <vListInitialise>
    3b5c:	f9 e0       	ldi	r31, 0x09	; 9
    3b5e:	ef 0e       	add	r14, r31
    3b60:	f1 1c       	adc	r15, r1
    3b62:	ec 14       	cp	r14, r12
    3b64:	fd 04       	cpc	r15, r13
    3b66:	b9 f7       	brne	.-18     	; 0x3b56 <xTaskGenericCreate+0x138>
    3b68:	86 eb       	ldi	r24, 0xB6	; 182
    3b6a:	9a e1       	ldi	r25, 0x1A	; 26
    3b6c:	0e 94 ee 05 	call	0xbdc	; 0xbdc <vListInitialise>
    3b70:	8d ea       	ldi	r24, 0xAD	; 173
    3b72:	9a e1       	ldi	r25, 0x1A	; 26
    3b74:	0e 94 ee 05 	call	0xbdc	; 0xbdc <vListInitialise>
    3b78:	80 ea       	ldi	r24, 0xA0	; 160
    3b7a:	9a e1       	ldi	r25, 0x1A	; 26
    3b7c:	0e 94 ee 05 	call	0xbdc	; 0xbdc <vListInitialise>
    3b80:	87 e9       	ldi	r24, 0x97	; 151
    3b82:	9a e1       	ldi	r25, 0x1A	; 26
    3b84:	0e 94 ee 05 	call	0xbdc	; 0xbdc <vListInitialise>
    3b88:	86 eb       	ldi	r24, 0xB6	; 182
    3b8a:	9a e1       	ldi	r25, 0x1A	; 26
    3b8c:	90 93 ac 1a 	sts	0x1AAC, r25	; 0x801aac <pxDelayedTaskList+0x1>
    3b90:	80 93 ab 1a 	sts	0x1AAB, r24	; 0x801aab <pxDelayedTaskList>
    3b94:	8d ea       	ldi	r24, 0xAD	; 173
    3b96:	9a e1       	ldi	r25, 0x1A	; 26
    3b98:	90 93 aa 1a 	sts	0x1AAA, r25	; 0x801aaa <pxOverflowDelayedTaskList+0x1>
    3b9c:	80 93 a9 1a 	sts	0x1AA9, r24	; 0x801aa9 <pxOverflowDelayedTaskList>
    3ba0:	0f c0       	rjmp	.+30     	; 0x3bc0 <xTaskGenericCreate+0x1a2>
    3ba2:	80 91 92 1a 	lds	r24, 0x1A92	; 0x801a92 <xSchedulerRunning>
    3ba6:	81 11       	cpse	r24, r1
    3ba8:	0b c0       	rjmp	.+22     	; 0x3bc0 <xTaskGenericCreate+0x1a2>
    3baa:	e0 91 f5 1a 	lds	r30, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    3bae:	f0 91 f6 1a 	lds	r31, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    3bb2:	86 89       	ldd	r24, Z+22	; 0x16
    3bb4:	08 17       	cp	r16, r24
    3bb6:	20 f0       	brcs	.+8      	; 0x3bc0 <xTaskGenericCreate+0x1a2>
    3bb8:	70 92 f6 1a 	sts	0x1AF6, r7	; 0x801af6 <pxCurrentTCB+0x1>
    3bbc:	60 92 f5 1a 	sts	0x1AF5, r6	; 0x801af5 <pxCurrentTCB>
    3bc0:	80 91 8e 1a 	lds	r24, 0x1A8E	; 0x801a8e <uxTaskNumber>
    3bc4:	8f 5f       	subi	r24, 0xFF	; 255
    3bc6:	80 93 8e 1a 	sts	0x1A8E, r24	; 0x801a8e <uxTaskNumber>
    3bca:	f3 01       	movw	r30, r6
    3bcc:	86 89       	ldd	r24, Z+22	; 0x16
    3bce:	90 91 93 1a 	lds	r25, 0x1A93	; 0x801a93 <uxTopReadyPriority>
    3bd2:	98 17       	cp	r25, r24
    3bd4:	10 f4       	brcc	.+4      	; 0x3bda <xTaskGenericCreate+0x1bc>
    3bd6:	80 93 93 1a 	sts	0x1A93, r24	; 0x801a93 <uxTopReadyPriority>
    3bda:	90 e0       	ldi	r25, 0x00	; 0
    3bdc:	9c 01       	movw	r18, r24
    3bde:	22 0f       	add	r18, r18
    3be0:	33 1f       	adc	r19, r19
    3be2:	22 0f       	add	r18, r18
    3be4:	33 1f       	adc	r19, r19
    3be6:	22 0f       	add	r18, r18
    3be8:	33 1f       	adc	r19, r19
    3bea:	82 0f       	add	r24, r18
    3bec:	93 1f       	adc	r25, r19
    3bee:	be 01       	movw	r22, r28
    3bf0:	81 54       	subi	r24, 0x41	; 65
    3bf2:	95 4e       	sbci	r25, 0xE5	; 229
    3bf4:	0e 94 00 06 	call	0xc00	; 0xc00 <vListInsertEnd>
    3bf8:	0f 90       	pop	r0
    3bfa:	0f be       	out	0x3f, r0	; 63
    3bfc:	80 91 92 1a 	lds	r24, 0x1A92	; 0x801a92 <xSchedulerRunning>
    3c00:	88 23       	and	r24, r24
    3c02:	59 f0       	breq	.+22     	; 0x3c1a <xTaskGenericCreate+0x1fc>
    3c04:	e0 91 f5 1a 	lds	r30, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    3c08:	f0 91 f6 1a 	lds	r31, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    3c0c:	86 89       	ldd	r24, Z+22	; 0x16
    3c0e:	80 17       	cp	r24, r16
    3c10:	30 f4       	brcc	.+12     	; 0x3c1e <xTaskGenericCreate+0x200>
    3c12:	0e 94 1a 15 	call	0x2a34	; 0x2a34 <vPortYield>
    3c16:	81 e0       	ldi	r24, 0x01	; 1
    3c18:	05 c0       	rjmp	.+10     	; 0x3c24 <xTaskGenericCreate+0x206>
    3c1a:	81 e0       	ldi	r24, 0x01	; 1
    3c1c:	03 c0       	rjmp	.+6      	; 0x3c24 <xTaskGenericCreate+0x206>
    3c1e:	81 e0       	ldi	r24, 0x01	; 1
    3c20:	01 c0       	rjmp	.+2      	; 0x3c24 <xTaskGenericCreate+0x206>
    3c22:	8f ef       	ldi	r24, 0xFF	; 255
    3c24:	df 91       	pop	r29
    3c26:	cf 91       	pop	r28
    3c28:	1f 91       	pop	r17
    3c2a:	0f 91       	pop	r16
    3c2c:	ff 90       	pop	r15
    3c2e:	ef 90       	pop	r14
    3c30:	df 90       	pop	r13
    3c32:	cf 90       	pop	r12
    3c34:	bf 90       	pop	r11
    3c36:	af 90       	pop	r10
    3c38:	9f 90       	pop	r9
    3c3a:	8f 90       	pop	r8
    3c3c:	7f 90       	pop	r7
    3c3e:	6f 90       	pop	r6
    3c40:	5f 90       	pop	r5
    3c42:	4f 90       	pop	r4
    3c44:	08 95       	ret

00003c46 <vTaskDelayUntil>:
    3c46:	9f 92       	push	r9
    3c48:	af 92       	push	r10
    3c4a:	bf 92       	push	r11
    3c4c:	cf 92       	push	r12
    3c4e:	df 92       	push	r13
    3c50:	ef 92       	push	r14
    3c52:	ff 92       	push	r15
    3c54:	0f 93       	push	r16
    3c56:	1f 93       	push	r17
    3c58:	cf 93       	push	r28
    3c5a:	df 93       	push	r29
    3c5c:	fc 01       	movw	r30, r24
    3c5e:	90 91 8b 1a 	lds	r25, 0x1A8B	; 0x801a8b <uxSchedulerSuspended>
    3c62:	9f 5f       	subi	r25, 0xFF	; 255
    3c64:	90 93 8b 1a 	sts	0x1A8B, r25	; 0x801a8b <uxSchedulerSuspended>
    3c68:	80 91 94 1a 	lds	r24, 0x1A94	; 0x801a94 <xTickCount>
    3c6c:	90 91 95 1a 	lds	r25, 0x1A95	; 0x801a95 <xTickCount+0x1>
    3c70:	20 81       	ld	r18, Z
    3c72:	31 81       	ldd	r19, Z+1	; 0x01
    3c74:	e9 01       	movw	r28, r18
    3c76:	c6 0f       	add	r28, r22
    3c78:	d7 1f       	adc	r29, r23
    3c7a:	82 17       	cp	r24, r18
    3c7c:	93 07       	cpc	r25, r19
    3c7e:	58 f4       	brcc	.+22     	; 0x3c96 <vTaskDelayUntil+0x50>
    3c80:	c2 17       	cp	r28, r18
    3c82:	d3 07       	cpc	r29, r19
    3c84:	08 f0       	brcs	.+2      	; 0x3c88 <vTaskDelayUntil+0x42>
    3c86:	6e c1       	rjmp	.+732    	; 0x3f64 <vTaskDelayUntil+0x31e>
    3c88:	d1 83       	std	Z+1, r29	; 0x01
    3c8a:	c0 83       	st	Z, r28
    3c8c:	8c 17       	cp	r24, r28
    3c8e:	9d 07       	cpc	r25, r29
    3c90:	08 f0       	brcs	.+2      	; 0x3c94 <vTaskDelayUntil+0x4e>
    3c92:	42 c0       	rjmp	.+132    	; 0x3d18 <vTaskDelayUntil+0xd2>
    3c94:	09 c0       	rjmp	.+18     	; 0x3ca8 <vTaskDelayUntil+0x62>
    3c96:	c2 17       	cp	r28, r18
    3c98:	d3 07       	cpc	r29, r19
    3c9a:	08 f4       	brcc	.+2      	; 0x3c9e <vTaskDelayUntil+0x58>
    3c9c:	60 c1       	rjmp	.+704    	; 0x3f5e <vTaskDelayUntil+0x318>
    3c9e:	8c 17       	cp	r24, r28
    3ca0:	9d 07       	cpc	r25, r29
    3ca2:	08 f4       	brcc	.+2      	; 0x3ca6 <vTaskDelayUntil+0x60>
    3ca4:	5c c1       	rjmp	.+696    	; 0x3f5e <vTaskDelayUntil+0x318>
    3ca6:	5e c1       	rjmp	.+700    	; 0x3f64 <vTaskDelayUntil+0x31e>
    3ca8:	80 91 f5 1a 	lds	r24, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    3cac:	90 91 f6 1a 	lds	r25, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    3cb0:	02 96       	adiw	r24, 0x02	; 2
    3cb2:	0e 94 52 06 	call	0xca4	; 0xca4 <uxListRemove>
    3cb6:	e0 91 f5 1a 	lds	r30, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    3cba:	f0 91 f6 1a 	lds	r31, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    3cbe:	d3 83       	std	Z+3, r29	; 0x03
    3cc0:	c2 83       	std	Z+2, r28	; 0x02
    3cc2:	80 91 94 1a 	lds	r24, 0x1A94	; 0x801a94 <xTickCount>
    3cc6:	90 91 95 1a 	lds	r25, 0x1A95	; 0x801a95 <xTickCount+0x1>
    3cca:	c8 17       	cp	r28, r24
    3ccc:	d9 07       	cpc	r29, r25
    3cce:	68 f4       	brcc	.+26     	; 0x3cea <vTaskDelayUntil+0xa4>
    3cd0:	60 91 f5 1a 	lds	r22, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    3cd4:	70 91 f6 1a 	lds	r23, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    3cd8:	80 91 a9 1a 	lds	r24, 0x1AA9	; 0x801aa9 <pxOverflowDelayedTaskList>
    3cdc:	90 91 aa 1a 	lds	r25, 0x1AAA	; 0x801aaa <pxOverflowDelayedTaskList+0x1>
    3ce0:	6e 5f       	subi	r22, 0xFE	; 254
    3ce2:	7f 4f       	sbci	r23, 0xFF	; 255
    3ce4:	0e 94 21 06 	call	0xc42	; 0xc42 <vListInsert>
    3ce8:	17 c0       	rjmp	.+46     	; 0x3d18 <vTaskDelayUntil+0xd2>
    3cea:	60 91 f5 1a 	lds	r22, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    3cee:	70 91 f6 1a 	lds	r23, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    3cf2:	80 91 ab 1a 	lds	r24, 0x1AAB	; 0x801aab <pxDelayedTaskList>
    3cf6:	90 91 ac 1a 	lds	r25, 0x1AAC	; 0x801aac <pxDelayedTaskList+0x1>
    3cfa:	6e 5f       	subi	r22, 0xFE	; 254
    3cfc:	7f 4f       	sbci	r23, 0xFF	; 255
    3cfe:	0e 94 21 06 	call	0xc42	; 0xc42 <vListInsert>
    3d02:	80 91 8c 1a 	lds	r24, 0x1A8C	; 0x801a8c <xNextTaskUnblockTime>
    3d06:	90 91 8d 1a 	lds	r25, 0x1A8D	; 0x801a8d <xNextTaskUnblockTime+0x1>
    3d0a:	c8 17       	cp	r28, r24
    3d0c:	d9 07       	cpc	r29, r25
    3d0e:	20 f4       	brcc	.+8      	; 0x3d18 <vTaskDelayUntil+0xd2>
    3d10:	d0 93 8d 1a 	sts	0x1A8D, r29	; 0x801a8d <xNextTaskUnblockTime+0x1>
    3d14:	c0 93 8c 1a 	sts	0x1A8C, r28	; 0x801a8c <xNextTaskUnblockTime>
    3d18:	0f b6       	in	r0, 0x3f	; 63
    3d1a:	f8 94       	cli
    3d1c:	0f 92       	push	r0
    3d1e:	80 91 8b 1a 	lds	r24, 0x1A8B	; 0x801a8b <uxSchedulerSuspended>
    3d22:	81 50       	subi	r24, 0x01	; 1
    3d24:	80 93 8b 1a 	sts	0x1A8B, r24	; 0x801a8b <uxSchedulerSuspended>
    3d28:	80 91 8b 1a 	lds	r24, 0x1A8B	; 0x801a8b <uxSchedulerSuspended>
    3d2c:	81 11       	cpse	r24, r1
    3d2e:	0d c1       	rjmp	.+538    	; 0x3f4a <vTaskDelayUntil+0x304>
    3d30:	80 91 96 1a 	lds	r24, 0x1A96	; 0x801a96 <uxCurrentNumberOfTasks>
    3d34:	81 11       	cpse	r24, r1
    3d36:	33 c0       	rjmp	.+102    	; 0x3d9e <vTaskDelayUntil+0x158>
    3d38:	0b c1       	rjmp	.+534    	; 0x3f50 <vTaskDelayUntil+0x30a>
    3d3a:	d7 01       	movw	r26, r14
    3d3c:	15 96       	adiw	r26, 0x05	; 5
    3d3e:	ed 91       	ld	r30, X+
    3d40:	fc 91       	ld	r31, X
    3d42:	16 97       	sbiw	r26, 0x06	; 6
    3d44:	c6 81       	ldd	r28, Z+6	; 0x06
    3d46:	d7 81       	ldd	r29, Z+7	; 0x07
    3d48:	ce 01       	movw	r24, r28
    3d4a:	0c 96       	adiw	r24, 0x0c	; 12
    3d4c:	0e 94 52 06 	call	0xca4	; 0xca4 <uxListRemove>
    3d50:	8e 01       	movw	r16, r28
    3d52:	0e 5f       	subi	r16, 0xFE	; 254
    3d54:	1f 4f       	sbci	r17, 0xFF	; 255
    3d56:	c8 01       	movw	r24, r16
    3d58:	0e 94 52 06 	call	0xca4	; 0xca4 <uxListRemove>
    3d5c:	2e 89       	ldd	r18, Y+22	; 0x16
    3d5e:	80 91 93 1a 	lds	r24, 0x1A93	; 0x801a93 <uxTopReadyPriority>
    3d62:	82 17       	cp	r24, r18
    3d64:	10 f4       	brcc	.+4      	; 0x3d6a <vTaskDelayUntil+0x124>
    3d66:	20 93 93 1a 	sts	0x1A93, r18	; 0x801a93 <uxTopReadyPriority>
    3d6a:	30 e0       	ldi	r19, 0x00	; 0
    3d6c:	c9 01       	movw	r24, r18
    3d6e:	88 0f       	add	r24, r24
    3d70:	99 1f       	adc	r25, r25
    3d72:	88 0f       	add	r24, r24
    3d74:	99 1f       	adc	r25, r25
    3d76:	88 0f       	add	r24, r24
    3d78:	99 1f       	adc	r25, r25
    3d7a:	82 0f       	add	r24, r18
    3d7c:	93 1f       	adc	r25, r19
    3d7e:	b8 01       	movw	r22, r16
    3d80:	81 54       	subi	r24, 0x41	; 65
    3d82:	95 4e       	sbci	r25, 0xE5	; 229
    3d84:	0e 94 00 06 	call	0xc00	; 0xc00 <vListInsertEnd>
    3d88:	e0 91 f5 1a 	lds	r30, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    3d8c:	f0 91 f6 1a 	lds	r31, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    3d90:	9e 89       	ldd	r25, Y+22	; 0x16
    3d92:	86 89       	ldd	r24, Z+22	; 0x16
    3d94:	98 17       	cp	r25, r24
    3d96:	58 f0       	brcs	.+22     	; 0x3dae <vTaskDelayUntil+0x168>
    3d98:	d0 92 90 1a 	sts	0x1A90, r13	; 0x801a90 <xYieldPending>
    3d9c:	08 c0       	rjmp	.+16     	; 0x3dae <vTaskDelayUntil+0x168>
    3d9e:	0f 2e       	mov	r0, r31
    3da0:	f0 ea       	ldi	r31, 0xA0	; 160
    3da2:	ef 2e       	mov	r14, r31
    3da4:	fa e1       	ldi	r31, 0x1A	; 26
    3da6:	ff 2e       	mov	r15, r31
    3da8:	f0 2d       	mov	r31, r0
    3daa:	dd 24       	eor	r13, r13
    3dac:	d3 94       	inc	r13
    3dae:	f7 01       	movw	r30, r14
    3db0:	80 81       	ld	r24, Z
    3db2:	81 11       	cpse	r24, r1
    3db4:	c2 cf       	rjmp	.-124    	; 0x3d3a <vTaskDelayUntil+0xf4>
    3db6:	80 91 91 1a 	lds	r24, 0x1A91	; 0x801a91 <uxPendedTicks>
    3dba:	88 23       	and	r24, r24
    3dbc:	09 f4       	brne	.+2      	; 0x3dc0 <vTaskDelayUntil+0x17a>
    3dbe:	bd c0       	rjmp	.+378    	; 0x3f3a <vTaskDelayUntil+0x2f4>
    3dc0:	80 91 91 1a 	lds	r24, 0x1A91	; 0x801a91 <uxPendedTicks>
    3dc4:	88 23       	and	r24, r24
    3dc6:	09 f4       	brne	.+2      	; 0x3dca <vTaskDelayUntil+0x184>
    3dc8:	b8 c0       	rjmp	.+368    	; 0x3f3a <vTaskDelayUntil+0x2f4>
    3dca:	91 2c       	mov	r9, r1
    3dcc:	aa 24       	eor	r10, r10
    3dce:	a3 94       	inc	r10
    3dd0:	cc 24       	eor	r12, r12
    3dd2:	ca 94       	dec	r12
    3dd4:	dc 2c       	mov	r13, r12
    3dd6:	80 91 8b 1a 	lds	r24, 0x1A8B	; 0x801a8b <uxSchedulerSuspended>
    3dda:	81 11       	cpse	r24, r1
    3ddc:	98 c0       	rjmp	.+304    	; 0x3f0e <vTaskDelayUntil+0x2c8>
    3dde:	80 91 94 1a 	lds	r24, 0x1A94	; 0x801a94 <xTickCount>
    3de2:	90 91 95 1a 	lds	r25, 0x1A95	; 0x801a95 <xTickCount+0x1>
    3de6:	01 96       	adiw	r24, 0x01	; 1
    3de8:	90 93 95 1a 	sts	0x1A95, r25	; 0x801a95 <xTickCount+0x1>
    3dec:	80 93 94 1a 	sts	0x1A94, r24	; 0x801a94 <xTickCount>
    3df0:	e0 90 94 1a 	lds	r14, 0x1A94	; 0x801a94 <xTickCount>
    3df4:	f0 90 95 1a 	lds	r15, 0x1A95	; 0x801a95 <xTickCount+0x1>
    3df8:	e1 14       	cp	r14, r1
    3dfa:	f1 04       	cpc	r15, r1
    3dfc:	89 f5       	brne	.+98     	; 0x3e60 <vTaskDelayUntil+0x21a>
    3dfe:	80 91 ab 1a 	lds	r24, 0x1AAB	; 0x801aab <pxDelayedTaskList>
    3e02:	90 91 ac 1a 	lds	r25, 0x1AAC	; 0x801aac <pxDelayedTaskList+0x1>
    3e06:	20 91 a9 1a 	lds	r18, 0x1AA9	; 0x801aa9 <pxOverflowDelayedTaskList>
    3e0a:	30 91 aa 1a 	lds	r19, 0x1AAA	; 0x801aaa <pxOverflowDelayedTaskList+0x1>
    3e0e:	30 93 ac 1a 	sts	0x1AAC, r19	; 0x801aac <pxDelayedTaskList+0x1>
    3e12:	20 93 ab 1a 	sts	0x1AAB, r18	; 0x801aab <pxDelayedTaskList>
    3e16:	90 93 aa 1a 	sts	0x1AAA, r25	; 0x801aaa <pxOverflowDelayedTaskList+0x1>
    3e1a:	80 93 a9 1a 	sts	0x1AA9, r24	; 0x801aa9 <pxOverflowDelayedTaskList>
    3e1e:	80 91 8f 1a 	lds	r24, 0x1A8F	; 0x801a8f <xNumOfOverflows>
    3e22:	8f 5f       	subi	r24, 0xFF	; 255
    3e24:	80 93 8f 1a 	sts	0x1A8F, r24	; 0x801a8f <xNumOfOverflows>
    3e28:	e0 91 ab 1a 	lds	r30, 0x1AAB	; 0x801aab <pxDelayedTaskList>
    3e2c:	f0 91 ac 1a 	lds	r31, 0x1AAC	; 0x801aac <pxDelayedTaskList+0x1>
    3e30:	80 81       	ld	r24, Z
    3e32:	81 11       	cpse	r24, r1
    3e34:	05 c0       	rjmp	.+10     	; 0x3e40 <vTaskDelayUntil+0x1fa>
    3e36:	d0 92 8d 1a 	sts	0x1A8D, r13	; 0x801a8d <xNextTaskUnblockTime+0x1>
    3e3a:	c0 92 8c 1a 	sts	0x1A8C, r12	; 0x801a8c <xNextTaskUnblockTime>
    3e3e:	10 c0       	rjmp	.+32     	; 0x3e60 <vTaskDelayUntil+0x21a>
    3e40:	e0 91 ab 1a 	lds	r30, 0x1AAB	; 0x801aab <pxDelayedTaskList>
    3e44:	f0 91 ac 1a 	lds	r31, 0x1AAC	; 0x801aac <pxDelayedTaskList+0x1>
    3e48:	05 80       	ldd	r0, Z+5	; 0x05
    3e4a:	f6 81       	ldd	r31, Z+6	; 0x06
    3e4c:	e0 2d       	mov	r30, r0
    3e4e:	06 80       	ldd	r0, Z+6	; 0x06
    3e50:	f7 81       	ldd	r31, Z+7	; 0x07
    3e52:	e0 2d       	mov	r30, r0
    3e54:	82 81       	ldd	r24, Z+2	; 0x02
    3e56:	93 81       	ldd	r25, Z+3	; 0x03
    3e58:	90 93 8d 1a 	sts	0x1A8D, r25	; 0x801a8d <xNextTaskUnblockTime+0x1>
    3e5c:	80 93 8c 1a 	sts	0x1A8C, r24	; 0x801a8c <xNextTaskUnblockTime>
    3e60:	80 91 8c 1a 	lds	r24, 0x1A8C	; 0x801a8c <xNextTaskUnblockTime>
    3e64:	90 91 8d 1a 	lds	r25, 0x1A8D	; 0x801a8d <xNextTaskUnblockTime+0x1>
    3e68:	e8 16       	cp	r14, r24
    3e6a:	f9 06       	cpc	r15, r25
    3e6c:	08 f4       	brcc	.+2      	; 0x3e70 <vTaskDelayUntil+0x22a>
    3e6e:	7d c0       	rjmp	.+250    	; 0x3f6a <vTaskDelayUntil+0x324>
    3e70:	b9 2c       	mov	r11, r9
    3e72:	e0 91 ab 1a 	lds	r30, 0x1AAB	; 0x801aab <pxDelayedTaskList>
    3e76:	f0 91 ac 1a 	lds	r31, 0x1AAC	; 0x801aac <pxDelayedTaskList+0x1>
    3e7a:	80 81       	ld	r24, Z
    3e7c:	81 11       	cpse	r24, r1
    3e7e:	05 c0       	rjmp	.+10     	; 0x3e8a <vTaskDelayUntil+0x244>
    3e80:	d0 92 8d 1a 	sts	0x1A8D, r13	; 0x801a8d <xNextTaskUnblockTime+0x1>
    3e84:	c0 92 8c 1a 	sts	0x1A8C, r12	; 0x801a8c <xNextTaskUnblockTime>
    3e88:	48 c0       	rjmp	.+144    	; 0x3f1a <vTaskDelayUntil+0x2d4>
    3e8a:	e0 91 ab 1a 	lds	r30, 0x1AAB	; 0x801aab <pxDelayedTaskList>
    3e8e:	f0 91 ac 1a 	lds	r31, 0x1AAC	; 0x801aac <pxDelayedTaskList+0x1>
    3e92:	05 80       	ldd	r0, Z+5	; 0x05
    3e94:	f6 81       	ldd	r31, Z+6	; 0x06
    3e96:	e0 2d       	mov	r30, r0
    3e98:	c6 81       	ldd	r28, Z+6	; 0x06
    3e9a:	d7 81       	ldd	r29, Z+7	; 0x07
    3e9c:	8a 81       	ldd	r24, Y+2	; 0x02
    3e9e:	9b 81       	ldd	r25, Y+3	; 0x03
    3ea0:	e8 16       	cp	r14, r24
    3ea2:	f9 06       	cpc	r15, r25
    3ea4:	28 f4       	brcc	.+10     	; 0x3eb0 <vTaskDelayUntil+0x26a>
    3ea6:	90 93 8d 1a 	sts	0x1A8D, r25	; 0x801a8d <xNextTaskUnblockTime+0x1>
    3eaa:	80 93 8c 1a 	sts	0x1A8C, r24	; 0x801a8c <xNextTaskUnblockTime>
    3eae:	35 c0       	rjmp	.+106    	; 0x3f1a <vTaskDelayUntil+0x2d4>
    3eb0:	8e 01       	movw	r16, r28
    3eb2:	0e 5f       	subi	r16, 0xFE	; 254
    3eb4:	1f 4f       	sbci	r17, 0xFF	; 255
    3eb6:	c8 01       	movw	r24, r16
    3eb8:	0e 94 52 06 	call	0xca4	; 0xca4 <uxListRemove>
    3ebc:	8c 89       	ldd	r24, Y+20	; 0x14
    3ebe:	9d 89       	ldd	r25, Y+21	; 0x15
    3ec0:	89 2b       	or	r24, r25
    3ec2:	21 f0       	breq	.+8      	; 0x3ecc <vTaskDelayUntil+0x286>
    3ec4:	ce 01       	movw	r24, r28
    3ec6:	0c 96       	adiw	r24, 0x0c	; 12
    3ec8:	0e 94 52 06 	call	0xca4	; 0xca4 <uxListRemove>
    3ecc:	2e 89       	ldd	r18, Y+22	; 0x16
    3ece:	80 91 93 1a 	lds	r24, 0x1A93	; 0x801a93 <uxTopReadyPriority>
    3ed2:	82 17       	cp	r24, r18
    3ed4:	10 f4       	brcc	.+4      	; 0x3eda <vTaskDelayUntil+0x294>
    3ed6:	20 93 93 1a 	sts	0x1A93, r18	; 0x801a93 <uxTopReadyPriority>
    3eda:	30 e0       	ldi	r19, 0x00	; 0
    3edc:	c9 01       	movw	r24, r18
    3ede:	88 0f       	add	r24, r24
    3ee0:	99 1f       	adc	r25, r25
    3ee2:	88 0f       	add	r24, r24
    3ee4:	99 1f       	adc	r25, r25
    3ee6:	88 0f       	add	r24, r24
    3ee8:	99 1f       	adc	r25, r25
    3eea:	82 0f       	add	r24, r18
    3eec:	93 1f       	adc	r25, r19
    3eee:	b8 01       	movw	r22, r16
    3ef0:	81 54       	subi	r24, 0x41	; 65
    3ef2:	95 4e       	sbci	r25, 0xE5	; 229
    3ef4:	0e 94 00 06 	call	0xc00	; 0xc00 <vListInsertEnd>
    3ef8:	e0 91 f5 1a 	lds	r30, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    3efc:	f0 91 f6 1a 	lds	r31, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    3f00:	9e 89       	ldd	r25, Y+22	; 0x16
    3f02:	86 89       	ldd	r24, Z+22	; 0x16
    3f04:	98 17       	cp	r25, r24
    3f06:	08 f4       	brcc	.+2      	; 0x3f0a <vTaskDelayUntil+0x2c4>
    3f08:	b4 cf       	rjmp	.-152    	; 0x3e72 <vTaskDelayUntil+0x22c>
    3f0a:	ba 2c       	mov	r11, r10
    3f0c:	b2 cf       	rjmp	.-156    	; 0x3e72 <vTaskDelayUntil+0x22c>
    3f0e:	80 91 91 1a 	lds	r24, 0x1A91	; 0x801a91 <uxPendedTicks>
    3f12:	8f 5f       	subi	r24, 0xFF	; 255
    3f14:	80 93 91 1a 	sts	0x1A91, r24	; 0x801a91 <uxPendedTicks>
    3f18:	28 c0       	rjmp	.+80     	; 0x3f6a <vTaskDelayUntil+0x324>
    3f1a:	80 91 90 1a 	lds	r24, 0x1A90	; 0x801a90 <xYieldPending>
    3f1e:	81 11       	cpse	r24, r1
    3f20:	01 c0       	rjmp	.+2      	; 0x3f24 <vTaskDelayUntil+0x2de>
    3f22:	b1 10       	cpse	r11, r1
    3f24:	a0 92 90 1a 	sts	0x1A90, r10	; 0x801a90 <xYieldPending>
    3f28:	80 91 91 1a 	lds	r24, 0x1A91	; 0x801a91 <uxPendedTicks>
    3f2c:	81 50       	subi	r24, 0x01	; 1
    3f2e:	80 93 91 1a 	sts	0x1A91, r24	; 0x801a91 <uxPendedTicks>
    3f32:	80 91 91 1a 	lds	r24, 0x1A91	; 0x801a91 <uxPendedTicks>
    3f36:	81 11       	cpse	r24, r1
    3f38:	4e cf       	rjmp	.-356    	; 0x3dd6 <vTaskDelayUntil+0x190>
    3f3a:	80 91 90 1a 	lds	r24, 0x1A90	; 0x801a90 <xYieldPending>
    3f3e:	81 30       	cpi	r24, 0x01	; 1
    3f40:	31 f4       	brne	.+12     	; 0x3f4e <vTaskDelayUntil+0x308>
    3f42:	0e 94 1a 15 	call	0x2a34	; 0x2a34 <vPortYield>
    3f46:	81 e0       	ldi	r24, 0x01	; 1
    3f48:	03 c0       	rjmp	.+6      	; 0x3f50 <vTaskDelayUntil+0x30a>
    3f4a:	80 e0       	ldi	r24, 0x00	; 0
    3f4c:	01 c0       	rjmp	.+2      	; 0x3f50 <vTaskDelayUntil+0x30a>
    3f4e:	80 e0       	ldi	r24, 0x00	; 0
    3f50:	0f 90       	pop	r0
    3f52:	0f be       	out	0x3f, r0	; 63
    3f54:	81 11       	cpse	r24, r1
    3f56:	0e c0       	rjmp	.+28     	; 0x3f74 <vTaskDelayUntil+0x32e>
    3f58:	0e 94 1a 15 	call	0x2a34	; 0x2a34 <vPortYield>
    3f5c:	0b c0       	rjmp	.+22     	; 0x3f74 <vTaskDelayUntil+0x32e>
    3f5e:	d1 83       	std	Z+1, r29	; 0x01
    3f60:	c0 83       	st	Z, r28
    3f62:	a2 ce       	rjmp	.-700    	; 0x3ca8 <vTaskDelayUntil+0x62>
    3f64:	d1 83       	std	Z+1, r29	; 0x01
    3f66:	c0 83       	st	Z, r28
    3f68:	d7 ce       	rjmp	.-594    	; 0x3d18 <vTaskDelayUntil+0xd2>
    3f6a:	80 91 90 1a 	lds	r24, 0x1A90	; 0x801a90 <xYieldPending>
    3f6e:	88 23       	and	r24, r24
    3f70:	d9 f2       	breq	.-74     	; 0x3f28 <vTaskDelayUntil+0x2e2>
    3f72:	d8 cf       	rjmp	.-80     	; 0x3f24 <vTaskDelayUntil+0x2de>
    3f74:	df 91       	pop	r29
    3f76:	cf 91       	pop	r28
    3f78:	1f 91       	pop	r17
    3f7a:	0f 91       	pop	r16
    3f7c:	ff 90       	pop	r15
    3f7e:	ef 90       	pop	r14
    3f80:	df 90       	pop	r13
    3f82:	cf 90       	pop	r12
    3f84:	bf 90       	pop	r11
    3f86:	af 90       	pop	r10
    3f88:	9f 90       	pop	r9
    3f8a:	08 95       	ret

00003f8c <vTaskDelay>:
    3f8c:	9f 92       	push	r9
    3f8e:	af 92       	push	r10
    3f90:	bf 92       	push	r11
    3f92:	cf 92       	push	r12
    3f94:	df 92       	push	r13
    3f96:	ef 92       	push	r14
    3f98:	ff 92       	push	r15
    3f9a:	0f 93       	push	r16
    3f9c:	1f 93       	push	r17
    3f9e:	cf 93       	push	r28
    3fa0:	df 93       	push	r29
    3fa2:	00 97       	sbiw	r24, 0x00	; 0
    3fa4:	09 f4       	brne	.+2      	; 0x3fa8 <vTaskDelay+0x1c>
    3fa6:	63 c1       	rjmp	.+710    	; 0x426e <vTaskDelay+0x2e2>
    3fa8:	20 91 8b 1a 	lds	r18, 0x1A8B	; 0x801a8b <uxSchedulerSuspended>
    3fac:	2f 5f       	subi	r18, 0xFF	; 255
    3fae:	20 93 8b 1a 	sts	0x1A8B, r18	; 0x801a8b <uxSchedulerSuspended>
    3fb2:	c0 91 94 1a 	lds	r28, 0x1A94	; 0x801a94 <xTickCount>
    3fb6:	d0 91 95 1a 	lds	r29, 0x1A95	; 0x801a95 <xTickCount+0x1>
    3fba:	c8 0f       	add	r28, r24
    3fbc:	d9 1f       	adc	r29, r25
    3fbe:	80 91 f5 1a 	lds	r24, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    3fc2:	90 91 f6 1a 	lds	r25, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    3fc6:	02 96       	adiw	r24, 0x02	; 2
    3fc8:	0e 94 52 06 	call	0xca4	; 0xca4 <uxListRemove>
    3fcc:	e0 91 f5 1a 	lds	r30, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    3fd0:	f0 91 f6 1a 	lds	r31, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    3fd4:	d3 83       	std	Z+3, r29	; 0x03
    3fd6:	c2 83       	std	Z+2, r28	; 0x02
    3fd8:	80 91 94 1a 	lds	r24, 0x1A94	; 0x801a94 <xTickCount>
    3fdc:	90 91 95 1a 	lds	r25, 0x1A95	; 0x801a95 <xTickCount+0x1>
    3fe0:	c8 17       	cp	r28, r24
    3fe2:	d9 07       	cpc	r29, r25
    3fe4:	68 f4       	brcc	.+26     	; 0x4000 <vTaskDelay+0x74>
    3fe6:	60 91 f5 1a 	lds	r22, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    3fea:	70 91 f6 1a 	lds	r23, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    3fee:	80 91 a9 1a 	lds	r24, 0x1AA9	; 0x801aa9 <pxOverflowDelayedTaskList>
    3ff2:	90 91 aa 1a 	lds	r25, 0x1AAA	; 0x801aaa <pxOverflowDelayedTaskList+0x1>
    3ff6:	6e 5f       	subi	r22, 0xFE	; 254
    3ff8:	7f 4f       	sbci	r23, 0xFF	; 255
    3ffa:	0e 94 21 06 	call	0xc42	; 0xc42 <vListInsert>
    3ffe:	17 c0       	rjmp	.+46     	; 0x402e <vTaskDelay+0xa2>
    4000:	60 91 f5 1a 	lds	r22, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    4004:	70 91 f6 1a 	lds	r23, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    4008:	80 91 ab 1a 	lds	r24, 0x1AAB	; 0x801aab <pxDelayedTaskList>
    400c:	90 91 ac 1a 	lds	r25, 0x1AAC	; 0x801aac <pxDelayedTaskList+0x1>
    4010:	6e 5f       	subi	r22, 0xFE	; 254
    4012:	7f 4f       	sbci	r23, 0xFF	; 255
    4014:	0e 94 21 06 	call	0xc42	; 0xc42 <vListInsert>
    4018:	80 91 8c 1a 	lds	r24, 0x1A8C	; 0x801a8c <xNextTaskUnblockTime>
    401c:	90 91 8d 1a 	lds	r25, 0x1A8D	; 0x801a8d <xNextTaskUnblockTime+0x1>
    4020:	c8 17       	cp	r28, r24
    4022:	d9 07       	cpc	r29, r25
    4024:	20 f4       	brcc	.+8      	; 0x402e <vTaskDelay+0xa2>
    4026:	d0 93 8d 1a 	sts	0x1A8D, r29	; 0x801a8d <xNextTaskUnblockTime+0x1>
    402a:	c0 93 8c 1a 	sts	0x1A8C, r28	; 0x801a8c <xNextTaskUnblockTime>
    402e:	0f b6       	in	r0, 0x3f	; 63
    4030:	f8 94       	cli
    4032:	0f 92       	push	r0
    4034:	80 91 8b 1a 	lds	r24, 0x1A8B	; 0x801a8b <uxSchedulerSuspended>
    4038:	81 50       	subi	r24, 0x01	; 1
    403a:	80 93 8b 1a 	sts	0x1A8B, r24	; 0x801a8b <uxSchedulerSuspended>
    403e:	80 91 8b 1a 	lds	r24, 0x1A8B	; 0x801a8b <uxSchedulerSuspended>
    4042:	81 11       	cpse	r24, r1
    4044:	0d c1       	rjmp	.+538    	; 0x4260 <vTaskDelay+0x2d4>
    4046:	80 91 96 1a 	lds	r24, 0x1A96	; 0x801a96 <uxCurrentNumberOfTasks>
    404a:	81 11       	cpse	r24, r1
    404c:	33 c0       	rjmp	.+102    	; 0x40b4 <vTaskDelay+0x128>
    404e:	0b c1       	rjmp	.+534    	; 0x4266 <vTaskDelay+0x2da>
    4050:	d7 01       	movw	r26, r14
    4052:	15 96       	adiw	r26, 0x05	; 5
    4054:	ed 91       	ld	r30, X+
    4056:	fc 91       	ld	r31, X
    4058:	16 97       	sbiw	r26, 0x06	; 6
    405a:	c6 81       	ldd	r28, Z+6	; 0x06
    405c:	d7 81       	ldd	r29, Z+7	; 0x07
    405e:	ce 01       	movw	r24, r28
    4060:	0c 96       	adiw	r24, 0x0c	; 12
    4062:	0e 94 52 06 	call	0xca4	; 0xca4 <uxListRemove>
    4066:	8e 01       	movw	r16, r28
    4068:	0e 5f       	subi	r16, 0xFE	; 254
    406a:	1f 4f       	sbci	r17, 0xFF	; 255
    406c:	c8 01       	movw	r24, r16
    406e:	0e 94 52 06 	call	0xca4	; 0xca4 <uxListRemove>
    4072:	2e 89       	ldd	r18, Y+22	; 0x16
    4074:	80 91 93 1a 	lds	r24, 0x1A93	; 0x801a93 <uxTopReadyPriority>
    4078:	82 17       	cp	r24, r18
    407a:	10 f4       	brcc	.+4      	; 0x4080 <vTaskDelay+0xf4>
    407c:	20 93 93 1a 	sts	0x1A93, r18	; 0x801a93 <uxTopReadyPriority>
    4080:	30 e0       	ldi	r19, 0x00	; 0
    4082:	c9 01       	movw	r24, r18
    4084:	88 0f       	add	r24, r24
    4086:	99 1f       	adc	r25, r25
    4088:	88 0f       	add	r24, r24
    408a:	99 1f       	adc	r25, r25
    408c:	88 0f       	add	r24, r24
    408e:	99 1f       	adc	r25, r25
    4090:	82 0f       	add	r24, r18
    4092:	93 1f       	adc	r25, r19
    4094:	b8 01       	movw	r22, r16
    4096:	81 54       	subi	r24, 0x41	; 65
    4098:	95 4e       	sbci	r25, 0xE5	; 229
    409a:	0e 94 00 06 	call	0xc00	; 0xc00 <vListInsertEnd>
    409e:	e0 91 f5 1a 	lds	r30, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    40a2:	f0 91 f6 1a 	lds	r31, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    40a6:	9e 89       	ldd	r25, Y+22	; 0x16
    40a8:	86 89       	ldd	r24, Z+22	; 0x16
    40aa:	98 17       	cp	r25, r24
    40ac:	58 f0       	brcs	.+22     	; 0x40c4 <vTaskDelay+0x138>
    40ae:	d0 92 90 1a 	sts	0x1A90, r13	; 0x801a90 <xYieldPending>
    40b2:	08 c0       	rjmp	.+16     	; 0x40c4 <vTaskDelay+0x138>
    40b4:	0f 2e       	mov	r0, r31
    40b6:	f0 ea       	ldi	r31, 0xA0	; 160
    40b8:	ef 2e       	mov	r14, r31
    40ba:	fa e1       	ldi	r31, 0x1A	; 26
    40bc:	ff 2e       	mov	r15, r31
    40be:	f0 2d       	mov	r31, r0
    40c0:	dd 24       	eor	r13, r13
    40c2:	d3 94       	inc	r13
    40c4:	f7 01       	movw	r30, r14
    40c6:	80 81       	ld	r24, Z
    40c8:	81 11       	cpse	r24, r1
    40ca:	c2 cf       	rjmp	.-124    	; 0x4050 <vTaskDelay+0xc4>
    40cc:	80 91 91 1a 	lds	r24, 0x1A91	; 0x801a91 <uxPendedTicks>
    40d0:	88 23       	and	r24, r24
    40d2:	09 f4       	brne	.+2      	; 0x40d6 <vTaskDelay+0x14a>
    40d4:	bd c0       	rjmp	.+378    	; 0x4250 <vTaskDelay+0x2c4>
    40d6:	80 91 91 1a 	lds	r24, 0x1A91	; 0x801a91 <uxPendedTicks>
    40da:	88 23       	and	r24, r24
    40dc:	09 f4       	brne	.+2      	; 0x40e0 <vTaskDelay+0x154>
    40de:	b8 c0       	rjmp	.+368    	; 0x4250 <vTaskDelay+0x2c4>
    40e0:	91 2c       	mov	r9, r1
    40e2:	aa 24       	eor	r10, r10
    40e4:	a3 94       	inc	r10
    40e6:	cc 24       	eor	r12, r12
    40e8:	ca 94       	dec	r12
    40ea:	dc 2c       	mov	r13, r12
    40ec:	80 91 8b 1a 	lds	r24, 0x1A8B	; 0x801a8b <uxSchedulerSuspended>
    40f0:	81 11       	cpse	r24, r1
    40f2:	98 c0       	rjmp	.+304    	; 0x4224 <vTaskDelay+0x298>
    40f4:	80 91 94 1a 	lds	r24, 0x1A94	; 0x801a94 <xTickCount>
    40f8:	90 91 95 1a 	lds	r25, 0x1A95	; 0x801a95 <xTickCount+0x1>
    40fc:	01 96       	adiw	r24, 0x01	; 1
    40fe:	90 93 95 1a 	sts	0x1A95, r25	; 0x801a95 <xTickCount+0x1>
    4102:	80 93 94 1a 	sts	0x1A94, r24	; 0x801a94 <xTickCount>
    4106:	e0 90 94 1a 	lds	r14, 0x1A94	; 0x801a94 <xTickCount>
    410a:	f0 90 95 1a 	lds	r15, 0x1A95	; 0x801a95 <xTickCount+0x1>
    410e:	e1 14       	cp	r14, r1
    4110:	f1 04       	cpc	r15, r1
    4112:	89 f5       	brne	.+98     	; 0x4176 <vTaskDelay+0x1ea>
    4114:	80 91 ab 1a 	lds	r24, 0x1AAB	; 0x801aab <pxDelayedTaskList>
    4118:	90 91 ac 1a 	lds	r25, 0x1AAC	; 0x801aac <pxDelayedTaskList+0x1>
    411c:	20 91 a9 1a 	lds	r18, 0x1AA9	; 0x801aa9 <pxOverflowDelayedTaskList>
    4120:	30 91 aa 1a 	lds	r19, 0x1AAA	; 0x801aaa <pxOverflowDelayedTaskList+0x1>
    4124:	30 93 ac 1a 	sts	0x1AAC, r19	; 0x801aac <pxDelayedTaskList+0x1>
    4128:	20 93 ab 1a 	sts	0x1AAB, r18	; 0x801aab <pxDelayedTaskList>
    412c:	90 93 aa 1a 	sts	0x1AAA, r25	; 0x801aaa <pxOverflowDelayedTaskList+0x1>
    4130:	80 93 a9 1a 	sts	0x1AA9, r24	; 0x801aa9 <pxOverflowDelayedTaskList>
    4134:	80 91 8f 1a 	lds	r24, 0x1A8F	; 0x801a8f <xNumOfOverflows>
    4138:	8f 5f       	subi	r24, 0xFF	; 255
    413a:	80 93 8f 1a 	sts	0x1A8F, r24	; 0x801a8f <xNumOfOverflows>
    413e:	e0 91 ab 1a 	lds	r30, 0x1AAB	; 0x801aab <pxDelayedTaskList>
    4142:	f0 91 ac 1a 	lds	r31, 0x1AAC	; 0x801aac <pxDelayedTaskList+0x1>
    4146:	80 81       	ld	r24, Z
    4148:	81 11       	cpse	r24, r1
    414a:	05 c0       	rjmp	.+10     	; 0x4156 <vTaskDelay+0x1ca>
    414c:	d0 92 8d 1a 	sts	0x1A8D, r13	; 0x801a8d <xNextTaskUnblockTime+0x1>
    4150:	c0 92 8c 1a 	sts	0x1A8C, r12	; 0x801a8c <xNextTaskUnblockTime>
    4154:	10 c0       	rjmp	.+32     	; 0x4176 <vTaskDelay+0x1ea>
    4156:	e0 91 ab 1a 	lds	r30, 0x1AAB	; 0x801aab <pxDelayedTaskList>
    415a:	f0 91 ac 1a 	lds	r31, 0x1AAC	; 0x801aac <pxDelayedTaskList+0x1>
    415e:	05 80       	ldd	r0, Z+5	; 0x05
    4160:	f6 81       	ldd	r31, Z+6	; 0x06
    4162:	e0 2d       	mov	r30, r0
    4164:	06 80       	ldd	r0, Z+6	; 0x06
    4166:	f7 81       	ldd	r31, Z+7	; 0x07
    4168:	e0 2d       	mov	r30, r0
    416a:	82 81       	ldd	r24, Z+2	; 0x02
    416c:	93 81       	ldd	r25, Z+3	; 0x03
    416e:	90 93 8d 1a 	sts	0x1A8D, r25	; 0x801a8d <xNextTaskUnblockTime+0x1>
    4172:	80 93 8c 1a 	sts	0x1A8C, r24	; 0x801a8c <xNextTaskUnblockTime>
    4176:	80 91 8c 1a 	lds	r24, 0x1A8C	; 0x801a8c <xNextTaskUnblockTime>
    417a:	90 91 8d 1a 	lds	r25, 0x1A8D	; 0x801a8d <xNextTaskUnblockTime+0x1>
    417e:	e8 16       	cp	r14, r24
    4180:	f9 06       	cpc	r15, r25
    4182:	08 f4       	brcc	.+2      	; 0x4186 <vTaskDelay+0x1fa>
    4184:	77 c0       	rjmp	.+238    	; 0x4274 <vTaskDelay+0x2e8>
    4186:	b9 2c       	mov	r11, r9
    4188:	e0 91 ab 1a 	lds	r30, 0x1AAB	; 0x801aab <pxDelayedTaskList>
    418c:	f0 91 ac 1a 	lds	r31, 0x1AAC	; 0x801aac <pxDelayedTaskList+0x1>
    4190:	80 81       	ld	r24, Z
    4192:	81 11       	cpse	r24, r1
    4194:	05 c0       	rjmp	.+10     	; 0x41a0 <vTaskDelay+0x214>
    4196:	d0 92 8d 1a 	sts	0x1A8D, r13	; 0x801a8d <xNextTaskUnblockTime+0x1>
    419a:	c0 92 8c 1a 	sts	0x1A8C, r12	; 0x801a8c <xNextTaskUnblockTime>
    419e:	48 c0       	rjmp	.+144    	; 0x4230 <vTaskDelay+0x2a4>
    41a0:	e0 91 ab 1a 	lds	r30, 0x1AAB	; 0x801aab <pxDelayedTaskList>
    41a4:	f0 91 ac 1a 	lds	r31, 0x1AAC	; 0x801aac <pxDelayedTaskList+0x1>
    41a8:	05 80       	ldd	r0, Z+5	; 0x05
    41aa:	f6 81       	ldd	r31, Z+6	; 0x06
    41ac:	e0 2d       	mov	r30, r0
    41ae:	c6 81       	ldd	r28, Z+6	; 0x06
    41b0:	d7 81       	ldd	r29, Z+7	; 0x07
    41b2:	8a 81       	ldd	r24, Y+2	; 0x02
    41b4:	9b 81       	ldd	r25, Y+3	; 0x03
    41b6:	e8 16       	cp	r14, r24
    41b8:	f9 06       	cpc	r15, r25
    41ba:	28 f4       	brcc	.+10     	; 0x41c6 <vTaskDelay+0x23a>
    41bc:	90 93 8d 1a 	sts	0x1A8D, r25	; 0x801a8d <xNextTaskUnblockTime+0x1>
    41c0:	80 93 8c 1a 	sts	0x1A8C, r24	; 0x801a8c <xNextTaskUnblockTime>
    41c4:	35 c0       	rjmp	.+106    	; 0x4230 <vTaskDelay+0x2a4>
    41c6:	8e 01       	movw	r16, r28
    41c8:	0e 5f       	subi	r16, 0xFE	; 254
    41ca:	1f 4f       	sbci	r17, 0xFF	; 255
    41cc:	c8 01       	movw	r24, r16
    41ce:	0e 94 52 06 	call	0xca4	; 0xca4 <uxListRemove>
    41d2:	8c 89       	ldd	r24, Y+20	; 0x14
    41d4:	9d 89       	ldd	r25, Y+21	; 0x15
    41d6:	89 2b       	or	r24, r25
    41d8:	21 f0       	breq	.+8      	; 0x41e2 <vTaskDelay+0x256>
    41da:	ce 01       	movw	r24, r28
    41dc:	0c 96       	adiw	r24, 0x0c	; 12
    41de:	0e 94 52 06 	call	0xca4	; 0xca4 <uxListRemove>
    41e2:	2e 89       	ldd	r18, Y+22	; 0x16
    41e4:	80 91 93 1a 	lds	r24, 0x1A93	; 0x801a93 <uxTopReadyPriority>
    41e8:	82 17       	cp	r24, r18
    41ea:	10 f4       	brcc	.+4      	; 0x41f0 <vTaskDelay+0x264>
    41ec:	20 93 93 1a 	sts	0x1A93, r18	; 0x801a93 <uxTopReadyPriority>
    41f0:	30 e0       	ldi	r19, 0x00	; 0
    41f2:	c9 01       	movw	r24, r18
    41f4:	88 0f       	add	r24, r24
    41f6:	99 1f       	adc	r25, r25
    41f8:	88 0f       	add	r24, r24
    41fa:	99 1f       	adc	r25, r25
    41fc:	88 0f       	add	r24, r24
    41fe:	99 1f       	adc	r25, r25
    4200:	82 0f       	add	r24, r18
    4202:	93 1f       	adc	r25, r19
    4204:	b8 01       	movw	r22, r16
    4206:	81 54       	subi	r24, 0x41	; 65
    4208:	95 4e       	sbci	r25, 0xE5	; 229
    420a:	0e 94 00 06 	call	0xc00	; 0xc00 <vListInsertEnd>
    420e:	e0 91 f5 1a 	lds	r30, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    4212:	f0 91 f6 1a 	lds	r31, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    4216:	9e 89       	ldd	r25, Y+22	; 0x16
    4218:	86 89       	ldd	r24, Z+22	; 0x16
    421a:	98 17       	cp	r25, r24
    421c:	08 f4       	brcc	.+2      	; 0x4220 <vTaskDelay+0x294>
    421e:	b4 cf       	rjmp	.-152    	; 0x4188 <vTaskDelay+0x1fc>
    4220:	ba 2c       	mov	r11, r10
    4222:	b2 cf       	rjmp	.-156    	; 0x4188 <vTaskDelay+0x1fc>
    4224:	80 91 91 1a 	lds	r24, 0x1A91	; 0x801a91 <uxPendedTicks>
    4228:	8f 5f       	subi	r24, 0xFF	; 255
    422a:	80 93 91 1a 	sts	0x1A91, r24	; 0x801a91 <uxPendedTicks>
    422e:	22 c0       	rjmp	.+68     	; 0x4274 <vTaskDelay+0x2e8>
    4230:	80 91 90 1a 	lds	r24, 0x1A90	; 0x801a90 <xYieldPending>
    4234:	81 11       	cpse	r24, r1
    4236:	01 c0       	rjmp	.+2      	; 0x423a <vTaskDelay+0x2ae>
    4238:	b1 10       	cpse	r11, r1
    423a:	a0 92 90 1a 	sts	0x1A90, r10	; 0x801a90 <xYieldPending>
    423e:	80 91 91 1a 	lds	r24, 0x1A91	; 0x801a91 <uxPendedTicks>
    4242:	81 50       	subi	r24, 0x01	; 1
    4244:	80 93 91 1a 	sts	0x1A91, r24	; 0x801a91 <uxPendedTicks>
    4248:	80 91 91 1a 	lds	r24, 0x1A91	; 0x801a91 <uxPendedTicks>
    424c:	81 11       	cpse	r24, r1
    424e:	4e cf       	rjmp	.-356    	; 0x40ec <vTaskDelay+0x160>
    4250:	80 91 90 1a 	lds	r24, 0x1A90	; 0x801a90 <xYieldPending>
    4254:	81 30       	cpi	r24, 0x01	; 1
    4256:	31 f4       	brne	.+12     	; 0x4264 <vTaskDelay+0x2d8>
    4258:	0e 94 1a 15 	call	0x2a34	; 0x2a34 <vPortYield>
    425c:	81 e0       	ldi	r24, 0x01	; 1
    425e:	03 c0       	rjmp	.+6      	; 0x4266 <vTaskDelay+0x2da>
    4260:	80 e0       	ldi	r24, 0x00	; 0
    4262:	01 c0       	rjmp	.+2      	; 0x4266 <vTaskDelay+0x2da>
    4264:	80 e0       	ldi	r24, 0x00	; 0
    4266:	0f 90       	pop	r0
    4268:	0f be       	out	0x3f, r0	; 63
    426a:	81 11       	cpse	r24, r1
    426c:	08 c0       	rjmp	.+16     	; 0x427e <vTaskDelay+0x2f2>
    426e:	0e 94 1a 15 	call	0x2a34	; 0x2a34 <vPortYield>
    4272:	05 c0       	rjmp	.+10     	; 0x427e <vTaskDelay+0x2f2>
    4274:	80 91 90 1a 	lds	r24, 0x1A90	; 0x801a90 <xYieldPending>
    4278:	88 23       	and	r24, r24
    427a:	09 f3       	breq	.-62     	; 0x423e <vTaskDelay+0x2b2>
    427c:	de cf       	rjmp	.-68     	; 0x423a <vTaskDelay+0x2ae>
    427e:	df 91       	pop	r29
    4280:	cf 91       	pop	r28
    4282:	1f 91       	pop	r17
    4284:	0f 91       	pop	r16
    4286:	ff 90       	pop	r15
    4288:	ef 90       	pop	r14
    428a:	df 90       	pop	r13
    428c:	cf 90       	pop	r12
    428e:	bf 90       	pop	r11
    4290:	af 90       	pop	r10
    4292:	9f 90       	pop	r9
    4294:	08 95       	ret

00004296 <vTaskStartScheduler>:
    4296:	cf 92       	push	r12
    4298:	df 92       	push	r13
    429a:	ef 92       	push	r14
    429c:	ff 92       	push	r15
    429e:	0f 93       	push	r16
    42a0:	1f 93       	push	r17
    42a2:	cf 93       	push	r28
    42a4:	df 93       	push	r29
    42a6:	85 e5       	ldi	r24, 0x55	; 85
    42a8:	90 e0       	ldi	r25, 0x00	; 0
    42aa:	0e 94 8f 02 	call	0x51e	; 0x51e <pvPortMalloc>
    42ae:	8c 01       	movw	r16, r24
    42b0:	89 2b       	or	r24, r25
    42b2:	09 f4       	brne	.+2      	; 0x42b6 <vTaskStartScheduler+0x20>
    42b4:	cb c0       	rjmp	.+406    	; 0x444c <vTaskStartScheduler+0x1b6>
    42b6:	88 e2       	ldi	r24, 0x28	; 40
    42b8:	90 e0       	ldi	r25, 0x00	; 0
    42ba:	0e 94 8f 02 	call	0x51e	; 0x51e <pvPortMalloc>
    42be:	ec 01       	movw	r28, r24
    42c0:	89 2b       	or	r24, r25
    42c2:	69 f0       	breq	.+26     	; 0x42de <vTaskStartScheduler+0x48>
    42c4:	18 8f       	std	Y+24, r17	; 0x18
    42c6:	0f 8b       	std	Y+23, r16	; 0x17
    42c8:	0c 5a       	subi	r16, 0xAC	; 172
    42ca:	1f 4f       	sbci	r17, 0xFF	; 255
    42cc:	89 e4       	ldi	r24, 0x49	; 73
    42ce:	89 8f       	std	Y+25, r24	; 0x19
    42d0:	e9 ef       	ldi	r30, 0xF9	; 249
    42d2:	f7 e0       	ldi	r31, 0x07	; 7
    42d4:	de 01       	movw	r26, r28
    42d6:	5a 96       	adiw	r26, 0x1a	; 26
    42d8:	20 e0       	ldi	r18, 0x00	; 0
    42da:	38 e0       	ldi	r19, 0x08	; 8
    42dc:	04 c0       	rjmp	.+8      	; 0x42e6 <vTaskStartScheduler+0x50>
    42de:	c8 01       	movw	r24, r16
    42e0:	0e 94 c4 02 	call	0x588	; 0x588 <vPortFree>
    42e4:	b3 c0       	rjmp	.+358    	; 0x444c <vTaskStartScheduler+0x1b6>
    42e6:	91 91       	ld	r25, Z+
    42e8:	9d 93       	st	X+, r25
    42ea:	99 23       	and	r25, r25
    42ec:	19 f0       	breq	.+6      	; 0x42f4 <vTaskStartScheduler+0x5e>
    42ee:	e2 17       	cp	r30, r18
    42f0:	f3 07       	cpc	r31, r19
    42f2:	c9 f7       	brne	.-14     	; 0x42e6 <vTaskStartScheduler+0x50>
    42f4:	18 a2       	std	Y+32, r1	; 0x20
    42f6:	1e 8a       	std	Y+22, r1	; 0x16
    42f8:	19 a2       	std	Y+33, r1	; 0x21
    42fa:	1a a2       	std	Y+34, r1	; 0x22
    42fc:	7e 01       	movw	r14, r28
    42fe:	82 e0       	ldi	r24, 0x02	; 2
    4300:	e8 0e       	add	r14, r24
    4302:	f1 1c       	adc	r15, r1
    4304:	c7 01       	movw	r24, r14
    4306:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <vListInitialiseItem>
    430a:	ce 01       	movw	r24, r28
    430c:	0c 96       	adiw	r24, 0x0c	; 12
    430e:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <vListInitialiseItem>
    4312:	d9 87       	std	Y+9, r29	; 0x09
    4314:	c8 87       	std	Y+8, r28	; 0x08
    4316:	86 e0       	ldi	r24, 0x06	; 6
    4318:	90 e0       	ldi	r25, 0x00	; 0
    431a:	9d 87       	std	Y+13, r25	; 0x0d
    431c:	8c 87       	std	Y+12, r24	; 0x0c
    431e:	db 8b       	std	Y+19, r29	; 0x13
    4320:	ca 8b       	std	Y+18, r28	; 0x12
    4322:	1b a2       	std	Y+35, r1	; 0x23
    4324:	1c a2       	std	Y+36, r1	; 0x24
    4326:	1d a2       	std	Y+37, r1	; 0x25
    4328:	1e a2       	std	Y+38, r1	; 0x26
    432a:	1f a2       	std	Y+39, r1	; 0x27
    432c:	40 e0       	ldi	r20, 0x00	; 0
    432e:	50 e0       	ldi	r21, 0x00	; 0
    4330:	61 e2       	ldi	r22, 0x21	; 33
    4332:	71 e0       	ldi	r23, 0x01	; 1
    4334:	c8 01       	movw	r24, r16
    4336:	0e 94 60 14 	call	0x28c0	; 0x28c0 <pxPortInitialiseStack>
    433a:	99 83       	std	Y+1, r25	; 0x01
    433c:	88 83       	st	Y, r24
    433e:	0f b6       	in	r0, 0x3f	; 63
    4340:	f8 94       	cli
    4342:	0f 92       	push	r0
    4344:	80 91 96 1a 	lds	r24, 0x1A96	; 0x801a96 <uxCurrentNumberOfTasks>
    4348:	8f 5f       	subi	r24, 0xFF	; 255
    434a:	80 93 96 1a 	sts	0x1A96, r24	; 0x801a96 <uxCurrentNumberOfTasks>
    434e:	80 91 f5 1a 	lds	r24, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    4352:	90 91 f6 1a 	lds	r25, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    4356:	89 2b       	or	r24, r25
    4358:	a9 f5       	brne	.+106    	; 0x43c4 <vTaskStartScheduler+0x12e>
    435a:	d0 93 f6 1a 	sts	0x1AF6, r29	; 0x801af6 <pxCurrentTCB+0x1>
    435e:	c0 93 f5 1a 	sts	0x1AF5, r28	; 0x801af5 <pxCurrentTCB>
    4362:	80 91 96 1a 	lds	r24, 0x1A96	; 0x801a96 <uxCurrentNumberOfTasks>
    4366:	81 30       	cpi	r24, 0x01	; 1
    4368:	e1 f5       	brne	.+120    	; 0x43e2 <vTaskStartScheduler+0x14c>
    436a:	0f eb       	ldi	r16, 0xBF	; 191
    436c:	1a e1       	ldi	r17, 0x1A	; 26
    436e:	0f 2e       	mov	r0, r31
    4370:	f5 ef       	ldi	r31, 0xF5	; 245
    4372:	cf 2e       	mov	r12, r31
    4374:	fa e1       	ldi	r31, 0x1A	; 26
    4376:	df 2e       	mov	r13, r31
    4378:	f0 2d       	mov	r31, r0
    437a:	c8 01       	movw	r24, r16
    437c:	0e 94 ee 05 	call	0xbdc	; 0xbdc <vListInitialise>
    4380:	07 5f       	subi	r16, 0xF7	; 247
    4382:	1f 4f       	sbci	r17, 0xFF	; 255
    4384:	0c 15       	cp	r16, r12
    4386:	1d 05       	cpc	r17, r13
    4388:	c1 f7       	brne	.-16     	; 0x437a <vTaskStartScheduler+0xe4>
    438a:	86 eb       	ldi	r24, 0xB6	; 182
    438c:	9a e1       	ldi	r25, 0x1A	; 26
    438e:	0e 94 ee 05 	call	0xbdc	; 0xbdc <vListInitialise>
    4392:	8d ea       	ldi	r24, 0xAD	; 173
    4394:	9a e1       	ldi	r25, 0x1A	; 26
    4396:	0e 94 ee 05 	call	0xbdc	; 0xbdc <vListInitialise>
    439a:	80 ea       	ldi	r24, 0xA0	; 160
    439c:	9a e1       	ldi	r25, 0x1A	; 26
    439e:	0e 94 ee 05 	call	0xbdc	; 0xbdc <vListInitialise>
    43a2:	87 e9       	ldi	r24, 0x97	; 151
    43a4:	9a e1       	ldi	r25, 0x1A	; 26
    43a6:	0e 94 ee 05 	call	0xbdc	; 0xbdc <vListInitialise>
    43aa:	86 eb       	ldi	r24, 0xB6	; 182
    43ac:	9a e1       	ldi	r25, 0x1A	; 26
    43ae:	90 93 ac 1a 	sts	0x1AAC, r25	; 0x801aac <pxDelayedTaskList+0x1>
    43b2:	80 93 ab 1a 	sts	0x1AAB, r24	; 0x801aab <pxDelayedTaskList>
    43b6:	8d ea       	ldi	r24, 0xAD	; 173
    43b8:	9a e1       	ldi	r25, 0x1A	; 26
    43ba:	90 93 aa 1a 	sts	0x1AAA, r25	; 0x801aaa <pxOverflowDelayedTaskList+0x1>
    43be:	80 93 a9 1a 	sts	0x1AA9, r24	; 0x801aa9 <pxOverflowDelayedTaskList>
    43c2:	0f c0       	rjmp	.+30     	; 0x43e2 <vTaskStartScheduler+0x14c>
    43c4:	80 91 92 1a 	lds	r24, 0x1A92	; 0x801a92 <xSchedulerRunning>
    43c8:	81 11       	cpse	r24, r1
    43ca:	0b c0       	rjmp	.+22     	; 0x43e2 <vTaskStartScheduler+0x14c>
    43cc:	e0 91 f5 1a 	lds	r30, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    43d0:	f0 91 f6 1a 	lds	r31, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    43d4:	86 89       	ldd	r24, Z+22	; 0x16
    43d6:	81 11       	cpse	r24, r1
    43d8:	04 c0       	rjmp	.+8      	; 0x43e2 <vTaskStartScheduler+0x14c>
    43da:	d0 93 f6 1a 	sts	0x1AF6, r29	; 0x801af6 <pxCurrentTCB+0x1>
    43de:	c0 93 f5 1a 	sts	0x1AF5, r28	; 0x801af5 <pxCurrentTCB>
    43e2:	80 91 8e 1a 	lds	r24, 0x1A8E	; 0x801a8e <uxTaskNumber>
    43e6:	8f 5f       	subi	r24, 0xFF	; 255
    43e8:	80 93 8e 1a 	sts	0x1A8E, r24	; 0x801a8e <uxTaskNumber>
    43ec:	2e 89       	ldd	r18, Y+22	; 0x16
    43ee:	80 91 93 1a 	lds	r24, 0x1A93	; 0x801a93 <uxTopReadyPriority>
    43f2:	82 17       	cp	r24, r18
    43f4:	10 f4       	brcc	.+4      	; 0x43fa <vTaskStartScheduler+0x164>
    43f6:	20 93 93 1a 	sts	0x1A93, r18	; 0x801a93 <uxTopReadyPriority>
    43fa:	30 e0       	ldi	r19, 0x00	; 0
    43fc:	c9 01       	movw	r24, r18
    43fe:	88 0f       	add	r24, r24
    4400:	99 1f       	adc	r25, r25
    4402:	88 0f       	add	r24, r24
    4404:	99 1f       	adc	r25, r25
    4406:	88 0f       	add	r24, r24
    4408:	99 1f       	adc	r25, r25
    440a:	82 0f       	add	r24, r18
    440c:	93 1f       	adc	r25, r19
    440e:	b7 01       	movw	r22, r14
    4410:	81 54       	subi	r24, 0x41	; 65
    4412:	95 4e       	sbci	r25, 0xE5	; 229
    4414:	0e 94 00 06 	call	0xc00	; 0xc00 <vListInsertEnd>
    4418:	0f 90       	pop	r0
    441a:	0f be       	out	0x3f, r0	; 63
    441c:	80 91 92 1a 	lds	r24, 0x1A92	; 0x801a92 <xSchedulerRunning>
    4420:	88 23       	and	r24, r24
    4422:	21 f0       	breq	.+8      	; 0x442c <vTaskStartScheduler+0x196>
    4424:	80 91 f5 1a 	lds	r24, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    4428:	90 91 f6 1a 	lds	r25, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    442c:	f8 94       	cli
    442e:	8f ef       	ldi	r24, 0xFF	; 255
    4430:	9f ef       	ldi	r25, 0xFF	; 255
    4432:	90 93 8d 1a 	sts	0x1A8D, r25	; 0x801a8d <xNextTaskUnblockTime+0x1>
    4436:	80 93 8c 1a 	sts	0x1A8C, r24	; 0x801a8c <xNextTaskUnblockTime>
    443a:	81 e0       	ldi	r24, 0x01	; 1
    443c:	80 93 92 1a 	sts	0x1A92, r24	; 0x801a92 <xSchedulerRunning>
    4440:	10 92 95 1a 	sts	0x1A95, r1	; 0x801a95 <xTickCount+0x1>
    4444:	10 92 94 1a 	sts	0x1A94, r1	; 0x801a94 <xTickCount>
    4448:	0e 94 d2 14 	call	0x29a4	; 0x29a4 <xPortStartScheduler>
    444c:	df 91       	pop	r29
    444e:	cf 91       	pop	r28
    4450:	1f 91       	pop	r17
    4452:	0f 91       	pop	r16
    4454:	ff 90       	pop	r15
    4456:	ef 90       	pop	r14
    4458:	df 90       	pop	r13
    445a:	cf 90       	pop	r12
    445c:	08 95       	ret

0000445e <vTaskSuspendAll>:
    445e:	80 91 8b 1a 	lds	r24, 0x1A8B	; 0x801a8b <uxSchedulerSuspended>
    4462:	8f 5f       	subi	r24, 0xFF	; 255
    4464:	80 93 8b 1a 	sts	0x1A8B, r24	; 0x801a8b <uxSchedulerSuspended>
    4468:	08 95       	ret

0000446a <xTaskResumeAll>:
    446a:	9f 92       	push	r9
    446c:	af 92       	push	r10
    446e:	bf 92       	push	r11
    4470:	cf 92       	push	r12
    4472:	df 92       	push	r13
    4474:	ef 92       	push	r14
    4476:	ff 92       	push	r15
    4478:	0f 93       	push	r16
    447a:	1f 93       	push	r17
    447c:	cf 93       	push	r28
    447e:	df 93       	push	r29
    4480:	0f b6       	in	r0, 0x3f	; 63
    4482:	f8 94       	cli
    4484:	0f 92       	push	r0
    4486:	80 91 8b 1a 	lds	r24, 0x1A8B	; 0x801a8b <uxSchedulerSuspended>
    448a:	81 50       	subi	r24, 0x01	; 1
    448c:	80 93 8b 1a 	sts	0x1A8B, r24	; 0x801a8b <uxSchedulerSuspended>
    4490:	80 91 8b 1a 	lds	r24, 0x1A8B	; 0x801a8b <uxSchedulerSuspended>
    4494:	81 11       	cpse	r24, r1
    4496:	0d c1       	rjmp	.+538    	; 0x46b2 <xTaskResumeAll+0x248>
    4498:	80 91 96 1a 	lds	r24, 0x1A96	; 0x801a96 <uxCurrentNumberOfTasks>
    449c:	81 11       	cpse	r24, r1
    449e:	33 c0       	rjmp	.+102    	; 0x4506 <xTaskResumeAll+0x9c>
    44a0:	0b c1       	rjmp	.+534    	; 0x46b8 <xTaskResumeAll+0x24e>
    44a2:	d7 01       	movw	r26, r14
    44a4:	15 96       	adiw	r26, 0x05	; 5
    44a6:	ed 91       	ld	r30, X+
    44a8:	fc 91       	ld	r31, X
    44aa:	16 97       	sbiw	r26, 0x06	; 6
    44ac:	c6 81       	ldd	r28, Z+6	; 0x06
    44ae:	d7 81       	ldd	r29, Z+7	; 0x07
    44b0:	ce 01       	movw	r24, r28
    44b2:	0c 96       	adiw	r24, 0x0c	; 12
    44b4:	0e 94 52 06 	call	0xca4	; 0xca4 <uxListRemove>
    44b8:	8e 01       	movw	r16, r28
    44ba:	0e 5f       	subi	r16, 0xFE	; 254
    44bc:	1f 4f       	sbci	r17, 0xFF	; 255
    44be:	c8 01       	movw	r24, r16
    44c0:	0e 94 52 06 	call	0xca4	; 0xca4 <uxListRemove>
    44c4:	2e 89       	ldd	r18, Y+22	; 0x16
    44c6:	80 91 93 1a 	lds	r24, 0x1A93	; 0x801a93 <uxTopReadyPriority>
    44ca:	82 17       	cp	r24, r18
    44cc:	10 f4       	brcc	.+4      	; 0x44d2 <xTaskResumeAll+0x68>
    44ce:	20 93 93 1a 	sts	0x1A93, r18	; 0x801a93 <uxTopReadyPriority>
    44d2:	30 e0       	ldi	r19, 0x00	; 0
    44d4:	c9 01       	movw	r24, r18
    44d6:	88 0f       	add	r24, r24
    44d8:	99 1f       	adc	r25, r25
    44da:	88 0f       	add	r24, r24
    44dc:	99 1f       	adc	r25, r25
    44de:	88 0f       	add	r24, r24
    44e0:	99 1f       	adc	r25, r25
    44e2:	82 0f       	add	r24, r18
    44e4:	93 1f       	adc	r25, r19
    44e6:	b8 01       	movw	r22, r16
    44e8:	81 54       	subi	r24, 0x41	; 65
    44ea:	95 4e       	sbci	r25, 0xE5	; 229
    44ec:	0e 94 00 06 	call	0xc00	; 0xc00 <vListInsertEnd>
    44f0:	e0 91 f5 1a 	lds	r30, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    44f4:	f0 91 f6 1a 	lds	r31, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    44f8:	9e 89       	ldd	r25, Y+22	; 0x16
    44fa:	86 89       	ldd	r24, Z+22	; 0x16
    44fc:	98 17       	cp	r25, r24
    44fe:	58 f0       	brcs	.+22     	; 0x4516 <xTaskResumeAll+0xac>
    4500:	d0 92 90 1a 	sts	0x1A90, r13	; 0x801a90 <xYieldPending>
    4504:	08 c0       	rjmp	.+16     	; 0x4516 <xTaskResumeAll+0xac>
    4506:	0f 2e       	mov	r0, r31
    4508:	f0 ea       	ldi	r31, 0xA0	; 160
    450a:	ef 2e       	mov	r14, r31
    450c:	fa e1       	ldi	r31, 0x1A	; 26
    450e:	ff 2e       	mov	r15, r31
    4510:	f0 2d       	mov	r31, r0
    4512:	dd 24       	eor	r13, r13
    4514:	d3 94       	inc	r13
    4516:	f7 01       	movw	r30, r14
    4518:	80 81       	ld	r24, Z
    451a:	81 11       	cpse	r24, r1
    451c:	c2 cf       	rjmp	.-124    	; 0x44a2 <xTaskResumeAll+0x38>
    451e:	80 91 91 1a 	lds	r24, 0x1A91	; 0x801a91 <uxPendedTicks>
    4522:	88 23       	and	r24, r24
    4524:	09 f4       	brne	.+2      	; 0x4528 <xTaskResumeAll+0xbe>
    4526:	bd c0       	rjmp	.+378    	; 0x46a2 <xTaskResumeAll+0x238>
    4528:	80 91 91 1a 	lds	r24, 0x1A91	; 0x801a91 <uxPendedTicks>
    452c:	88 23       	and	r24, r24
    452e:	09 f4       	brne	.+2      	; 0x4532 <xTaskResumeAll+0xc8>
    4530:	b8 c0       	rjmp	.+368    	; 0x46a2 <xTaskResumeAll+0x238>
    4532:	91 2c       	mov	r9, r1
    4534:	aa 24       	eor	r10, r10
    4536:	a3 94       	inc	r10
    4538:	cc 24       	eor	r12, r12
    453a:	ca 94       	dec	r12
    453c:	dc 2c       	mov	r13, r12
    453e:	80 91 8b 1a 	lds	r24, 0x1A8B	; 0x801a8b <uxSchedulerSuspended>
    4542:	81 11       	cpse	r24, r1
    4544:	98 c0       	rjmp	.+304    	; 0x4676 <xTaskResumeAll+0x20c>
    4546:	80 91 94 1a 	lds	r24, 0x1A94	; 0x801a94 <xTickCount>
    454a:	90 91 95 1a 	lds	r25, 0x1A95	; 0x801a95 <xTickCount+0x1>
    454e:	01 96       	adiw	r24, 0x01	; 1
    4550:	90 93 95 1a 	sts	0x1A95, r25	; 0x801a95 <xTickCount+0x1>
    4554:	80 93 94 1a 	sts	0x1A94, r24	; 0x801a94 <xTickCount>
    4558:	e0 90 94 1a 	lds	r14, 0x1A94	; 0x801a94 <xTickCount>
    455c:	f0 90 95 1a 	lds	r15, 0x1A95	; 0x801a95 <xTickCount+0x1>
    4560:	e1 14       	cp	r14, r1
    4562:	f1 04       	cpc	r15, r1
    4564:	89 f5       	brne	.+98     	; 0x45c8 <xTaskResumeAll+0x15e>
    4566:	80 91 ab 1a 	lds	r24, 0x1AAB	; 0x801aab <pxDelayedTaskList>
    456a:	90 91 ac 1a 	lds	r25, 0x1AAC	; 0x801aac <pxDelayedTaskList+0x1>
    456e:	20 91 a9 1a 	lds	r18, 0x1AA9	; 0x801aa9 <pxOverflowDelayedTaskList>
    4572:	30 91 aa 1a 	lds	r19, 0x1AAA	; 0x801aaa <pxOverflowDelayedTaskList+0x1>
    4576:	30 93 ac 1a 	sts	0x1AAC, r19	; 0x801aac <pxDelayedTaskList+0x1>
    457a:	20 93 ab 1a 	sts	0x1AAB, r18	; 0x801aab <pxDelayedTaskList>
    457e:	90 93 aa 1a 	sts	0x1AAA, r25	; 0x801aaa <pxOverflowDelayedTaskList+0x1>
    4582:	80 93 a9 1a 	sts	0x1AA9, r24	; 0x801aa9 <pxOverflowDelayedTaskList>
    4586:	80 91 8f 1a 	lds	r24, 0x1A8F	; 0x801a8f <xNumOfOverflows>
    458a:	8f 5f       	subi	r24, 0xFF	; 255
    458c:	80 93 8f 1a 	sts	0x1A8F, r24	; 0x801a8f <xNumOfOverflows>
    4590:	e0 91 ab 1a 	lds	r30, 0x1AAB	; 0x801aab <pxDelayedTaskList>
    4594:	f0 91 ac 1a 	lds	r31, 0x1AAC	; 0x801aac <pxDelayedTaskList+0x1>
    4598:	80 81       	ld	r24, Z
    459a:	81 11       	cpse	r24, r1
    459c:	05 c0       	rjmp	.+10     	; 0x45a8 <xTaskResumeAll+0x13e>
    459e:	d0 92 8d 1a 	sts	0x1A8D, r13	; 0x801a8d <xNextTaskUnblockTime+0x1>
    45a2:	c0 92 8c 1a 	sts	0x1A8C, r12	; 0x801a8c <xNextTaskUnblockTime>
    45a6:	10 c0       	rjmp	.+32     	; 0x45c8 <xTaskResumeAll+0x15e>
    45a8:	e0 91 ab 1a 	lds	r30, 0x1AAB	; 0x801aab <pxDelayedTaskList>
    45ac:	f0 91 ac 1a 	lds	r31, 0x1AAC	; 0x801aac <pxDelayedTaskList+0x1>
    45b0:	05 80       	ldd	r0, Z+5	; 0x05
    45b2:	f6 81       	ldd	r31, Z+6	; 0x06
    45b4:	e0 2d       	mov	r30, r0
    45b6:	06 80       	ldd	r0, Z+6	; 0x06
    45b8:	f7 81       	ldd	r31, Z+7	; 0x07
    45ba:	e0 2d       	mov	r30, r0
    45bc:	82 81       	ldd	r24, Z+2	; 0x02
    45be:	93 81       	ldd	r25, Z+3	; 0x03
    45c0:	90 93 8d 1a 	sts	0x1A8D, r25	; 0x801a8d <xNextTaskUnblockTime+0x1>
    45c4:	80 93 8c 1a 	sts	0x1A8C, r24	; 0x801a8c <xNextTaskUnblockTime>
    45c8:	80 91 8c 1a 	lds	r24, 0x1A8C	; 0x801a8c <xNextTaskUnblockTime>
    45cc:	90 91 8d 1a 	lds	r25, 0x1A8D	; 0x801a8d <xNextTaskUnblockTime+0x1>
    45d0:	e8 16       	cp	r14, r24
    45d2:	f9 06       	cpc	r15, r25
    45d4:	08 f4       	brcc	.+2      	; 0x45d8 <xTaskResumeAll+0x16e>
    45d6:	73 c0       	rjmp	.+230    	; 0x46be <xTaskResumeAll+0x254>
    45d8:	b9 2c       	mov	r11, r9
    45da:	e0 91 ab 1a 	lds	r30, 0x1AAB	; 0x801aab <pxDelayedTaskList>
    45de:	f0 91 ac 1a 	lds	r31, 0x1AAC	; 0x801aac <pxDelayedTaskList+0x1>
    45e2:	80 81       	ld	r24, Z
    45e4:	81 11       	cpse	r24, r1
    45e6:	05 c0       	rjmp	.+10     	; 0x45f2 <xTaskResumeAll+0x188>
    45e8:	d0 92 8d 1a 	sts	0x1A8D, r13	; 0x801a8d <xNextTaskUnblockTime+0x1>
    45ec:	c0 92 8c 1a 	sts	0x1A8C, r12	; 0x801a8c <xNextTaskUnblockTime>
    45f0:	48 c0       	rjmp	.+144    	; 0x4682 <xTaskResumeAll+0x218>
    45f2:	e0 91 ab 1a 	lds	r30, 0x1AAB	; 0x801aab <pxDelayedTaskList>
    45f6:	f0 91 ac 1a 	lds	r31, 0x1AAC	; 0x801aac <pxDelayedTaskList+0x1>
    45fa:	05 80       	ldd	r0, Z+5	; 0x05
    45fc:	f6 81       	ldd	r31, Z+6	; 0x06
    45fe:	e0 2d       	mov	r30, r0
    4600:	c6 81       	ldd	r28, Z+6	; 0x06
    4602:	d7 81       	ldd	r29, Z+7	; 0x07
    4604:	8a 81       	ldd	r24, Y+2	; 0x02
    4606:	9b 81       	ldd	r25, Y+3	; 0x03
    4608:	e8 16       	cp	r14, r24
    460a:	f9 06       	cpc	r15, r25
    460c:	28 f4       	brcc	.+10     	; 0x4618 <xTaskResumeAll+0x1ae>
    460e:	90 93 8d 1a 	sts	0x1A8D, r25	; 0x801a8d <xNextTaskUnblockTime+0x1>
    4612:	80 93 8c 1a 	sts	0x1A8C, r24	; 0x801a8c <xNextTaskUnblockTime>
    4616:	35 c0       	rjmp	.+106    	; 0x4682 <xTaskResumeAll+0x218>
    4618:	8e 01       	movw	r16, r28
    461a:	0e 5f       	subi	r16, 0xFE	; 254
    461c:	1f 4f       	sbci	r17, 0xFF	; 255
    461e:	c8 01       	movw	r24, r16
    4620:	0e 94 52 06 	call	0xca4	; 0xca4 <uxListRemove>
    4624:	8c 89       	ldd	r24, Y+20	; 0x14
    4626:	9d 89       	ldd	r25, Y+21	; 0x15
    4628:	89 2b       	or	r24, r25
    462a:	21 f0       	breq	.+8      	; 0x4634 <xTaskResumeAll+0x1ca>
    462c:	ce 01       	movw	r24, r28
    462e:	0c 96       	adiw	r24, 0x0c	; 12
    4630:	0e 94 52 06 	call	0xca4	; 0xca4 <uxListRemove>
    4634:	2e 89       	ldd	r18, Y+22	; 0x16
    4636:	80 91 93 1a 	lds	r24, 0x1A93	; 0x801a93 <uxTopReadyPriority>
    463a:	82 17       	cp	r24, r18
    463c:	10 f4       	brcc	.+4      	; 0x4642 <xTaskResumeAll+0x1d8>
    463e:	20 93 93 1a 	sts	0x1A93, r18	; 0x801a93 <uxTopReadyPriority>
    4642:	30 e0       	ldi	r19, 0x00	; 0
    4644:	c9 01       	movw	r24, r18
    4646:	88 0f       	add	r24, r24
    4648:	99 1f       	adc	r25, r25
    464a:	88 0f       	add	r24, r24
    464c:	99 1f       	adc	r25, r25
    464e:	88 0f       	add	r24, r24
    4650:	99 1f       	adc	r25, r25
    4652:	82 0f       	add	r24, r18
    4654:	93 1f       	adc	r25, r19
    4656:	b8 01       	movw	r22, r16
    4658:	81 54       	subi	r24, 0x41	; 65
    465a:	95 4e       	sbci	r25, 0xE5	; 229
    465c:	0e 94 00 06 	call	0xc00	; 0xc00 <vListInsertEnd>
    4660:	e0 91 f5 1a 	lds	r30, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    4664:	f0 91 f6 1a 	lds	r31, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    4668:	9e 89       	ldd	r25, Y+22	; 0x16
    466a:	86 89       	ldd	r24, Z+22	; 0x16
    466c:	98 17       	cp	r25, r24
    466e:	08 f4       	brcc	.+2      	; 0x4672 <xTaskResumeAll+0x208>
    4670:	b4 cf       	rjmp	.-152    	; 0x45da <xTaskResumeAll+0x170>
    4672:	ba 2c       	mov	r11, r10
    4674:	b2 cf       	rjmp	.-156    	; 0x45da <xTaskResumeAll+0x170>
    4676:	80 91 91 1a 	lds	r24, 0x1A91	; 0x801a91 <uxPendedTicks>
    467a:	8f 5f       	subi	r24, 0xFF	; 255
    467c:	80 93 91 1a 	sts	0x1A91, r24	; 0x801a91 <uxPendedTicks>
    4680:	1e c0       	rjmp	.+60     	; 0x46be <xTaskResumeAll+0x254>
    4682:	80 91 90 1a 	lds	r24, 0x1A90	; 0x801a90 <xYieldPending>
    4686:	81 11       	cpse	r24, r1
    4688:	01 c0       	rjmp	.+2      	; 0x468c <xTaskResumeAll+0x222>
    468a:	b1 10       	cpse	r11, r1
    468c:	a0 92 90 1a 	sts	0x1A90, r10	; 0x801a90 <xYieldPending>
    4690:	80 91 91 1a 	lds	r24, 0x1A91	; 0x801a91 <uxPendedTicks>
    4694:	81 50       	subi	r24, 0x01	; 1
    4696:	80 93 91 1a 	sts	0x1A91, r24	; 0x801a91 <uxPendedTicks>
    469a:	80 91 91 1a 	lds	r24, 0x1A91	; 0x801a91 <uxPendedTicks>
    469e:	81 11       	cpse	r24, r1
    46a0:	4e cf       	rjmp	.-356    	; 0x453e <xTaskResumeAll+0xd4>
    46a2:	80 91 90 1a 	lds	r24, 0x1A90	; 0x801a90 <xYieldPending>
    46a6:	81 30       	cpi	r24, 0x01	; 1
    46a8:	31 f4       	brne	.+12     	; 0x46b6 <xTaskResumeAll+0x24c>
    46aa:	0e 94 1a 15 	call	0x2a34	; 0x2a34 <vPortYield>
    46ae:	81 e0       	ldi	r24, 0x01	; 1
    46b0:	03 c0       	rjmp	.+6      	; 0x46b8 <xTaskResumeAll+0x24e>
    46b2:	80 e0       	ldi	r24, 0x00	; 0
    46b4:	01 c0       	rjmp	.+2      	; 0x46b8 <xTaskResumeAll+0x24e>
    46b6:	80 e0       	ldi	r24, 0x00	; 0
    46b8:	0f 90       	pop	r0
    46ba:	0f be       	out	0x3f, r0	; 63
    46bc:	05 c0       	rjmp	.+10     	; 0x46c8 <xTaskResumeAll+0x25e>
    46be:	80 91 90 1a 	lds	r24, 0x1A90	; 0x801a90 <xYieldPending>
    46c2:	88 23       	and	r24, r24
    46c4:	29 f3       	breq	.-54     	; 0x4690 <xTaskResumeAll+0x226>
    46c6:	e2 cf       	rjmp	.-60     	; 0x468c <xTaskResumeAll+0x222>
    46c8:	df 91       	pop	r29
    46ca:	cf 91       	pop	r28
    46cc:	1f 91       	pop	r17
    46ce:	0f 91       	pop	r16
    46d0:	ff 90       	pop	r15
    46d2:	ef 90       	pop	r14
    46d4:	df 90       	pop	r13
    46d6:	cf 90       	pop	r12
    46d8:	bf 90       	pop	r11
    46da:	af 90       	pop	r10
    46dc:	9f 90       	pop	r9
    46de:	08 95       	ret

000046e0 <xTaskGetTickCount>:
    46e0:	0f b6       	in	r0, 0x3f	; 63
    46e2:	f8 94       	cli
    46e4:	0f 92       	push	r0
    46e6:	80 91 94 1a 	lds	r24, 0x1A94	; 0x801a94 <xTickCount>
    46ea:	90 91 95 1a 	lds	r25, 0x1A95	; 0x801a95 <xTickCount+0x1>
    46ee:	0f 90       	pop	r0
    46f0:	0f be       	out	0x3f, r0	; 63
    46f2:	08 95       	ret

000046f4 <xTaskIncrementTick>:
    46f4:	cf 92       	push	r12
    46f6:	df 92       	push	r13
    46f8:	ef 92       	push	r14
    46fa:	ff 92       	push	r15
    46fc:	0f 93       	push	r16
    46fe:	1f 93       	push	r17
    4700:	cf 93       	push	r28
    4702:	df 93       	push	r29
    4704:	80 91 8b 1a 	lds	r24, 0x1A8B	; 0x801a8b <uxSchedulerSuspended>
    4708:	81 11       	cpse	r24, r1
    470a:	9f c0       	rjmp	.+318    	; 0x484a <xTaskIncrementTick+0x156>
    470c:	80 91 94 1a 	lds	r24, 0x1A94	; 0x801a94 <xTickCount>
    4710:	90 91 95 1a 	lds	r25, 0x1A95	; 0x801a95 <xTickCount+0x1>
    4714:	01 96       	adiw	r24, 0x01	; 1
    4716:	90 93 95 1a 	sts	0x1A95, r25	; 0x801a95 <xTickCount+0x1>
    471a:	80 93 94 1a 	sts	0x1A94, r24	; 0x801a94 <xTickCount>
    471e:	e0 90 94 1a 	lds	r14, 0x1A94	; 0x801a94 <xTickCount>
    4722:	f0 90 95 1a 	lds	r15, 0x1A95	; 0x801a95 <xTickCount+0x1>
    4726:	e1 14       	cp	r14, r1
    4728:	f1 04       	cpc	r15, r1
    472a:	99 f5       	brne	.+102    	; 0x4792 <xTaskIncrementTick+0x9e>
    472c:	80 91 ab 1a 	lds	r24, 0x1AAB	; 0x801aab <pxDelayedTaskList>
    4730:	90 91 ac 1a 	lds	r25, 0x1AAC	; 0x801aac <pxDelayedTaskList+0x1>
    4734:	20 91 a9 1a 	lds	r18, 0x1AA9	; 0x801aa9 <pxOverflowDelayedTaskList>
    4738:	30 91 aa 1a 	lds	r19, 0x1AAA	; 0x801aaa <pxOverflowDelayedTaskList+0x1>
    473c:	30 93 ac 1a 	sts	0x1AAC, r19	; 0x801aac <pxDelayedTaskList+0x1>
    4740:	20 93 ab 1a 	sts	0x1AAB, r18	; 0x801aab <pxDelayedTaskList>
    4744:	90 93 aa 1a 	sts	0x1AAA, r25	; 0x801aaa <pxOverflowDelayedTaskList+0x1>
    4748:	80 93 a9 1a 	sts	0x1AA9, r24	; 0x801aa9 <pxOverflowDelayedTaskList>
    474c:	80 91 8f 1a 	lds	r24, 0x1A8F	; 0x801a8f <xNumOfOverflows>
    4750:	8f 5f       	subi	r24, 0xFF	; 255
    4752:	80 93 8f 1a 	sts	0x1A8F, r24	; 0x801a8f <xNumOfOverflows>
    4756:	e0 91 ab 1a 	lds	r30, 0x1AAB	; 0x801aab <pxDelayedTaskList>
    475a:	f0 91 ac 1a 	lds	r31, 0x1AAC	; 0x801aac <pxDelayedTaskList+0x1>
    475e:	80 81       	ld	r24, Z
    4760:	81 11       	cpse	r24, r1
    4762:	07 c0       	rjmp	.+14     	; 0x4772 <xTaskIncrementTick+0x7e>
    4764:	8f ef       	ldi	r24, 0xFF	; 255
    4766:	9f ef       	ldi	r25, 0xFF	; 255
    4768:	90 93 8d 1a 	sts	0x1A8D, r25	; 0x801a8d <xNextTaskUnblockTime+0x1>
    476c:	80 93 8c 1a 	sts	0x1A8C, r24	; 0x801a8c <xNextTaskUnblockTime>
    4770:	10 c0       	rjmp	.+32     	; 0x4792 <xTaskIncrementTick+0x9e>
    4772:	e0 91 ab 1a 	lds	r30, 0x1AAB	; 0x801aab <pxDelayedTaskList>
    4776:	f0 91 ac 1a 	lds	r31, 0x1AAC	; 0x801aac <pxDelayedTaskList+0x1>
    477a:	05 80       	ldd	r0, Z+5	; 0x05
    477c:	f6 81       	ldd	r31, Z+6	; 0x06
    477e:	e0 2d       	mov	r30, r0
    4780:	06 80       	ldd	r0, Z+6	; 0x06
    4782:	f7 81       	ldd	r31, Z+7	; 0x07
    4784:	e0 2d       	mov	r30, r0
    4786:	82 81       	ldd	r24, Z+2	; 0x02
    4788:	93 81       	ldd	r25, Z+3	; 0x03
    478a:	90 93 8d 1a 	sts	0x1A8D, r25	; 0x801a8d <xNextTaskUnblockTime+0x1>
    478e:	80 93 8c 1a 	sts	0x1A8C, r24	; 0x801a8c <xNextTaskUnblockTime>
    4792:	80 91 8c 1a 	lds	r24, 0x1A8C	; 0x801a8c <xNextTaskUnblockTime>
    4796:	90 91 8d 1a 	lds	r25, 0x1A8D	; 0x801a8d <xNextTaskUnblockTime+0x1>
    479a:	e8 16       	cp	r14, r24
    479c:	f9 06       	cpc	r15, r25
    479e:	10 f4       	brcc	.+4      	; 0x47a4 <xTaskIncrementTick+0xb0>
    47a0:	d1 2c       	mov	r13, r1
    47a2:	59 c0       	rjmp	.+178    	; 0x4856 <xTaskIncrementTick+0x162>
    47a4:	d1 2c       	mov	r13, r1
    47a6:	cc 24       	eor	r12, r12
    47a8:	c3 94       	inc	r12
    47aa:	e0 91 ab 1a 	lds	r30, 0x1AAB	; 0x801aab <pxDelayedTaskList>
    47ae:	f0 91 ac 1a 	lds	r31, 0x1AAC	; 0x801aac <pxDelayedTaskList+0x1>
    47b2:	90 81       	ld	r25, Z
    47b4:	91 11       	cpse	r25, r1
    47b6:	07 c0       	rjmp	.+14     	; 0x47c6 <xTaskIncrementTick+0xd2>
    47b8:	8f ef       	ldi	r24, 0xFF	; 255
    47ba:	9f ef       	ldi	r25, 0xFF	; 255
    47bc:	90 93 8d 1a 	sts	0x1A8D, r25	; 0x801a8d <xNextTaskUnblockTime+0x1>
    47c0:	80 93 8c 1a 	sts	0x1A8C, r24	; 0x801a8c <xNextTaskUnblockTime>
    47c4:	48 c0       	rjmp	.+144    	; 0x4856 <xTaskIncrementTick+0x162>
    47c6:	e0 91 ab 1a 	lds	r30, 0x1AAB	; 0x801aab <pxDelayedTaskList>
    47ca:	f0 91 ac 1a 	lds	r31, 0x1AAC	; 0x801aac <pxDelayedTaskList+0x1>
    47ce:	05 80       	ldd	r0, Z+5	; 0x05
    47d0:	f6 81       	ldd	r31, Z+6	; 0x06
    47d2:	e0 2d       	mov	r30, r0
    47d4:	c6 81       	ldd	r28, Z+6	; 0x06
    47d6:	d7 81       	ldd	r29, Z+7	; 0x07
    47d8:	2a 81       	ldd	r18, Y+2	; 0x02
    47da:	3b 81       	ldd	r19, Y+3	; 0x03
    47dc:	e2 16       	cp	r14, r18
    47de:	f3 06       	cpc	r15, r19
    47e0:	28 f4       	brcc	.+10     	; 0x47ec <xTaskIncrementTick+0xf8>
    47e2:	30 93 8d 1a 	sts	0x1A8D, r19	; 0x801a8d <xNextTaskUnblockTime+0x1>
    47e6:	20 93 8c 1a 	sts	0x1A8C, r18	; 0x801a8c <xNextTaskUnblockTime>
    47ea:	35 c0       	rjmp	.+106    	; 0x4856 <xTaskIncrementTick+0x162>
    47ec:	8e 01       	movw	r16, r28
    47ee:	0e 5f       	subi	r16, 0xFE	; 254
    47f0:	1f 4f       	sbci	r17, 0xFF	; 255
    47f2:	c8 01       	movw	r24, r16
    47f4:	0e 94 52 06 	call	0xca4	; 0xca4 <uxListRemove>
    47f8:	8c 89       	ldd	r24, Y+20	; 0x14
    47fa:	9d 89       	ldd	r25, Y+21	; 0x15
    47fc:	89 2b       	or	r24, r25
    47fe:	21 f0       	breq	.+8      	; 0x4808 <xTaskIncrementTick+0x114>
    4800:	ce 01       	movw	r24, r28
    4802:	0c 96       	adiw	r24, 0x0c	; 12
    4804:	0e 94 52 06 	call	0xca4	; 0xca4 <uxListRemove>
    4808:	2e 89       	ldd	r18, Y+22	; 0x16
    480a:	80 91 93 1a 	lds	r24, 0x1A93	; 0x801a93 <uxTopReadyPriority>
    480e:	82 17       	cp	r24, r18
    4810:	10 f4       	brcc	.+4      	; 0x4816 <xTaskIncrementTick+0x122>
    4812:	20 93 93 1a 	sts	0x1A93, r18	; 0x801a93 <uxTopReadyPriority>
    4816:	30 e0       	ldi	r19, 0x00	; 0
    4818:	c9 01       	movw	r24, r18
    481a:	88 0f       	add	r24, r24
    481c:	99 1f       	adc	r25, r25
    481e:	88 0f       	add	r24, r24
    4820:	99 1f       	adc	r25, r25
    4822:	88 0f       	add	r24, r24
    4824:	99 1f       	adc	r25, r25
    4826:	82 0f       	add	r24, r18
    4828:	93 1f       	adc	r25, r19
    482a:	b8 01       	movw	r22, r16
    482c:	81 54       	subi	r24, 0x41	; 65
    482e:	95 4e       	sbci	r25, 0xE5	; 229
    4830:	0e 94 00 06 	call	0xc00	; 0xc00 <vListInsertEnd>
    4834:	e0 91 f5 1a 	lds	r30, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    4838:	f0 91 f6 1a 	lds	r31, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    483c:	9e 89       	ldd	r25, Y+22	; 0x16
    483e:	86 89       	ldd	r24, Z+22	; 0x16
    4840:	98 17       	cp	r25, r24
    4842:	08 f4       	brcc	.+2      	; 0x4846 <xTaskIncrementTick+0x152>
    4844:	b2 cf       	rjmp	.-156    	; 0x47aa <xTaskIncrementTick+0xb6>
    4846:	dc 2c       	mov	r13, r12
    4848:	b0 cf       	rjmp	.-160    	; 0x47aa <xTaskIncrementTick+0xb6>
    484a:	80 91 91 1a 	lds	r24, 0x1A91	; 0x801a91 <uxPendedTicks>
    484e:	8f 5f       	subi	r24, 0xFF	; 255
    4850:	80 93 91 1a 	sts	0x1A91, r24	; 0x801a91 <uxPendedTicks>
    4854:	d1 2c       	mov	r13, r1
    4856:	80 91 90 1a 	lds	r24, 0x1A90	; 0x801a90 <xYieldPending>
    485a:	88 23       	and	r24, r24
    485c:	11 f0       	breq	.+4      	; 0x4862 <xTaskIncrementTick+0x16e>
    485e:	dd 24       	eor	r13, r13
    4860:	d3 94       	inc	r13
    4862:	8d 2d       	mov	r24, r13
    4864:	df 91       	pop	r29
    4866:	cf 91       	pop	r28
    4868:	1f 91       	pop	r17
    486a:	0f 91       	pop	r16
    486c:	ff 90       	pop	r15
    486e:	ef 90       	pop	r14
    4870:	df 90       	pop	r13
    4872:	cf 90       	pop	r12
    4874:	08 95       	ret

00004876 <vTaskSwitchContext>:
    4876:	80 91 8b 1a 	lds	r24, 0x1A8B	; 0x801a8b <uxSchedulerSuspended>
    487a:	88 23       	and	r24, r24
    487c:	21 f0       	breq	.+8      	; 0x4886 <vTaskSwitchContext+0x10>
    487e:	81 e0       	ldi	r24, 0x01	; 1
    4880:	80 93 90 1a 	sts	0x1A90, r24	; 0x801a90 <xYieldPending>
    4884:	08 95       	ret
    4886:	10 92 90 1a 	sts	0x1A90, r1	; 0x801a90 <xYieldPending>
    488a:	a0 91 f5 1a 	lds	r26, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    488e:	b0 91 f6 1a 	lds	r27, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    4892:	e0 91 f5 1a 	lds	r30, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    4896:	f0 91 f6 1a 	lds	r31, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    489a:	2d 91       	ld	r18, X+
    489c:	3c 91       	ld	r19, X
    489e:	87 89       	ldd	r24, Z+23	; 0x17
    48a0:	90 8d       	ldd	r25, Z+24	; 0x18
    48a2:	82 17       	cp	r24, r18
    48a4:	93 07       	cpc	r25, r19
    48a6:	60 f0       	brcs	.+24     	; 0x48c0 <vTaskSwitchContext+0x4a>
    48a8:	60 91 f5 1a 	lds	r22, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    48ac:	70 91 f6 1a 	lds	r23, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    48b0:	80 91 f5 1a 	lds	r24, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    48b4:	90 91 f6 1a 	lds	r25, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    48b8:	67 5e       	subi	r22, 0xE7	; 231
    48ba:	7f 4f       	sbci	r23, 0xFF	; 255
    48bc:	0e 94 8c 11 	call	0x2318	; 0x2318 <vApplicationStackOverflowHook>
    48c0:	80 91 93 1a 	lds	r24, 0x1A93	; 0x801a93 <uxTopReadyPriority>
    48c4:	90 e0       	ldi	r25, 0x00	; 0
    48c6:	fc 01       	movw	r30, r24
    48c8:	ee 0f       	add	r30, r30
    48ca:	ff 1f       	adc	r31, r31
    48cc:	ee 0f       	add	r30, r30
    48ce:	ff 1f       	adc	r31, r31
    48d0:	ee 0f       	add	r30, r30
    48d2:	ff 1f       	adc	r31, r31
    48d4:	8e 0f       	add	r24, r30
    48d6:	9f 1f       	adc	r25, r31
    48d8:	fc 01       	movw	r30, r24
    48da:	e1 54       	subi	r30, 0x41	; 65
    48dc:	f5 4e       	sbci	r31, 0xE5	; 229
    48de:	80 81       	ld	r24, Z
    48e0:	81 11       	cpse	r24, r1
    48e2:	17 c0       	rjmp	.+46     	; 0x4912 <vTaskSwitchContext+0x9c>
    48e4:	80 91 93 1a 	lds	r24, 0x1A93	; 0x801a93 <uxTopReadyPriority>
    48e8:	81 50       	subi	r24, 0x01	; 1
    48ea:	80 93 93 1a 	sts	0x1A93, r24	; 0x801a93 <uxTopReadyPriority>
    48ee:	80 91 93 1a 	lds	r24, 0x1A93	; 0x801a93 <uxTopReadyPriority>
    48f2:	90 e0       	ldi	r25, 0x00	; 0
    48f4:	fc 01       	movw	r30, r24
    48f6:	ee 0f       	add	r30, r30
    48f8:	ff 1f       	adc	r31, r31
    48fa:	ee 0f       	add	r30, r30
    48fc:	ff 1f       	adc	r31, r31
    48fe:	ee 0f       	add	r30, r30
    4900:	ff 1f       	adc	r31, r31
    4902:	8e 0f       	add	r24, r30
    4904:	9f 1f       	adc	r25, r31
    4906:	fc 01       	movw	r30, r24
    4908:	e1 54       	subi	r30, 0x41	; 65
    490a:	f5 4e       	sbci	r31, 0xE5	; 229
    490c:	80 81       	ld	r24, Z
    490e:	88 23       	and	r24, r24
    4910:	49 f3       	breq	.-46     	; 0x48e4 <vTaskSwitchContext+0x6e>
    4912:	80 91 93 1a 	lds	r24, 0x1A93	; 0x801a93 <uxTopReadyPriority>
    4916:	90 e0       	ldi	r25, 0x00	; 0
    4918:	9c 01       	movw	r18, r24
    491a:	22 0f       	add	r18, r18
    491c:	33 1f       	adc	r19, r19
    491e:	22 0f       	add	r18, r18
    4920:	33 1f       	adc	r19, r19
    4922:	22 0f       	add	r18, r18
    4924:	33 1f       	adc	r19, r19
    4926:	28 0f       	add	r18, r24
    4928:	39 1f       	adc	r19, r25
    492a:	d9 01       	movw	r26, r18
    492c:	a1 54       	subi	r26, 0x41	; 65
    492e:	b5 4e       	sbci	r27, 0xE5	; 229
    4930:	11 96       	adiw	r26, 0x01	; 1
    4932:	ed 91       	ld	r30, X+
    4934:	fc 91       	ld	r31, X
    4936:	12 97       	sbiw	r26, 0x02	; 2
    4938:	02 80       	ldd	r0, Z+2	; 0x02
    493a:	f3 81       	ldd	r31, Z+3	; 0x03
    493c:	e0 2d       	mov	r30, r0
    493e:	12 96       	adiw	r26, 0x02	; 2
    4940:	fc 93       	st	X, r31
    4942:	ee 93       	st	-X, r30
    4944:	11 97       	sbiw	r26, 0x01	; 1
    4946:	2e 53       	subi	r18, 0x3E	; 62
    4948:	35 4e       	sbci	r19, 0xE5	; 229
    494a:	e2 17       	cp	r30, r18
    494c:	f3 07       	cpc	r31, r19
    494e:	29 f4       	brne	.+10     	; 0x495a <vTaskSwitchContext+0xe4>
    4950:	22 81       	ldd	r18, Z+2	; 0x02
    4952:	33 81       	ldd	r19, Z+3	; 0x03
    4954:	fd 01       	movw	r30, r26
    4956:	32 83       	std	Z+2, r19	; 0x02
    4958:	21 83       	std	Z+1, r18	; 0x01
    495a:	fc 01       	movw	r30, r24
    495c:	ee 0f       	add	r30, r30
    495e:	ff 1f       	adc	r31, r31
    4960:	ee 0f       	add	r30, r30
    4962:	ff 1f       	adc	r31, r31
    4964:	ee 0f       	add	r30, r30
    4966:	ff 1f       	adc	r31, r31
    4968:	8e 0f       	add	r24, r30
    496a:	9f 1f       	adc	r25, r31
    496c:	fc 01       	movw	r30, r24
    496e:	e1 54       	subi	r30, 0x41	; 65
    4970:	f5 4e       	sbci	r31, 0xE5	; 229
    4972:	01 80       	ldd	r0, Z+1	; 0x01
    4974:	f2 81       	ldd	r31, Z+2	; 0x02
    4976:	e0 2d       	mov	r30, r0
    4978:	86 81       	ldd	r24, Z+6	; 0x06
    497a:	97 81       	ldd	r25, Z+7	; 0x07
    497c:	90 93 f6 1a 	sts	0x1AF6, r25	; 0x801af6 <pxCurrentTCB+0x1>
    4980:	80 93 f5 1a 	sts	0x1AF5, r24	; 0x801af5 <pxCurrentTCB>
    4984:	08 95       	ret

00004986 <vTaskPlaceOnEventList>:
    4986:	cf 93       	push	r28
    4988:	df 93       	push	r29
    498a:	eb 01       	movw	r28, r22
    498c:	20 91 f5 1a 	lds	r18, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    4990:	30 91 f6 1a 	lds	r19, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    4994:	b9 01       	movw	r22, r18
    4996:	64 5f       	subi	r22, 0xF4	; 244
    4998:	7f 4f       	sbci	r23, 0xFF	; 255
    499a:	0e 94 21 06 	call	0xc42	; 0xc42 <vListInsert>
    499e:	80 91 f5 1a 	lds	r24, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    49a2:	90 91 f6 1a 	lds	r25, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    49a6:	02 96       	adiw	r24, 0x02	; 2
    49a8:	0e 94 52 06 	call	0xca4	; 0xca4 <uxListRemove>
    49ac:	cf 3f       	cpi	r28, 0xFF	; 255
    49ae:	8f ef       	ldi	r24, 0xFF	; 255
    49b0:	d8 07       	cpc	r29, r24
    49b2:	59 f4       	brne	.+22     	; 0x49ca <vTaskPlaceOnEventList+0x44>
    49b4:	60 91 f5 1a 	lds	r22, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    49b8:	70 91 f6 1a 	lds	r23, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    49bc:	6e 5f       	subi	r22, 0xFE	; 254
    49be:	7f 4f       	sbci	r23, 0xFF	; 255
    49c0:	87 e9       	ldi	r24, 0x97	; 151
    49c2:	9a e1       	ldi	r25, 0x1A	; 26
    49c4:	0e 94 00 06 	call	0xc00	; 0xc00 <vListInsertEnd>
    49c8:	37 c0       	rjmp	.+110    	; 0x4a38 <vTaskPlaceOnEventList+0xb2>
    49ca:	80 91 94 1a 	lds	r24, 0x1A94	; 0x801a94 <xTickCount>
    49ce:	90 91 95 1a 	lds	r25, 0x1A95	; 0x801a95 <xTickCount+0x1>
    49d2:	c8 0f       	add	r28, r24
    49d4:	d9 1f       	adc	r29, r25
    49d6:	e0 91 f5 1a 	lds	r30, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    49da:	f0 91 f6 1a 	lds	r31, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    49de:	d3 83       	std	Z+3, r29	; 0x03
    49e0:	c2 83       	std	Z+2, r28	; 0x02
    49e2:	80 91 94 1a 	lds	r24, 0x1A94	; 0x801a94 <xTickCount>
    49e6:	90 91 95 1a 	lds	r25, 0x1A95	; 0x801a95 <xTickCount+0x1>
    49ea:	c8 17       	cp	r28, r24
    49ec:	d9 07       	cpc	r29, r25
    49ee:	68 f4       	brcc	.+26     	; 0x4a0a <vTaskPlaceOnEventList+0x84>
    49f0:	60 91 f5 1a 	lds	r22, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    49f4:	70 91 f6 1a 	lds	r23, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    49f8:	80 91 a9 1a 	lds	r24, 0x1AA9	; 0x801aa9 <pxOverflowDelayedTaskList>
    49fc:	90 91 aa 1a 	lds	r25, 0x1AAA	; 0x801aaa <pxOverflowDelayedTaskList+0x1>
    4a00:	6e 5f       	subi	r22, 0xFE	; 254
    4a02:	7f 4f       	sbci	r23, 0xFF	; 255
    4a04:	0e 94 21 06 	call	0xc42	; 0xc42 <vListInsert>
    4a08:	17 c0       	rjmp	.+46     	; 0x4a38 <vTaskPlaceOnEventList+0xb2>
    4a0a:	60 91 f5 1a 	lds	r22, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    4a0e:	70 91 f6 1a 	lds	r23, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    4a12:	80 91 ab 1a 	lds	r24, 0x1AAB	; 0x801aab <pxDelayedTaskList>
    4a16:	90 91 ac 1a 	lds	r25, 0x1AAC	; 0x801aac <pxDelayedTaskList+0x1>
    4a1a:	6e 5f       	subi	r22, 0xFE	; 254
    4a1c:	7f 4f       	sbci	r23, 0xFF	; 255
    4a1e:	0e 94 21 06 	call	0xc42	; 0xc42 <vListInsert>
    4a22:	80 91 8c 1a 	lds	r24, 0x1A8C	; 0x801a8c <xNextTaskUnblockTime>
    4a26:	90 91 8d 1a 	lds	r25, 0x1A8D	; 0x801a8d <xNextTaskUnblockTime+0x1>
    4a2a:	c8 17       	cp	r28, r24
    4a2c:	d9 07       	cpc	r29, r25
    4a2e:	20 f4       	brcc	.+8      	; 0x4a38 <vTaskPlaceOnEventList+0xb2>
    4a30:	d0 93 8d 1a 	sts	0x1A8D, r29	; 0x801a8d <xNextTaskUnblockTime+0x1>
    4a34:	c0 93 8c 1a 	sts	0x1A8C, r28	; 0x801a8c <xNextTaskUnblockTime>
    4a38:	df 91       	pop	r29
    4a3a:	cf 91       	pop	r28
    4a3c:	08 95       	ret

00004a3e <xTaskRemoveFromEventList>:
    4a3e:	0f 93       	push	r16
    4a40:	1f 93       	push	r17
    4a42:	cf 93       	push	r28
    4a44:	df 93       	push	r29
    4a46:	dc 01       	movw	r26, r24
    4a48:	15 96       	adiw	r26, 0x05	; 5
    4a4a:	ed 91       	ld	r30, X+
    4a4c:	fc 91       	ld	r31, X
    4a4e:	16 97       	sbiw	r26, 0x06	; 6
    4a50:	c6 81       	ldd	r28, Z+6	; 0x06
    4a52:	d7 81       	ldd	r29, Z+7	; 0x07
    4a54:	8e 01       	movw	r16, r28
    4a56:	04 5f       	subi	r16, 0xF4	; 244
    4a58:	1f 4f       	sbci	r17, 0xFF	; 255
    4a5a:	c8 01       	movw	r24, r16
    4a5c:	0e 94 52 06 	call	0xca4	; 0xca4 <uxListRemove>
    4a60:	80 91 8b 1a 	lds	r24, 0x1A8B	; 0x801a8b <uxSchedulerSuspended>
    4a64:	81 11       	cpse	r24, r1
    4a66:	1c c0       	rjmp	.+56     	; 0x4aa0 <xTaskRemoveFromEventList+0x62>
    4a68:	0a 50       	subi	r16, 0x0A	; 10
    4a6a:	11 09       	sbc	r17, r1
    4a6c:	c8 01       	movw	r24, r16
    4a6e:	0e 94 52 06 	call	0xca4	; 0xca4 <uxListRemove>
    4a72:	2e 89       	ldd	r18, Y+22	; 0x16
    4a74:	80 91 93 1a 	lds	r24, 0x1A93	; 0x801a93 <uxTopReadyPriority>
    4a78:	82 17       	cp	r24, r18
    4a7a:	10 f4       	brcc	.+4      	; 0x4a80 <xTaskRemoveFromEventList+0x42>
    4a7c:	20 93 93 1a 	sts	0x1A93, r18	; 0x801a93 <uxTopReadyPriority>
    4a80:	30 e0       	ldi	r19, 0x00	; 0
    4a82:	c9 01       	movw	r24, r18
    4a84:	88 0f       	add	r24, r24
    4a86:	99 1f       	adc	r25, r25
    4a88:	88 0f       	add	r24, r24
    4a8a:	99 1f       	adc	r25, r25
    4a8c:	88 0f       	add	r24, r24
    4a8e:	99 1f       	adc	r25, r25
    4a90:	82 0f       	add	r24, r18
    4a92:	93 1f       	adc	r25, r19
    4a94:	b8 01       	movw	r22, r16
    4a96:	81 54       	subi	r24, 0x41	; 65
    4a98:	95 4e       	sbci	r25, 0xE5	; 229
    4a9a:	0e 94 00 06 	call	0xc00	; 0xc00 <vListInsertEnd>
    4a9e:	05 c0       	rjmp	.+10     	; 0x4aaa <xTaskRemoveFromEventList+0x6c>
    4aa0:	b8 01       	movw	r22, r16
    4aa2:	80 ea       	ldi	r24, 0xA0	; 160
    4aa4:	9a e1       	ldi	r25, 0x1A	; 26
    4aa6:	0e 94 00 06 	call	0xc00	; 0xc00 <vListInsertEnd>
    4aaa:	e0 91 f5 1a 	lds	r30, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    4aae:	f0 91 f6 1a 	lds	r31, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    4ab2:	9e 89       	ldd	r25, Y+22	; 0x16
    4ab4:	86 89       	ldd	r24, Z+22	; 0x16
    4ab6:	89 17       	cp	r24, r25
    4ab8:	20 f4       	brcc	.+8      	; 0x4ac2 <xTaskRemoveFromEventList+0x84>
    4aba:	81 e0       	ldi	r24, 0x01	; 1
    4abc:	80 93 90 1a 	sts	0x1A90, r24	; 0x801a90 <xYieldPending>
    4ac0:	01 c0       	rjmp	.+2      	; 0x4ac4 <xTaskRemoveFromEventList+0x86>
    4ac2:	80 e0       	ldi	r24, 0x00	; 0
    4ac4:	df 91       	pop	r29
    4ac6:	cf 91       	pop	r28
    4ac8:	1f 91       	pop	r17
    4aca:	0f 91       	pop	r16
    4acc:	08 95       	ret

00004ace <vTaskSetTimeOutState>:
    4ace:	20 91 8f 1a 	lds	r18, 0x1A8F	; 0x801a8f <xNumOfOverflows>
    4ad2:	fc 01       	movw	r30, r24
    4ad4:	20 83       	st	Z, r18
    4ad6:	20 91 94 1a 	lds	r18, 0x1A94	; 0x801a94 <xTickCount>
    4ada:	30 91 95 1a 	lds	r19, 0x1A95	; 0x801a95 <xTickCount+0x1>
    4ade:	32 83       	std	Z+2, r19	; 0x02
    4ae0:	21 83       	std	Z+1, r18	; 0x01
    4ae2:	08 95       	ret

00004ae4 <xTaskCheckForTimeOut>:
    4ae4:	fc 01       	movw	r30, r24
    4ae6:	0f b6       	in	r0, 0x3f	; 63
    4ae8:	f8 94       	cli
    4aea:	0f 92       	push	r0
    4aec:	20 91 94 1a 	lds	r18, 0x1A94	; 0x801a94 <xTickCount>
    4af0:	30 91 95 1a 	lds	r19, 0x1A95	; 0x801a95 <xTickCount+0x1>
    4af4:	db 01       	movw	r26, r22
    4af6:	8d 91       	ld	r24, X+
    4af8:	9c 91       	ld	r25, X
    4afa:	8f 3f       	cpi	r24, 0xFF	; 255
    4afc:	bf ef       	ldi	r27, 0xFF	; 255
    4afe:	9b 07       	cpc	r25, r27
    4b00:	21 f1       	breq	.+72     	; 0x4b4a <xTaskCheckForTimeOut+0x66>
    4b02:	40 91 8f 1a 	lds	r20, 0x1A8F	; 0x801a8f <xNumOfOverflows>
    4b06:	50 81       	ld	r21, Z
    4b08:	54 17       	cp	r21, r20
    4b0a:	29 f0       	breq	.+10     	; 0x4b16 <xTaskCheckForTimeOut+0x32>
    4b0c:	41 81       	ldd	r20, Z+1	; 0x01
    4b0e:	52 81       	ldd	r21, Z+2	; 0x02
    4b10:	24 17       	cp	r18, r20
    4b12:	35 07       	cpc	r19, r21
    4b14:	e0 f4       	brcc	.+56     	; 0x4b4e <xTaskCheckForTimeOut+0x6a>
    4b16:	41 81       	ldd	r20, Z+1	; 0x01
    4b18:	52 81       	ldd	r21, Z+2	; 0x02
    4b1a:	d9 01       	movw	r26, r18
    4b1c:	a4 1b       	sub	r26, r20
    4b1e:	b5 0b       	sbc	r27, r21
    4b20:	a8 17       	cp	r26, r24
    4b22:	b9 07       	cpc	r27, r25
    4b24:	b0 f4       	brcc	.+44     	; 0x4b52 <xTaskCheckForTimeOut+0x6e>
    4b26:	42 1b       	sub	r20, r18
    4b28:	53 0b       	sbc	r21, r19
    4b2a:	84 0f       	add	r24, r20
    4b2c:	95 1f       	adc	r25, r21
    4b2e:	db 01       	movw	r26, r22
    4b30:	8d 93       	st	X+, r24
    4b32:	9c 93       	st	X, r25
    4b34:	80 91 8f 1a 	lds	r24, 0x1A8F	; 0x801a8f <xNumOfOverflows>
    4b38:	80 83       	st	Z, r24
    4b3a:	80 91 94 1a 	lds	r24, 0x1A94	; 0x801a94 <xTickCount>
    4b3e:	90 91 95 1a 	lds	r25, 0x1A95	; 0x801a95 <xTickCount+0x1>
    4b42:	92 83       	std	Z+2, r25	; 0x02
    4b44:	81 83       	std	Z+1, r24	; 0x01
    4b46:	80 e0       	ldi	r24, 0x00	; 0
    4b48:	05 c0       	rjmp	.+10     	; 0x4b54 <xTaskCheckForTimeOut+0x70>
    4b4a:	80 e0       	ldi	r24, 0x00	; 0
    4b4c:	03 c0       	rjmp	.+6      	; 0x4b54 <xTaskCheckForTimeOut+0x70>
    4b4e:	81 e0       	ldi	r24, 0x01	; 1
    4b50:	01 c0       	rjmp	.+2      	; 0x4b54 <xTaskCheckForTimeOut+0x70>
    4b52:	81 e0       	ldi	r24, 0x01	; 1
    4b54:	0f 90       	pop	r0
    4b56:	0f be       	out	0x3f, r0	; 63
    4b58:	08 95       	ret

00004b5a <vTaskMissedYield>:
    4b5a:	81 e0       	ldi	r24, 0x01	; 1
    4b5c:	80 93 90 1a 	sts	0x1A90, r24	; 0x801a90 <xYieldPending>
    4b60:	08 95       	ret

00004b62 <vTaskPriorityInherit>:
    4b62:	0f 93       	push	r16
    4b64:	1f 93       	push	r17
    4b66:	cf 93       	push	r28
    4b68:	df 93       	push	r29
    4b6a:	fc 01       	movw	r30, r24
    4b6c:	89 2b       	or	r24, r25
    4b6e:	09 f4       	brne	.+2      	; 0x4b72 <vTaskPriorityInherit+0x10>
    4b70:	55 c0       	rjmp	.+170    	; 0x4c1c <vTaskPriorityInherit+0xba>
    4b72:	26 89       	ldd	r18, Z+22	; 0x16
    4b74:	a0 91 f5 1a 	lds	r26, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    4b78:	b0 91 f6 1a 	lds	r27, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    4b7c:	56 96       	adiw	r26, 0x16	; 22
    4b7e:	8c 91       	ld	r24, X
    4b80:	28 17       	cp	r18, r24
    4b82:	08 f0       	brcs	.+2      	; 0x4b86 <vTaskPriorityInherit+0x24>
    4b84:	4b c0       	rjmp	.+150    	; 0x4c1c <vTaskPriorityInherit+0xba>
    4b86:	84 85       	ldd	r24, Z+12	; 0x0c
    4b88:	95 85       	ldd	r25, Z+13	; 0x0d
    4b8a:	99 23       	and	r25, r25
    4b8c:	64 f0       	brlt	.+24     	; 0x4ba6 <vTaskPriorityInherit+0x44>
    4b8e:	a0 91 f5 1a 	lds	r26, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    4b92:	b0 91 f6 1a 	lds	r27, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    4b96:	56 96       	adiw	r26, 0x16	; 22
    4b98:	3c 91       	ld	r19, X
    4b9a:	86 e0       	ldi	r24, 0x06	; 6
    4b9c:	90 e0       	ldi	r25, 0x00	; 0
    4b9e:	83 1b       	sub	r24, r19
    4ba0:	91 09       	sbc	r25, r1
    4ba2:	95 87       	std	Z+13, r25	; 0x0d
    4ba4:	84 87       	std	Z+12, r24	; 0x0c
    4ba6:	30 e0       	ldi	r19, 0x00	; 0
    4ba8:	c9 01       	movw	r24, r18
    4baa:	88 0f       	add	r24, r24
    4bac:	99 1f       	adc	r25, r25
    4bae:	88 0f       	add	r24, r24
    4bb0:	99 1f       	adc	r25, r25
    4bb2:	88 0f       	add	r24, r24
    4bb4:	99 1f       	adc	r25, r25
    4bb6:	28 0f       	add	r18, r24
    4bb8:	39 1f       	adc	r19, r25
    4bba:	21 54       	subi	r18, 0x41	; 65
    4bbc:	35 4e       	sbci	r19, 0xE5	; 229
    4bbe:	82 85       	ldd	r24, Z+10	; 0x0a
    4bc0:	93 85       	ldd	r25, Z+11	; 0x0b
    4bc2:	82 17       	cp	r24, r18
    4bc4:	93 07       	cpc	r25, r19
    4bc6:	19 f5       	brne	.+70     	; 0x4c0e <vTaskPriorityInherit+0xac>
    4bc8:	8f 01       	movw	r16, r30
    4bca:	ef 01       	movw	r28, r30
    4bcc:	22 96       	adiw	r28, 0x02	; 2
    4bce:	ce 01       	movw	r24, r28
    4bd0:	0e 94 52 06 	call	0xca4	; 0xca4 <uxListRemove>
    4bd4:	e0 91 f5 1a 	lds	r30, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    4bd8:	f0 91 f6 1a 	lds	r31, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    4bdc:	26 89       	ldd	r18, Z+22	; 0x16
    4bde:	f8 01       	movw	r30, r16
    4be0:	26 8b       	std	Z+22, r18	; 0x16
    4be2:	80 91 93 1a 	lds	r24, 0x1A93	; 0x801a93 <uxTopReadyPriority>
    4be6:	82 17       	cp	r24, r18
    4be8:	10 f4       	brcc	.+4      	; 0x4bee <vTaskPriorityInherit+0x8c>
    4bea:	20 93 93 1a 	sts	0x1A93, r18	; 0x801a93 <uxTopReadyPriority>
    4bee:	30 e0       	ldi	r19, 0x00	; 0
    4bf0:	c9 01       	movw	r24, r18
    4bf2:	88 0f       	add	r24, r24
    4bf4:	99 1f       	adc	r25, r25
    4bf6:	88 0f       	add	r24, r24
    4bf8:	99 1f       	adc	r25, r25
    4bfa:	88 0f       	add	r24, r24
    4bfc:	99 1f       	adc	r25, r25
    4bfe:	82 0f       	add	r24, r18
    4c00:	93 1f       	adc	r25, r19
    4c02:	be 01       	movw	r22, r28
    4c04:	81 54       	subi	r24, 0x41	; 65
    4c06:	95 4e       	sbci	r25, 0xE5	; 229
    4c08:	0e 94 00 06 	call	0xc00	; 0xc00 <vListInsertEnd>
    4c0c:	07 c0       	rjmp	.+14     	; 0x4c1c <vTaskPriorityInherit+0xba>
    4c0e:	a0 91 f5 1a 	lds	r26, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    4c12:	b0 91 f6 1a 	lds	r27, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    4c16:	56 96       	adiw	r26, 0x16	; 22
    4c18:	8c 91       	ld	r24, X
    4c1a:	86 8b       	std	Z+22, r24	; 0x16
    4c1c:	df 91       	pop	r29
    4c1e:	cf 91       	pop	r28
    4c20:	1f 91       	pop	r17
    4c22:	0f 91       	pop	r16
    4c24:	08 95       	ret

00004c26 <xTaskPriorityDisinherit>:
    4c26:	0f 93       	push	r16
    4c28:	1f 93       	push	r17
    4c2a:	cf 93       	push	r28
    4c2c:	df 93       	push	r29
    4c2e:	fc 01       	movw	r30, r24
    4c30:	89 2b       	or	r24, r25
    4c32:	79 f1       	breq	.+94     	; 0x4c92 <xTaskPriorityDisinherit+0x6c>
    4c34:	82 a1       	ldd	r24, Z+34	; 0x22
    4c36:	81 50       	subi	r24, 0x01	; 1
    4c38:	82 a3       	std	Z+34, r24	; 0x22
    4c3a:	26 89       	ldd	r18, Z+22	; 0x16
    4c3c:	91 a1       	ldd	r25, Z+33	; 0x21
    4c3e:	29 17       	cp	r18, r25
    4c40:	51 f1       	breq	.+84     	; 0x4c96 <xTaskPriorityDisinherit+0x70>
    4c42:	81 11       	cpse	r24, r1
    4c44:	2a c0       	rjmp	.+84     	; 0x4c9a <xTaskPriorityDisinherit+0x74>
    4c46:	ef 01       	movw	r28, r30
    4c48:	8f 01       	movw	r16, r30
    4c4a:	0e 5f       	subi	r16, 0xFE	; 254
    4c4c:	1f 4f       	sbci	r17, 0xFF	; 255
    4c4e:	c8 01       	movw	r24, r16
    4c50:	0e 94 52 06 	call	0xca4	; 0xca4 <uxListRemove>
    4c54:	29 a1       	ldd	r18, Y+33	; 0x21
    4c56:	2e 8b       	std	Y+22, r18	; 0x16
    4c58:	46 e0       	ldi	r20, 0x06	; 6
    4c5a:	50 e0       	ldi	r21, 0x00	; 0
    4c5c:	42 1b       	sub	r20, r18
    4c5e:	51 09       	sbc	r21, r1
    4c60:	5d 87       	std	Y+13, r21	; 0x0d
    4c62:	4c 87       	std	Y+12, r20	; 0x0c
    4c64:	80 91 93 1a 	lds	r24, 0x1A93	; 0x801a93 <uxTopReadyPriority>
    4c68:	82 17       	cp	r24, r18
    4c6a:	10 f4       	brcc	.+4      	; 0x4c70 <xTaskPriorityDisinherit+0x4a>
    4c6c:	20 93 93 1a 	sts	0x1A93, r18	; 0x801a93 <uxTopReadyPriority>
    4c70:	30 e0       	ldi	r19, 0x00	; 0
    4c72:	c9 01       	movw	r24, r18
    4c74:	88 0f       	add	r24, r24
    4c76:	99 1f       	adc	r25, r25
    4c78:	88 0f       	add	r24, r24
    4c7a:	99 1f       	adc	r25, r25
    4c7c:	88 0f       	add	r24, r24
    4c7e:	99 1f       	adc	r25, r25
    4c80:	82 0f       	add	r24, r18
    4c82:	93 1f       	adc	r25, r19
    4c84:	b8 01       	movw	r22, r16
    4c86:	81 54       	subi	r24, 0x41	; 65
    4c88:	95 4e       	sbci	r25, 0xE5	; 229
    4c8a:	0e 94 00 06 	call	0xc00	; 0xc00 <vListInsertEnd>
    4c8e:	81 e0       	ldi	r24, 0x01	; 1
    4c90:	05 c0       	rjmp	.+10     	; 0x4c9c <xTaskPriorityDisinherit+0x76>
    4c92:	80 e0       	ldi	r24, 0x00	; 0
    4c94:	03 c0       	rjmp	.+6      	; 0x4c9c <xTaskPriorityDisinherit+0x76>
    4c96:	80 e0       	ldi	r24, 0x00	; 0
    4c98:	01 c0       	rjmp	.+2      	; 0x4c9c <xTaskPriorityDisinherit+0x76>
    4c9a:	80 e0       	ldi	r24, 0x00	; 0
    4c9c:	df 91       	pop	r29
    4c9e:	cf 91       	pop	r28
    4ca0:	1f 91       	pop	r17
    4ca2:	0f 91       	pop	r16
    4ca4:	08 95       	ret

00004ca6 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    4ca6:	80 91 f5 1a 	lds	r24, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    4caa:	90 91 f6 1a 	lds	r25, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    4cae:	89 2b       	or	r24, r25
    4cb0:	39 f0       	breq	.+14     	; 0x4cc0 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    4cb2:	e0 91 f5 1a 	lds	r30, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    4cb6:	f0 91 f6 1a 	lds	r31, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
    4cba:	82 a1       	ldd	r24, Z+34	; 0x22
    4cbc:	8f 5f       	subi	r24, 0xFF	; 255
    4cbe:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    4cc0:	80 91 f5 1a 	lds	r24, 0x1AF5	; 0x801af5 <pxCurrentTCB>
    4cc4:	90 91 f6 1a 	lds	r25, 0x1AF6	; 0x801af6 <pxCurrentTCB+0x1>
	}
    4cc8:	08 95       	ret

00004cca <vTWI_init>:
    data[(length-1)] = ui8TWI_read_nack();

    vTWI_stop();

    return 0;
}
    4cca:	88 e4       	ldi	r24, 0x48	; 72
    4ccc:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7000b8>
    4cd0:	08 95       	ret

00004cd2 <ui8TWI_start>:
    4cd2:	ec eb       	ldi	r30, 0xBC	; 188
    4cd4:	f0 e0       	ldi	r31, 0x00	; 0
    4cd6:	10 82       	st	Z, r1
    4cd8:	94 ea       	ldi	r25, 0xA4	; 164
    4cda:	90 83       	st	Z, r25
    4cdc:	90 81       	ld	r25, Z
    4cde:	99 23       	and	r25, r25
    4ce0:	ec f7       	brge	.-6      	; 0x4cdc <ui8TWI_start+0xa>
    4ce2:	90 91 b9 00 	lds	r25, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
    4ce6:	98 7f       	andi	r25, 0xF8	; 248
    4ce8:	98 30       	cpi	r25, 0x08	; 8
    4cea:	a1 f4       	brne	.+40     	; 0x4d14 <ui8TWI_start+0x42>
    4cec:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
    4cf0:	84 e8       	ldi	r24, 0x84	; 132
    4cf2:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
    4cf6:	ec eb       	ldi	r30, 0xBC	; 188
    4cf8:	f0 e0       	ldi	r31, 0x00	; 0
    4cfa:	80 81       	ld	r24, Z
    4cfc:	88 23       	and	r24, r24
    4cfe:	ec f7       	brge	.-6      	; 0x4cfa <ui8TWI_start+0x28>
    4d00:	90 91 b9 00 	lds	r25, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
    4d04:	98 7f       	andi	r25, 0xF8	; 248
    4d06:	98 31       	cpi	r25, 0x18	; 24
    4d08:	39 f0       	breq	.+14     	; 0x4d18 <ui8TWI_start+0x46>
    4d0a:	81 e0       	ldi	r24, 0x01	; 1
    4d0c:	90 34       	cpi	r25, 0x40	; 64
    4d0e:	29 f4       	brne	.+10     	; 0x4d1a <ui8TWI_start+0x48>
    4d10:	80 e0       	ldi	r24, 0x00	; 0
    4d12:	08 95       	ret
    4d14:	81 e0       	ldi	r24, 0x01	; 1
    4d16:	08 95       	ret
    4d18:	80 e0       	ldi	r24, 0x00	; 0
    4d1a:	08 95       	ret

00004d1c <ui8TWI_write>:
    4d1c:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
    4d20:	84 e8       	ldi	r24, 0x84	; 132
    4d22:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
    4d26:	ec eb       	ldi	r30, 0xBC	; 188
    4d28:	f0 e0       	ldi	r31, 0x00	; 0
    4d2a:	80 81       	ld	r24, Z
    4d2c:	88 23       	and	r24, r24
    4d2e:	ec f7       	brge	.-6      	; 0x4d2a <ui8TWI_write+0xe>
    4d30:	90 91 b9 00 	lds	r25, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
    4d34:	98 7f       	andi	r25, 0xF8	; 248
    4d36:	81 e0       	ldi	r24, 0x01	; 1
    4d38:	98 32       	cpi	r25, 0x28	; 40
    4d3a:	09 f4       	brne	.+2      	; 0x4d3e <ui8TWI_write+0x22>
    4d3c:	80 e0       	ldi	r24, 0x00	; 0
    4d3e:	08 95       	ret

00004d40 <ui8TWI_read_ack>:
    4d40:	84 ec       	ldi	r24, 0xC4	; 196
    4d42:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
    4d46:	ec eb       	ldi	r30, 0xBC	; 188
    4d48:	f0 e0       	ldi	r31, 0x00	; 0
    4d4a:	80 81       	ld	r24, Z
    4d4c:	88 23       	and	r24, r24
    4d4e:	ec f7       	brge	.-6      	; 0x4d4a <ui8TWI_read_ack+0xa>
    4d50:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
    4d54:	08 95       	ret

00004d56 <ui8TWI_read_nack>:
    4d56:	84 e8       	ldi	r24, 0x84	; 132
    4d58:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
    4d5c:	ec eb       	ldi	r30, 0xBC	; 188
    4d5e:	f0 e0       	ldi	r31, 0x00	; 0
    4d60:	80 81       	ld	r24, Z
    4d62:	88 23       	and	r24, r24
    4d64:	ec f7       	brge	.-6      	; 0x4d60 <ui8TWI_read_nack+0xa>
    4d66:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
    4d6a:	08 95       	ret

00004d6c <vTWI_stop>:

void vTWI_stop(void){
    // transmit STOP condition
    TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
    4d6c:	84 e9       	ldi	r24, 0x94	; 148
    4d6e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
    4d72:	08 95       	ret

00004d74 <uart_putchar>:
    }
}

// Included to be able to use printf
static void uart_putchar(char c, FILE *stream)
{
    4d74:	cf 93       	push	r28
    if (nRFconnected){ // No point in sending if we're not connected.        
    4d76:	64 99       	sbic	0x0c, 4	; 12
    4d78:	1b c0       	rjmp	.+54     	; 0x4db0 <uart_putchar+0x3c>
    4d7a:	c8 2f       	mov	r28, r24
        xSemaphoreTake(xUartMutex,200);
    4d7c:	20 e0       	ldi	r18, 0x00	; 0
    4d7e:	48 ec       	ldi	r20, 0xC8	; 200
    4d80:	50 e0       	ldi	r21, 0x00	; 0
    4d82:	60 e0       	ldi	r22, 0x00	; 0
    4d84:	70 e0       	ldi	r23, 0x00	; 0
    4d86:	80 91 1c 1b 	lds	r24, 0x1B1C	; 0x801b1c <xUartMutex>
    4d8a:	90 91 1d 1b 	lds	r25, 0x1B1D	; 0x801b1d <xUartMutex+0x1>
    4d8e:	0e 94 34 1b 	call	0x3668	; 0x3668 <xQueueGenericReceive>
        loop_until_bit_is_set(UCSR2A, UDRE2); // Macro from <avr/io.h>, wait until bit bit in IO register is set.
    4d92:	e0 ed       	ldi	r30, 0xD0	; 208
    4d94:	f0 e0       	ldi	r31, 0x00	; 0
    4d96:	90 81       	ld	r25, Z
    4d98:	95 ff       	sbrs	r25, 5
    4d9a:	fd cf       	rjmp	.-6      	; 0x4d96 <uart_putchar+0x22>
        UDR2 = c;
    4d9c:	c0 93 d6 00 	sts	0x00D6, r28	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
        xSemaphoreGive(xUartMutex);
    4da0:	60 e0       	ldi	r22, 0x00	; 0
    4da2:	70 e0       	ldi	r23, 0x00	; 0
    4da4:	80 91 1c 1b 	lds	r24, 0x1B1C	; 0x801b1c <xUartMutex>
    4da8:	90 91 1d 1b 	lds	r25, 0x1B1D	; 0x801b1d <xUartMutex+0x1>
    4dac:	0e 94 9a 19 	call	0x3334	; 0x3334 <xQueueGive>
    } 
}
    4db0:	cf 91       	pop	r28
    4db2:	08 95       	ret

00004db4 <vUSART_init>:
// Note that the nRF51 dongle is limited to send 20 characters
// in each package
/************************************************************************/
void vUSART_init(){
    /* Set baud rate, has to match nRF51 dongle! */
    UBRR2H = (unsigned char)(BAUD_PRESCALE>>8);
    4db4:	10 92 d5 00 	sts	0x00D5, r1	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7000d5>
    UBRR2L = (unsigned char)BAUD_PRESCALE;
    4db8:	89 e1       	ldi	r24, 0x19	; 25
    4dba:	80 93 d4 00 	sts	0x00D4, r24	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7000d4>
    
    /* RX/TX Complete, data register empty */
    UCSR2A = (1<<RXC2) | (1<<TXC2) | (1<<UDRE2);
    4dbe:	80 ee       	ldi	r24, 0xE0	; 224
    4dc0:	80 93 d0 00 	sts	0x00D0, r24	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>

    /* Enable reciever, transmitter, and recieve interrupt enable*/
    UCSR2B = (1<<RXEN2) | (1<<TXEN2) | (1<<RXCIE2);
    4dc4:	88 e9       	ldi	r24, 0x98	; 152
    4dc6:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7000d1>

    /* Set frame format: 8data, 1 stop bit, no parity */
    UCSR2C = (1<<UCSZ20) | (1<<UCSZ21);
    4dca:	e2 ed       	ldi	r30, 0xD2	; 210
    4dcc:	f0 e0       	ldi	r31, 0x00	; 0
    4dce:	86 e0       	ldi	r24, 0x06	; 6
    4dd0:	80 83       	st	Z, r24
    UCSR2C &= ~((1<<USBS2) & (1<<UPM21) & (1<<UPM20));
    4dd2:	80 81       	ld	r24, Z
    4dd4:	80 83       	st	Z, r24

    stdout = &mystdout; //Required for printf init
    4dd6:	80 e0       	ldi	r24, 0x00	; 0
    4dd8:	96 e0       	ldi	r25, 0x06	; 6
    4dda:	90 93 3d 1b 	sts	0x1B3D, r25	; 0x801b3d <__iob+0x3>
    4dde:	80 93 3c 1b 	sts	0x1B3C, r24	; 0x801b3c <__iob+0x2>
    4de2:	08 95       	ret

00004de4 <vUSART_sendC>:
}

void vUSART_sendC(char c){
    if (nRFconnected){ // No point in sending if we're not connected.
    4de4:	64 99       	sbic	0x0c, 4	; 12
    4de6:	07 c0       	rjmp	.+14     	; 0x4df6 <vUSART_sendC+0x12>
        while ( !( UCSR2A & (1<<UDRE2)) );
    4de8:	e0 ed       	ldi	r30, 0xD0	; 208
    4dea:	f0 e0       	ldi	r31, 0x00	; 0
    4dec:	90 81       	ld	r25, Z
    4dee:	95 ff       	sbrs	r25, 5
    4df0:	fd cf       	rjmp	.-6      	; 0x4dec <vUSART_sendC+0x8>
        UDR2 = c;
    4df2:	80 93 d6 00 	sts	0x00D6, r24	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    4df6:	08 95       	ret

00004df8 <vUSART_sendS>:
        UDR2 = c;
        xSemaphoreGive(xUartMutex);
    } 
}

void vUSART_sendS(char *s){
    4df8:	cf 93       	push	r28
    4dfa:	df 93       	push	r29
    4dfc:	ec 01       	movw	r28, r24
    while (*s != 0x00){
    4dfe:	88 81       	ld	r24, Y
    4e00:	88 23       	and	r24, r24
    4e02:	29 f0       	breq	.+10     	; 0x4e0e <vUSART_sendS+0x16>
    4e04:	21 96       	adiw	r28, 0x01	; 1
        vUSART_sendC(*s);
    4e06:	ee df       	rcall	.-36     	; 0x4de4 <vUSART_sendC>
        xSemaphoreGive(xUartMutex);
    } 
}

void vUSART_sendS(char *s){
    while (*s != 0x00){
    4e08:	89 91       	ld	r24, Y+
    4e0a:	81 11       	cpse	r24, r1
    4e0c:	fc cf       	rjmp	.-8      	; 0x4e06 <vUSART_sendS+0xe>
        vUSART_sendC(*s);
        s++;
    }
}
    4e0e:	df 91       	pop	r29
    4e10:	cf 91       	pop	r28
    4e12:	08 95       	ret

00004e14 <vUSART_sendHandshake>:

void vUSART_sendHandshake(){
    printf(HANDSHAKE
    4e14:	8d ef       	ldi	r24, 0xFD	; 253
    4e16:	97 e0       	ldi	r25, 0x07	; 7
    4e18:	0c 94 f9 2f 	jmp	0x5ff2	; 0x5ff2 <puts>
    4e1c:	08 95       	ret

00004e1e <__subsf3>:
    4e1e:	50 58       	subi	r21, 0x80	; 128

00004e20 <__addsf3>:
    4e20:	bb 27       	eor	r27, r27
    4e22:	aa 27       	eor	r26, r26
    4e24:	0e d0       	rcall	.+28     	; 0x4e42 <__addsf3x>
    4e26:	27 c2       	rjmp	.+1102   	; 0x5276 <__fp_round>
    4e28:	f0 d1       	rcall	.+992    	; 0x520a <__fp_pscA>
    4e2a:	30 f0       	brcs	.+12     	; 0x4e38 <__addsf3+0x18>
    4e2c:	f5 d1       	rcall	.+1002   	; 0x5218 <__fp_pscB>
    4e2e:	20 f0       	brcs	.+8      	; 0x4e38 <__addsf3+0x18>
    4e30:	31 f4       	brne	.+12     	; 0x4e3e <__addsf3+0x1e>
    4e32:	9f 3f       	cpi	r25, 0xFF	; 255
    4e34:	11 f4       	brne	.+4      	; 0x4e3a <__addsf3+0x1a>
    4e36:	1e f4       	brtc	.+6      	; 0x4e3e <__addsf3+0x1e>
    4e38:	c0 c1       	rjmp	.+896    	; 0x51ba <__fp_nan>
    4e3a:	0e f4       	brtc	.+2      	; 0x4e3e <__addsf3+0x1e>
    4e3c:	e0 95       	com	r30
    4e3e:	e7 fb       	bst	r30, 7
    4e40:	b6 c1       	rjmp	.+876    	; 0x51ae <__fp_inf>

00004e42 <__addsf3x>:
    4e42:	e9 2f       	mov	r30, r25
    4e44:	3a d2       	rcall	.+1140   	; 0x52ba <__fp_split3>
    4e46:	80 f3       	brcs	.-32     	; 0x4e28 <__addsf3+0x8>
    4e48:	ba 17       	cp	r27, r26
    4e4a:	62 07       	cpc	r22, r18
    4e4c:	73 07       	cpc	r23, r19
    4e4e:	84 07       	cpc	r24, r20
    4e50:	95 07       	cpc	r25, r21
    4e52:	18 f0       	brcs	.+6      	; 0x4e5a <__addsf3x+0x18>
    4e54:	71 f4       	brne	.+28     	; 0x4e72 <__addsf3x+0x30>
    4e56:	9e f5       	brtc	.+102    	; 0x4ebe <__addsf3x+0x7c>
    4e58:	52 c2       	rjmp	.+1188   	; 0x52fe <__fp_zero>
    4e5a:	0e f4       	brtc	.+2      	; 0x4e5e <__addsf3x+0x1c>
    4e5c:	e0 95       	com	r30
    4e5e:	0b 2e       	mov	r0, r27
    4e60:	ba 2f       	mov	r27, r26
    4e62:	a0 2d       	mov	r26, r0
    4e64:	0b 01       	movw	r0, r22
    4e66:	b9 01       	movw	r22, r18
    4e68:	90 01       	movw	r18, r0
    4e6a:	0c 01       	movw	r0, r24
    4e6c:	ca 01       	movw	r24, r20
    4e6e:	a0 01       	movw	r20, r0
    4e70:	11 24       	eor	r1, r1
    4e72:	ff 27       	eor	r31, r31
    4e74:	59 1b       	sub	r21, r25
    4e76:	99 f0       	breq	.+38     	; 0x4e9e <__addsf3x+0x5c>
    4e78:	59 3f       	cpi	r21, 0xF9	; 249
    4e7a:	50 f4       	brcc	.+20     	; 0x4e90 <__addsf3x+0x4e>
    4e7c:	50 3e       	cpi	r21, 0xE0	; 224
    4e7e:	68 f1       	brcs	.+90     	; 0x4eda <__addsf3x+0x98>
    4e80:	1a 16       	cp	r1, r26
    4e82:	f0 40       	sbci	r31, 0x00	; 0
    4e84:	a2 2f       	mov	r26, r18
    4e86:	23 2f       	mov	r18, r19
    4e88:	34 2f       	mov	r19, r20
    4e8a:	44 27       	eor	r20, r20
    4e8c:	58 5f       	subi	r21, 0xF8	; 248
    4e8e:	f3 cf       	rjmp	.-26     	; 0x4e76 <__addsf3x+0x34>
    4e90:	46 95       	lsr	r20
    4e92:	37 95       	ror	r19
    4e94:	27 95       	ror	r18
    4e96:	a7 95       	ror	r26
    4e98:	f0 40       	sbci	r31, 0x00	; 0
    4e9a:	53 95       	inc	r21
    4e9c:	c9 f7       	brne	.-14     	; 0x4e90 <__addsf3x+0x4e>
    4e9e:	7e f4       	brtc	.+30     	; 0x4ebe <__addsf3x+0x7c>
    4ea0:	1f 16       	cp	r1, r31
    4ea2:	ba 0b       	sbc	r27, r26
    4ea4:	62 0b       	sbc	r22, r18
    4ea6:	73 0b       	sbc	r23, r19
    4ea8:	84 0b       	sbc	r24, r20
    4eaa:	ba f0       	brmi	.+46     	; 0x4eda <__addsf3x+0x98>
    4eac:	91 50       	subi	r25, 0x01	; 1
    4eae:	a1 f0       	breq	.+40     	; 0x4ed8 <__addsf3x+0x96>
    4eb0:	ff 0f       	add	r31, r31
    4eb2:	bb 1f       	adc	r27, r27
    4eb4:	66 1f       	adc	r22, r22
    4eb6:	77 1f       	adc	r23, r23
    4eb8:	88 1f       	adc	r24, r24
    4eba:	c2 f7       	brpl	.-16     	; 0x4eac <__addsf3x+0x6a>
    4ebc:	0e c0       	rjmp	.+28     	; 0x4eda <__addsf3x+0x98>
    4ebe:	ba 0f       	add	r27, r26
    4ec0:	62 1f       	adc	r22, r18
    4ec2:	73 1f       	adc	r23, r19
    4ec4:	84 1f       	adc	r24, r20
    4ec6:	48 f4       	brcc	.+18     	; 0x4eda <__addsf3x+0x98>
    4ec8:	87 95       	ror	r24
    4eca:	77 95       	ror	r23
    4ecc:	67 95       	ror	r22
    4ece:	b7 95       	ror	r27
    4ed0:	f7 95       	ror	r31
    4ed2:	9e 3f       	cpi	r25, 0xFE	; 254
    4ed4:	08 f0       	brcs	.+2      	; 0x4ed8 <__addsf3x+0x96>
    4ed6:	b3 cf       	rjmp	.-154    	; 0x4e3e <__addsf3+0x1e>
    4ed8:	93 95       	inc	r25
    4eda:	88 0f       	add	r24, r24
    4edc:	08 f0       	brcs	.+2      	; 0x4ee0 <__addsf3x+0x9e>
    4ede:	99 27       	eor	r25, r25
    4ee0:	ee 0f       	add	r30, r30
    4ee2:	97 95       	ror	r25
    4ee4:	87 95       	ror	r24
    4ee6:	08 95       	ret
    4ee8:	90 d1       	rcall	.+800    	; 0x520a <__fp_pscA>
    4eea:	58 f0       	brcs	.+22     	; 0x4f02 <__addsf3x+0xc0>
    4eec:	80 e8       	ldi	r24, 0x80	; 128
    4eee:	91 e0       	ldi	r25, 0x01	; 1
    4ef0:	09 f4       	brne	.+2      	; 0x4ef4 <__addsf3x+0xb2>
    4ef2:	9e ef       	ldi	r25, 0xFE	; 254
    4ef4:	91 d1       	rcall	.+802    	; 0x5218 <__fp_pscB>
    4ef6:	28 f0       	brcs	.+10     	; 0x4f02 <__addsf3x+0xc0>
    4ef8:	40 e8       	ldi	r20, 0x80	; 128
    4efa:	51 e0       	ldi	r21, 0x01	; 1
    4efc:	59 f4       	brne	.+22     	; 0x4f14 <atan2+0xe>
    4efe:	5e ef       	ldi	r21, 0xFE	; 254
    4f00:	09 c0       	rjmp	.+18     	; 0x4f14 <atan2+0xe>
    4f02:	5b c1       	rjmp	.+694    	; 0x51ba <__fp_nan>
    4f04:	fc c1       	rjmp	.+1016   	; 0x52fe <__fp_zero>

00004f06 <atan2>:
    4f06:	e9 2f       	mov	r30, r25
    4f08:	e0 78       	andi	r30, 0x80	; 128
    4f0a:	d7 d1       	rcall	.+942    	; 0x52ba <__fp_split3>
    4f0c:	68 f3       	brcs	.-38     	; 0x4ee8 <__addsf3x+0xa6>
    4f0e:	09 2e       	mov	r0, r25
    4f10:	05 2a       	or	r0, r21
    4f12:	c1 f3       	breq	.-16     	; 0x4f04 <__addsf3x+0xc2>
    4f14:	26 17       	cp	r18, r22
    4f16:	37 07       	cpc	r19, r23
    4f18:	48 07       	cpc	r20, r24
    4f1a:	59 07       	cpc	r21, r25
    4f1c:	38 f0       	brcs	.+14     	; 0x4f2c <atan2+0x26>
    4f1e:	0e 2e       	mov	r0, r30
    4f20:	07 f8       	bld	r0, 7
    4f22:	e0 25       	eor	r30, r0
    4f24:	69 f0       	breq	.+26     	; 0x4f40 <atan2+0x3a>
    4f26:	e0 25       	eor	r30, r0
    4f28:	e0 64       	ori	r30, 0x40	; 64
    4f2a:	0a c0       	rjmp	.+20     	; 0x4f40 <atan2+0x3a>
    4f2c:	ef 63       	ori	r30, 0x3F	; 63
    4f2e:	07 f8       	bld	r0, 7
    4f30:	00 94       	com	r0
    4f32:	07 fa       	bst	r0, 7
    4f34:	db 01       	movw	r26, r22
    4f36:	b9 01       	movw	r22, r18
    4f38:	9d 01       	movw	r18, r26
    4f3a:	dc 01       	movw	r26, r24
    4f3c:	ca 01       	movw	r24, r20
    4f3e:	ad 01       	movw	r20, r26
    4f40:	ef 93       	push	r30
    4f42:	4a d0       	rcall	.+148    	; 0x4fd8 <__divsf3_pse>
    4f44:	98 d1       	rcall	.+816    	; 0x5276 <__fp_round>
    4f46:	0a d0       	rcall	.+20     	; 0x4f5c <atan>
    4f48:	5f 91       	pop	r21
    4f4a:	55 23       	and	r21, r21
    4f4c:	31 f0       	breq	.+12     	; 0x4f5a <atan2+0x54>
    4f4e:	2b ed       	ldi	r18, 0xDB	; 219
    4f50:	3f e0       	ldi	r19, 0x0F	; 15
    4f52:	49 e4       	ldi	r20, 0x49	; 73
    4f54:	50 fd       	sbrc	r21, 0
    4f56:	49 ec       	ldi	r20, 0xC9	; 201
    4f58:	63 cf       	rjmp	.-314    	; 0x4e20 <__addsf3>
    4f5a:	08 95       	ret

00004f5c <atan>:
    4f5c:	df 93       	push	r29
    4f5e:	dd 27       	eor	r29, r29
    4f60:	b9 2f       	mov	r27, r25
    4f62:	bf 77       	andi	r27, 0x7F	; 127
    4f64:	40 e8       	ldi	r20, 0x80	; 128
    4f66:	5f e3       	ldi	r21, 0x3F	; 63
    4f68:	16 16       	cp	r1, r22
    4f6a:	17 06       	cpc	r1, r23
    4f6c:	48 07       	cpc	r20, r24
    4f6e:	5b 07       	cpc	r21, r27
    4f70:	10 f4       	brcc	.+4      	; 0x4f76 <atan+0x1a>
    4f72:	d9 2f       	mov	r29, r25
    4f74:	cf d1       	rcall	.+926    	; 0x5314 <inverse>
    4f76:	9f 93       	push	r25
    4f78:	8f 93       	push	r24
    4f7a:	7f 93       	push	r23
    4f7c:	6f 93       	push	r22
    4f7e:	7c d2       	rcall	.+1272   	; 0x5478 <square>
    4f80:	e4 ef       	ldi	r30, 0xF4	; 244
    4f82:	f0 e0       	ldi	r31, 0x00	; 0
    4f84:	1d d1       	rcall	.+570    	; 0x51c0 <__fp_powser>
    4f86:	77 d1       	rcall	.+750    	; 0x5276 <__fp_round>
    4f88:	2f 91       	pop	r18
    4f8a:	3f 91       	pop	r19
    4f8c:	4f 91       	pop	r20
    4f8e:	5f 91       	pop	r21
    4f90:	d4 d1       	rcall	.+936    	; 0x533a <__mulsf3x>
    4f92:	dd 23       	and	r29, r29
    4f94:	49 f0       	breq	.+18     	; 0x4fa8 <atan+0x4c>
    4f96:	90 58       	subi	r25, 0x80	; 128
    4f98:	a2 ea       	ldi	r26, 0xA2	; 162
    4f9a:	2a ed       	ldi	r18, 0xDA	; 218
    4f9c:	3f e0       	ldi	r19, 0x0F	; 15
    4f9e:	49 ec       	ldi	r20, 0xC9	; 201
    4fa0:	5f e3       	ldi	r21, 0x3F	; 63
    4fa2:	d0 78       	andi	r29, 0x80	; 128
    4fa4:	5d 27       	eor	r21, r29
    4fa6:	4d df       	rcall	.-358    	; 0x4e42 <__addsf3x>
    4fa8:	df 91       	pop	r29
    4faa:	65 c1       	rjmp	.+714    	; 0x5276 <__fp_round>

00004fac <__cmpsf2>:
    4fac:	dc d0       	rcall	.+440    	; 0x5166 <__fp_cmp>
    4fae:	08 f4       	brcc	.+2      	; 0x4fb2 <__cmpsf2+0x6>
    4fb0:	81 e0       	ldi	r24, 0x01	; 1
    4fb2:	08 95       	ret

00004fb4 <cos>:
    4fb4:	39 d1       	rcall	.+626    	; 0x5228 <__fp_rempio2>
    4fb6:	e3 95       	inc	r30
    4fb8:	6f c1       	rjmp	.+734    	; 0x5298 <__fp_sinus>

00004fba <__divsf3>:
    4fba:	0c d0       	rcall	.+24     	; 0x4fd4 <__divsf3x>
    4fbc:	5c c1       	rjmp	.+696    	; 0x5276 <__fp_round>
    4fbe:	2c d1       	rcall	.+600    	; 0x5218 <__fp_pscB>
    4fc0:	40 f0       	brcs	.+16     	; 0x4fd2 <__divsf3+0x18>
    4fc2:	23 d1       	rcall	.+582    	; 0x520a <__fp_pscA>
    4fc4:	30 f0       	brcs	.+12     	; 0x4fd2 <__divsf3+0x18>
    4fc6:	21 f4       	brne	.+8      	; 0x4fd0 <__divsf3+0x16>
    4fc8:	5f 3f       	cpi	r21, 0xFF	; 255
    4fca:	19 f0       	breq	.+6      	; 0x4fd2 <__divsf3+0x18>
    4fcc:	f0 c0       	rjmp	.+480    	; 0x51ae <__fp_inf>
    4fce:	51 11       	cpse	r21, r1
    4fd0:	97 c1       	rjmp	.+814    	; 0x5300 <__fp_szero>
    4fd2:	f3 c0       	rjmp	.+486    	; 0x51ba <__fp_nan>

00004fd4 <__divsf3x>:
    4fd4:	72 d1       	rcall	.+740    	; 0x52ba <__fp_split3>
    4fd6:	98 f3       	brcs	.-26     	; 0x4fbe <__divsf3+0x4>

00004fd8 <__divsf3_pse>:
    4fd8:	99 23       	and	r25, r25
    4fda:	c9 f3       	breq	.-14     	; 0x4fce <__divsf3+0x14>
    4fdc:	55 23       	and	r21, r21
    4fde:	b1 f3       	breq	.-20     	; 0x4fcc <__divsf3+0x12>
    4fe0:	95 1b       	sub	r25, r21
    4fe2:	55 0b       	sbc	r21, r21
    4fe4:	bb 27       	eor	r27, r27
    4fe6:	aa 27       	eor	r26, r26
    4fe8:	62 17       	cp	r22, r18
    4fea:	73 07       	cpc	r23, r19
    4fec:	84 07       	cpc	r24, r20
    4fee:	38 f0       	brcs	.+14     	; 0x4ffe <__divsf3_pse+0x26>
    4ff0:	9f 5f       	subi	r25, 0xFF	; 255
    4ff2:	5f 4f       	sbci	r21, 0xFF	; 255
    4ff4:	22 0f       	add	r18, r18
    4ff6:	33 1f       	adc	r19, r19
    4ff8:	44 1f       	adc	r20, r20
    4ffa:	aa 1f       	adc	r26, r26
    4ffc:	a9 f3       	breq	.-22     	; 0x4fe8 <__divsf3_pse+0x10>
    4ffe:	33 d0       	rcall	.+102    	; 0x5066 <__divsf3_pse+0x8e>
    5000:	0e 2e       	mov	r0, r30
    5002:	3a f0       	brmi	.+14     	; 0x5012 <__divsf3_pse+0x3a>
    5004:	e0 e8       	ldi	r30, 0x80	; 128
    5006:	30 d0       	rcall	.+96     	; 0x5068 <__divsf3_pse+0x90>
    5008:	91 50       	subi	r25, 0x01	; 1
    500a:	50 40       	sbci	r21, 0x00	; 0
    500c:	e6 95       	lsr	r30
    500e:	00 1c       	adc	r0, r0
    5010:	ca f7       	brpl	.-14     	; 0x5004 <__divsf3_pse+0x2c>
    5012:	29 d0       	rcall	.+82     	; 0x5066 <__divsf3_pse+0x8e>
    5014:	fe 2f       	mov	r31, r30
    5016:	27 d0       	rcall	.+78     	; 0x5066 <__divsf3_pse+0x8e>
    5018:	66 0f       	add	r22, r22
    501a:	77 1f       	adc	r23, r23
    501c:	88 1f       	adc	r24, r24
    501e:	bb 1f       	adc	r27, r27
    5020:	26 17       	cp	r18, r22
    5022:	37 07       	cpc	r19, r23
    5024:	48 07       	cpc	r20, r24
    5026:	ab 07       	cpc	r26, r27
    5028:	b0 e8       	ldi	r27, 0x80	; 128
    502a:	09 f0       	breq	.+2      	; 0x502e <__divsf3_pse+0x56>
    502c:	bb 0b       	sbc	r27, r27
    502e:	80 2d       	mov	r24, r0
    5030:	bf 01       	movw	r22, r30
    5032:	ff 27       	eor	r31, r31
    5034:	93 58       	subi	r25, 0x83	; 131
    5036:	5f 4f       	sbci	r21, 0xFF	; 255
    5038:	2a f0       	brmi	.+10     	; 0x5044 <__divsf3_pse+0x6c>
    503a:	9e 3f       	cpi	r25, 0xFE	; 254
    503c:	51 05       	cpc	r21, r1
    503e:	68 f0       	brcs	.+26     	; 0x505a <__divsf3_pse+0x82>
    5040:	b6 c0       	rjmp	.+364    	; 0x51ae <__fp_inf>
    5042:	5e c1       	rjmp	.+700    	; 0x5300 <__fp_szero>
    5044:	5f 3f       	cpi	r21, 0xFF	; 255
    5046:	ec f3       	brlt	.-6      	; 0x5042 <__divsf3_pse+0x6a>
    5048:	98 3e       	cpi	r25, 0xE8	; 232
    504a:	dc f3       	brlt	.-10     	; 0x5042 <__divsf3_pse+0x6a>
    504c:	86 95       	lsr	r24
    504e:	77 95       	ror	r23
    5050:	67 95       	ror	r22
    5052:	b7 95       	ror	r27
    5054:	f7 95       	ror	r31
    5056:	9f 5f       	subi	r25, 0xFF	; 255
    5058:	c9 f7       	brne	.-14     	; 0x504c <__divsf3_pse+0x74>
    505a:	88 0f       	add	r24, r24
    505c:	91 1d       	adc	r25, r1
    505e:	96 95       	lsr	r25
    5060:	87 95       	ror	r24
    5062:	97 f9       	bld	r25, 7
    5064:	08 95       	ret
    5066:	e1 e0       	ldi	r30, 0x01	; 1
    5068:	66 0f       	add	r22, r22
    506a:	77 1f       	adc	r23, r23
    506c:	88 1f       	adc	r24, r24
    506e:	bb 1f       	adc	r27, r27
    5070:	62 17       	cp	r22, r18
    5072:	73 07       	cpc	r23, r19
    5074:	84 07       	cpc	r24, r20
    5076:	ba 07       	cpc	r27, r26
    5078:	20 f0       	brcs	.+8      	; 0x5082 <__divsf3_pse+0xaa>
    507a:	62 1b       	sub	r22, r18
    507c:	73 0b       	sbc	r23, r19
    507e:	84 0b       	sbc	r24, r20
    5080:	ba 0b       	sbc	r27, r26
    5082:	ee 1f       	adc	r30, r30
    5084:	88 f7       	brcc	.-30     	; 0x5068 <__divsf3_pse+0x90>
    5086:	e0 95       	com	r30
    5088:	08 95       	ret

0000508a <__fixsfsi>:
    508a:	04 d0       	rcall	.+8      	; 0x5094 <__fixunssfsi>
    508c:	68 94       	set
    508e:	b1 11       	cpse	r27, r1
    5090:	37 c1       	rjmp	.+622    	; 0x5300 <__fp_szero>
    5092:	08 95       	ret

00005094 <__fixunssfsi>:
    5094:	1a d1       	rcall	.+564    	; 0x52ca <__fp_splitA>
    5096:	88 f0       	brcs	.+34     	; 0x50ba <__fixunssfsi+0x26>
    5098:	9f 57       	subi	r25, 0x7F	; 127
    509a:	90 f0       	brcs	.+36     	; 0x50c0 <__fixunssfsi+0x2c>
    509c:	b9 2f       	mov	r27, r25
    509e:	99 27       	eor	r25, r25
    50a0:	b7 51       	subi	r27, 0x17	; 23
    50a2:	a0 f0       	brcs	.+40     	; 0x50cc <__fixunssfsi+0x38>
    50a4:	d1 f0       	breq	.+52     	; 0x50da <__fixunssfsi+0x46>
    50a6:	66 0f       	add	r22, r22
    50a8:	77 1f       	adc	r23, r23
    50aa:	88 1f       	adc	r24, r24
    50ac:	99 1f       	adc	r25, r25
    50ae:	1a f0       	brmi	.+6      	; 0x50b6 <__fixunssfsi+0x22>
    50b0:	ba 95       	dec	r27
    50b2:	c9 f7       	brne	.-14     	; 0x50a6 <__fixunssfsi+0x12>
    50b4:	12 c0       	rjmp	.+36     	; 0x50da <__fixunssfsi+0x46>
    50b6:	b1 30       	cpi	r27, 0x01	; 1
    50b8:	81 f0       	breq	.+32     	; 0x50da <__fixunssfsi+0x46>
    50ba:	21 d1       	rcall	.+578    	; 0x52fe <__fp_zero>
    50bc:	b1 e0       	ldi	r27, 0x01	; 1
    50be:	08 95       	ret
    50c0:	1e c1       	rjmp	.+572    	; 0x52fe <__fp_zero>
    50c2:	67 2f       	mov	r22, r23
    50c4:	78 2f       	mov	r23, r24
    50c6:	88 27       	eor	r24, r24
    50c8:	b8 5f       	subi	r27, 0xF8	; 248
    50ca:	39 f0       	breq	.+14     	; 0x50da <__fixunssfsi+0x46>
    50cc:	b9 3f       	cpi	r27, 0xF9	; 249
    50ce:	cc f3       	brlt	.-14     	; 0x50c2 <__fixunssfsi+0x2e>
    50d0:	86 95       	lsr	r24
    50d2:	77 95       	ror	r23
    50d4:	67 95       	ror	r22
    50d6:	b3 95       	inc	r27
    50d8:	d9 f7       	brne	.-10     	; 0x50d0 <__fixunssfsi+0x3c>
    50da:	3e f4       	brtc	.+14     	; 0x50ea <__fixunssfsi+0x56>
    50dc:	90 95       	com	r25
    50de:	80 95       	com	r24
    50e0:	70 95       	com	r23
    50e2:	61 95       	neg	r22
    50e4:	7f 4f       	sbci	r23, 0xFF	; 255
    50e6:	8f 4f       	sbci	r24, 0xFF	; 255
    50e8:	9f 4f       	sbci	r25, 0xFF	; 255
    50ea:	08 95       	ret

000050ec <__floatunsisf>:
    50ec:	e8 94       	clt
    50ee:	09 c0       	rjmp	.+18     	; 0x5102 <__floatsisf+0x12>

000050f0 <__floatsisf>:
    50f0:	97 fb       	bst	r25, 7
    50f2:	3e f4       	brtc	.+14     	; 0x5102 <__floatsisf+0x12>
    50f4:	90 95       	com	r25
    50f6:	80 95       	com	r24
    50f8:	70 95       	com	r23
    50fa:	61 95       	neg	r22
    50fc:	7f 4f       	sbci	r23, 0xFF	; 255
    50fe:	8f 4f       	sbci	r24, 0xFF	; 255
    5100:	9f 4f       	sbci	r25, 0xFF	; 255
    5102:	99 23       	and	r25, r25
    5104:	a9 f0       	breq	.+42     	; 0x5130 <__floatsisf+0x40>
    5106:	f9 2f       	mov	r31, r25
    5108:	96 e9       	ldi	r25, 0x96	; 150
    510a:	bb 27       	eor	r27, r27
    510c:	93 95       	inc	r25
    510e:	f6 95       	lsr	r31
    5110:	87 95       	ror	r24
    5112:	77 95       	ror	r23
    5114:	67 95       	ror	r22
    5116:	b7 95       	ror	r27
    5118:	f1 11       	cpse	r31, r1
    511a:	f8 cf       	rjmp	.-16     	; 0x510c <__floatsisf+0x1c>
    511c:	fa f4       	brpl	.+62     	; 0x515c <__floatsisf+0x6c>
    511e:	bb 0f       	add	r27, r27
    5120:	11 f4       	brne	.+4      	; 0x5126 <__floatsisf+0x36>
    5122:	60 ff       	sbrs	r22, 0
    5124:	1b c0       	rjmp	.+54     	; 0x515c <__floatsisf+0x6c>
    5126:	6f 5f       	subi	r22, 0xFF	; 255
    5128:	7f 4f       	sbci	r23, 0xFF	; 255
    512a:	8f 4f       	sbci	r24, 0xFF	; 255
    512c:	9f 4f       	sbci	r25, 0xFF	; 255
    512e:	16 c0       	rjmp	.+44     	; 0x515c <__floatsisf+0x6c>
    5130:	88 23       	and	r24, r24
    5132:	11 f0       	breq	.+4      	; 0x5138 <__floatsisf+0x48>
    5134:	96 e9       	ldi	r25, 0x96	; 150
    5136:	11 c0       	rjmp	.+34     	; 0x515a <__floatsisf+0x6a>
    5138:	77 23       	and	r23, r23
    513a:	21 f0       	breq	.+8      	; 0x5144 <__floatsisf+0x54>
    513c:	9e e8       	ldi	r25, 0x8E	; 142
    513e:	87 2f       	mov	r24, r23
    5140:	76 2f       	mov	r23, r22
    5142:	05 c0       	rjmp	.+10     	; 0x514e <__floatsisf+0x5e>
    5144:	66 23       	and	r22, r22
    5146:	71 f0       	breq	.+28     	; 0x5164 <__floatsisf+0x74>
    5148:	96 e8       	ldi	r25, 0x86	; 134
    514a:	86 2f       	mov	r24, r22
    514c:	70 e0       	ldi	r23, 0x00	; 0
    514e:	60 e0       	ldi	r22, 0x00	; 0
    5150:	2a f0       	brmi	.+10     	; 0x515c <__floatsisf+0x6c>
    5152:	9a 95       	dec	r25
    5154:	66 0f       	add	r22, r22
    5156:	77 1f       	adc	r23, r23
    5158:	88 1f       	adc	r24, r24
    515a:	da f7       	brpl	.-10     	; 0x5152 <__floatsisf+0x62>
    515c:	88 0f       	add	r24, r24
    515e:	96 95       	lsr	r25
    5160:	87 95       	ror	r24
    5162:	97 f9       	bld	r25, 7
    5164:	08 95       	ret

00005166 <__fp_cmp>:
    5166:	99 0f       	add	r25, r25
    5168:	00 08       	sbc	r0, r0
    516a:	55 0f       	add	r21, r21
    516c:	aa 0b       	sbc	r26, r26
    516e:	e0 e8       	ldi	r30, 0x80	; 128
    5170:	fe ef       	ldi	r31, 0xFE	; 254
    5172:	16 16       	cp	r1, r22
    5174:	17 06       	cpc	r1, r23
    5176:	e8 07       	cpc	r30, r24
    5178:	f9 07       	cpc	r31, r25
    517a:	c0 f0       	brcs	.+48     	; 0x51ac <__fp_cmp+0x46>
    517c:	12 16       	cp	r1, r18
    517e:	13 06       	cpc	r1, r19
    5180:	e4 07       	cpc	r30, r20
    5182:	f5 07       	cpc	r31, r21
    5184:	98 f0       	brcs	.+38     	; 0x51ac <__fp_cmp+0x46>
    5186:	62 1b       	sub	r22, r18
    5188:	73 0b       	sbc	r23, r19
    518a:	84 0b       	sbc	r24, r20
    518c:	95 0b       	sbc	r25, r21
    518e:	39 f4       	brne	.+14     	; 0x519e <__fp_cmp+0x38>
    5190:	0a 26       	eor	r0, r26
    5192:	61 f0       	breq	.+24     	; 0x51ac <__fp_cmp+0x46>
    5194:	23 2b       	or	r18, r19
    5196:	24 2b       	or	r18, r20
    5198:	25 2b       	or	r18, r21
    519a:	21 f4       	brne	.+8      	; 0x51a4 <__fp_cmp+0x3e>
    519c:	08 95       	ret
    519e:	0a 26       	eor	r0, r26
    51a0:	09 f4       	brne	.+2      	; 0x51a4 <__fp_cmp+0x3e>
    51a2:	a1 40       	sbci	r26, 0x01	; 1
    51a4:	a6 95       	lsr	r26
    51a6:	8f ef       	ldi	r24, 0xFF	; 255
    51a8:	81 1d       	adc	r24, r1
    51aa:	81 1d       	adc	r24, r1
    51ac:	08 95       	ret

000051ae <__fp_inf>:
    51ae:	97 f9       	bld	r25, 7
    51b0:	9f 67       	ori	r25, 0x7F	; 127
    51b2:	80 e8       	ldi	r24, 0x80	; 128
    51b4:	70 e0       	ldi	r23, 0x00	; 0
    51b6:	60 e0       	ldi	r22, 0x00	; 0
    51b8:	08 95       	ret

000051ba <__fp_nan>:
    51ba:	9f ef       	ldi	r25, 0xFF	; 255
    51bc:	80 ec       	ldi	r24, 0xC0	; 192
    51be:	08 95       	ret

000051c0 <__fp_powser>:
    51c0:	df 93       	push	r29
    51c2:	cf 93       	push	r28
    51c4:	1f 93       	push	r17
    51c6:	0f 93       	push	r16
    51c8:	ff 92       	push	r15
    51ca:	ef 92       	push	r14
    51cc:	df 92       	push	r13
    51ce:	7b 01       	movw	r14, r22
    51d0:	8c 01       	movw	r16, r24
    51d2:	68 94       	set
    51d4:	05 c0       	rjmp	.+10     	; 0x51e0 <__fp_powser+0x20>
    51d6:	da 2e       	mov	r13, r26
    51d8:	ef 01       	movw	r28, r30
    51da:	af d0       	rcall	.+350    	; 0x533a <__mulsf3x>
    51dc:	fe 01       	movw	r30, r28
    51de:	e8 94       	clt
    51e0:	a5 91       	lpm	r26, Z+
    51e2:	25 91       	lpm	r18, Z+
    51e4:	35 91       	lpm	r19, Z+
    51e6:	45 91       	lpm	r20, Z+
    51e8:	55 91       	lpm	r21, Z+
    51ea:	ae f3       	brts	.-22     	; 0x51d6 <__fp_powser+0x16>
    51ec:	ef 01       	movw	r28, r30
    51ee:	29 de       	rcall	.-942    	; 0x4e42 <__addsf3x>
    51f0:	fe 01       	movw	r30, r28
    51f2:	97 01       	movw	r18, r14
    51f4:	a8 01       	movw	r20, r16
    51f6:	da 94       	dec	r13
    51f8:	79 f7       	brne	.-34     	; 0x51d8 <__fp_powser+0x18>
    51fa:	df 90       	pop	r13
    51fc:	ef 90       	pop	r14
    51fe:	ff 90       	pop	r15
    5200:	0f 91       	pop	r16
    5202:	1f 91       	pop	r17
    5204:	cf 91       	pop	r28
    5206:	df 91       	pop	r29
    5208:	08 95       	ret

0000520a <__fp_pscA>:
    520a:	00 24       	eor	r0, r0
    520c:	0a 94       	dec	r0
    520e:	16 16       	cp	r1, r22
    5210:	17 06       	cpc	r1, r23
    5212:	18 06       	cpc	r1, r24
    5214:	09 06       	cpc	r0, r25
    5216:	08 95       	ret

00005218 <__fp_pscB>:
    5218:	00 24       	eor	r0, r0
    521a:	0a 94       	dec	r0
    521c:	12 16       	cp	r1, r18
    521e:	13 06       	cpc	r1, r19
    5220:	14 06       	cpc	r1, r20
    5222:	05 06       	cpc	r0, r21
    5224:	08 95       	ret
    5226:	c9 cf       	rjmp	.-110    	; 0x51ba <__fp_nan>

00005228 <__fp_rempio2>:
    5228:	50 d0       	rcall	.+160    	; 0x52ca <__fp_splitA>
    522a:	e8 f3       	brcs	.-6      	; 0x5226 <__fp_pscB+0xe>
    522c:	e8 94       	clt
    522e:	e0 e0       	ldi	r30, 0x00	; 0
    5230:	bb 27       	eor	r27, r27
    5232:	9f 57       	subi	r25, 0x7F	; 127
    5234:	f0 f0       	brcs	.+60     	; 0x5272 <__fp_rempio2+0x4a>
    5236:	2a ed       	ldi	r18, 0xDA	; 218
    5238:	3f e0       	ldi	r19, 0x0F	; 15
    523a:	49 ec       	ldi	r20, 0xC9	; 201
    523c:	06 c0       	rjmp	.+12     	; 0x524a <__fp_rempio2+0x22>
    523e:	ee 0f       	add	r30, r30
    5240:	bb 0f       	add	r27, r27
    5242:	66 1f       	adc	r22, r22
    5244:	77 1f       	adc	r23, r23
    5246:	88 1f       	adc	r24, r24
    5248:	28 f0       	brcs	.+10     	; 0x5254 <__fp_rempio2+0x2c>
    524a:	b2 3a       	cpi	r27, 0xA2	; 162
    524c:	62 07       	cpc	r22, r18
    524e:	73 07       	cpc	r23, r19
    5250:	84 07       	cpc	r24, r20
    5252:	28 f0       	brcs	.+10     	; 0x525e <__fp_rempio2+0x36>
    5254:	b2 5a       	subi	r27, 0xA2	; 162
    5256:	62 0b       	sbc	r22, r18
    5258:	73 0b       	sbc	r23, r19
    525a:	84 0b       	sbc	r24, r20
    525c:	e3 95       	inc	r30
    525e:	9a 95       	dec	r25
    5260:	72 f7       	brpl	.-36     	; 0x523e <__fp_rempio2+0x16>
    5262:	80 38       	cpi	r24, 0x80	; 128
    5264:	30 f4       	brcc	.+12     	; 0x5272 <__fp_rempio2+0x4a>
    5266:	9a 95       	dec	r25
    5268:	bb 0f       	add	r27, r27
    526a:	66 1f       	adc	r22, r22
    526c:	77 1f       	adc	r23, r23
    526e:	88 1f       	adc	r24, r24
    5270:	d2 f7       	brpl	.-12     	; 0x5266 <__fp_rempio2+0x3e>
    5272:	90 48       	sbci	r25, 0x80	; 128
    5274:	06 c1       	rjmp	.+524    	; 0x5482 <__fp_mpack_finite>

00005276 <__fp_round>:
    5276:	09 2e       	mov	r0, r25
    5278:	03 94       	inc	r0
    527a:	00 0c       	add	r0, r0
    527c:	11 f4       	brne	.+4      	; 0x5282 <__fp_round+0xc>
    527e:	88 23       	and	r24, r24
    5280:	52 f0       	brmi	.+20     	; 0x5296 <__fp_round+0x20>
    5282:	bb 0f       	add	r27, r27
    5284:	40 f4       	brcc	.+16     	; 0x5296 <__fp_round+0x20>
    5286:	bf 2b       	or	r27, r31
    5288:	11 f4       	brne	.+4      	; 0x528e <__fp_round+0x18>
    528a:	60 ff       	sbrs	r22, 0
    528c:	04 c0       	rjmp	.+8      	; 0x5296 <__fp_round+0x20>
    528e:	6f 5f       	subi	r22, 0xFF	; 255
    5290:	7f 4f       	sbci	r23, 0xFF	; 255
    5292:	8f 4f       	sbci	r24, 0xFF	; 255
    5294:	9f 4f       	sbci	r25, 0xFF	; 255
    5296:	08 95       	ret

00005298 <__fp_sinus>:
    5298:	ef 93       	push	r30
    529a:	e0 ff       	sbrs	r30, 0
    529c:	06 c0       	rjmp	.+12     	; 0x52aa <__fp_sinus+0x12>
    529e:	a2 ea       	ldi	r26, 0xA2	; 162
    52a0:	2a ed       	ldi	r18, 0xDA	; 218
    52a2:	3f e0       	ldi	r19, 0x0F	; 15
    52a4:	49 ec       	ldi	r20, 0xC9	; 201
    52a6:	5f eb       	ldi	r21, 0xBF	; 191
    52a8:	cc dd       	rcall	.-1128   	; 0x4e42 <__addsf3x>
    52aa:	e5 df       	rcall	.-54     	; 0x5276 <__fp_round>
    52ac:	0f 90       	pop	r0
    52ae:	03 94       	inc	r0
    52b0:	01 fc       	sbrc	r0, 1
    52b2:	90 58       	subi	r25, 0x80	; 128
    52b4:	e1 e2       	ldi	r30, 0x21	; 33
    52b6:	f1 e0       	ldi	r31, 0x01	; 1
    52b8:	f7 c0       	rjmp	.+494    	; 0x54a8 <__fp_powsodd>

000052ba <__fp_split3>:
    52ba:	57 fd       	sbrc	r21, 7
    52bc:	90 58       	subi	r25, 0x80	; 128
    52be:	44 0f       	add	r20, r20
    52c0:	55 1f       	adc	r21, r21
    52c2:	59 f0       	breq	.+22     	; 0x52da <__fp_splitA+0x10>
    52c4:	5f 3f       	cpi	r21, 0xFF	; 255
    52c6:	71 f0       	breq	.+28     	; 0x52e4 <__fp_splitA+0x1a>
    52c8:	47 95       	ror	r20

000052ca <__fp_splitA>:
    52ca:	88 0f       	add	r24, r24
    52cc:	97 fb       	bst	r25, 7
    52ce:	99 1f       	adc	r25, r25
    52d0:	61 f0       	breq	.+24     	; 0x52ea <__fp_splitA+0x20>
    52d2:	9f 3f       	cpi	r25, 0xFF	; 255
    52d4:	79 f0       	breq	.+30     	; 0x52f4 <__fp_splitA+0x2a>
    52d6:	87 95       	ror	r24
    52d8:	08 95       	ret
    52da:	12 16       	cp	r1, r18
    52dc:	13 06       	cpc	r1, r19
    52de:	14 06       	cpc	r1, r20
    52e0:	55 1f       	adc	r21, r21
    52e2:	f2 cf       	rjmp	.-28     	; 0x52c8 <__fp_split3+0xe>
    52e4:	46 95       	lsr	r20
    52e6:	f1 df       	rcall	.-30     	; 0x52ca <__fp_splitA>
    52e8:	08 c0       	rjmp	.+16     	; 0x52fa <__fp_splitA+0x30>
    52ea:	16 16       	cp	r1, r22
    52ec:	17 06       	cpc	r1, r23
    52ee:	18 06       	cpc	r1, r24
    52f0:	99 1f       	adc	r25, r25
    52f2:	f1 cf       	rjmp	.-30     	; 0x52d6 <__fp_splitA+0xc>
    52f4:	86 95       	lsr	r24
    52f6:	71 05       	cpc	r23, r1
    52f8:	61 05       	cpc	r22, r1
    52fa:	08 94       	sec
    52fc:	08 95       	ret

000052fe <__fp_zero>:
    52fe:	e8 94       	clt

00005300 <__fp_szero>:
    5300:	bb 27       	eor	r27, r27
    5302:	66 27       	eor	r22, r22
    5304:	77 27       	eor	r23, r23
    5306:	cb 01       	movw	r24, r22
    5308:	97 f9       	bld	r25, 7
    530a:	08 95       	ret

0000530c <__gesf2>:
    530c:	2c df       	rcall	.-424    	; 0x5166 <__fp_cmp>
    530e:	08 f4       	brcc	.+2      	; 0x5312 <__gesf2+0x6>
    5310:	8f ef       	ldi	r24, 0xFF	; 255
    5312:	08 95       	ret

00005314 <inverse>:
    5314:	9b 01       	movw	r18, r22
    5316:	ac 01       	movw	r20, r24
    5318:	60 e0       	ldi	r22, 0x00	; 0
    531a:	70 e0       	ldi	r23, 0x00	; 0
    531c:	80 e8       	ldi	r24, 0x80	; 128
    531e:	9f e3       	ldi	r25, 0x3F	; 63
    5320:	4c ce       	rjmp	.-872    	; 0x4fba <__divsf3>

00005322 <__mulsf3>:
    5322:	0b d0       	rcall	.+22     	; 0x533a <__mulsf3x>
    5324:	a8 cf       	rjmp	.-176    	; 0x5276 <__fp_round>
    5326:	71 df       	rcall	.-286    	; 0x520a <__fp_pscA>
    5328:	28 f0       	brcs	.+10     	; 0x5334 <__mulsf3+0x12>
    532a:	76 df       	rcall	.-276    	; 0x5218 <__fp_pscB>
    532c:	18 f0       	brcs	.+6      	; 0x5334 <__mulsf3+0x12>
    532e:	95 23       	and	r25, r21
    5330:	09 f0       	breq	.+2      	; 0x5334 <__mulsf3+0x12>
    5332:	3d cf       	rjmp	.-390    	; 0x51ae <__fp_inf>
    5334:	42 cf       	rjmp	.-380    	; 0x51ba <__fp_nan>
    5336:	11 24       	eor	r1, r1
    5338:	e3 cf       	rjmp	.-58     	; 0x5300 <__fp_szero>

0000533a <__mulsf3x>:
    533a:	bf df       	rcall	.-130    	; 0x52ba <__fp_split3>
    533c:	a0 f3       	brcs	.-24     	; 0x5326 <__mulsf3+0x4>

0000533e <__mulsf3_pse>:
    533e:	95 9f       	mul	r25, r21
    5340:	d1 f3       	breq	.-12     	; 0x5336 <__mulsf3+0x14>
    5342:	95 0f       	add	r25, r21
    5344:	50 e0       	ldi	r21, 0x00	; 0
    5346:	55 1f       	adc	r21, r21
    5348:	62 9f       	mul	r22, r18
    534a:	f0 01       	movw	r30, r0
    534c:	72 9f       	mul	r23, r18
    534e:	bb 27       	eor	r27, r27
    5350:	f0 0d       	add	r31, r0
    5352:	b1 1d       	adc	r27, r1
    5354:	63 9f       	mul	r22, r19
    5356:	aa 27       	eor	r26, r26
    5358:	f0 0d       	add	r31, r0
    535a:	b1 1d       	adc	r27, r1
    535c:	aa 1f       	adc	r26, r26
    535e:	64 9f       	mul	r22, r20
    5360:	66 27       	eor	r22, r22
    5362:	b0 0d       	add	r27, r0
    5364:	a1 1d       	adc	r26, r1
    5366:	66 1f       	adc	r22, r22
    5368:	82 9f       	mul	r24, r18
    536a:	22 27       	eor	r18, r18
    536c:	b0 0d       	add	r27, r0
    536e:	a1 1d       	adc	r26, r1
    5370:	62 1f       	adc	r22, r18
    5372:	73 9f       	mul	r23, r19
    5374:	b0 0d       	add	r27, r0
    5376:	a1 1d       	adc	r26, r1
    5378:	62 1f       	adc	r22, r18
    537a:	83 9f       	mul	r24, r19
    537c:	a0 0d       	add	r26, r0
    537e:	61 1d       	adc	r22, r1
    5380:	22 1f       	adc	r18, r18
    5382:	74 9f       	mul	r23, r20
    5384:	33 27       	eor	r19, r19
    5386:	a0 0d       	add	r26, r0
    5388:	61 1d       	adc	r22, r1
    538a:	23 1f       	adc	r18, r19
    538c:	84 9f       	mul	r24, r20
    538e:	60 0d       	add	r22, r0
    5390:	21 1d       	adc	r18, r1
    5392:	82 2f       	mov	r24, r18
    5394:	76 2f       	mov	r23, r22
    5396:	6a 2f       	mov	r22, r26
    5398:	11 24       	eor	r1, r1
    539a:	9f 57       	subi	r25, 0x7F	; 127
    539c:	50 40       	sbci	r21, 0x00	; 0
    539e:	8a f0       	brmi	.+34     	; 0x53c2 <__mulsf3_pse+0x84>
    53a0:	e1 f0       	breq	.+56     	; 0x53da <__mulsf3_pse+0x9c>
    53a2:	88 23       	and	r24, r24
    53a4:	4a f0       	brmi	.+18     	; 0x53b8 <__mulsf3_pse+0x7a>
    53a6:	ee 0f       	add	r30, r30
    53a8:	ff 1f       	adc	r31, r31
    53aa:	bb 1f       	adc	r27, r27
    53ac:	66 1f       	adc	r22, r22
    53ae:	77 1f       	adc	r23, r23
    53b0:	88 1f       	adc	r24, r24
    53b2:	91 50       	subi	r25, 0x01	; 1
    53b4:	50 40       	sbci	r21, 0x00	; 0
    53b6:	a9 f7       	brne	.-22     	; 0x53a2 <__mulsf3_pse+0x64>
    53b8:	9e 3f       	cpi	r25, 0xFE	; 254
    53ba:	51 05       	cpc	r21, r1
    53bc:	70 f0       	brcs	.+28     	; 0x53da <__mulsf3_pse+0x9c>
    53be:	f7 ce       	rjmp	.-530    	; 0x51ae <__fp_inf>
    53c0:	9f cf       	rjmp	.-194    	; 0x5300 <__fp_szero>
    53c2:	5f 3f       	cpi	r21, 0xFF	; 255
    53c4:	ec f3       	brlt	.-6      	; 0x53c0 <__mulsf3_pse+0x82>
    53c6:	98 3e       	cpi	r25, 0xE8	; 232
    53c8:	dc f3       	brlt	.-10     	; 0x53c0 <__mulsf3_pse+0x82>
    53ca:	86 95       	lsr	r24
    53cc:	77 95       	ror	r23
    53ce:	67 95       	ror	r22
    53d0:	b7 95       	ror	r27
    53d2:	f7 95       	ror	r31
    53d4:	e7 95       	ror	r30
    53d6:	9f 5f       	subi	r25, 0xFF	; 255
    53d8:	c1 f7       	brne	.-16     	; 0x53ca <__mulsf3_pse+0x8c>
    53da:	fe 2b       	or	r31, r30
    53dc:	88 0f       	add	r24, r24
    53de:	91 1d       	adc	r25, r1
    53e0:	96 95       	lsr	r25
    53e2:	87 95       	ror	r24
    53e4:	97 f9       	bld	r25, 7
    53e6:	08 95       	ret

000053e8 <sin>:
    53e8:	9f 93       	push	r25
    53ea:	1e df       	rcall	.-452    	; 0x5228 <__fp_rempio2>
    53ec:	0f 90       	pop	r0
    53ee:	07 fc       	sbrc	r0, 7
    53f0:	ee 5f       	subi	r30, 0xFE	; 254
    53f2:	52 cf       	rjmp	.-348    	; 0x5298 <__fp_sinus>
    53f4:	11 f4       	brne	.+4      	; 0x53fa <sin+0x12>
    53f6:	0e f4       	brtc	.+2      	; 0x53fa <sin+0x12>
    53f8:	e0 ce       	rjmp	.-576    	; 0x51ba <__fp_nan>
    53fa:	41 c0       	rjmp	.+130    	; 0x547e <__fp_mpack>

000053fc <sqrt>:
    53fc:	66 df       	rcall	.-308    	; 0x52ca <__fp_splitA>
    53fe:	d0 f3       	brcs	.-12     	; 0x53f4 <sin+0xc>
    5400:	99 23       	and	r25, r25
    5402:	d9 f3       	breq	.-10     	; 0x53fa <sin+0x12>
    5404:	ce f3       	brts	.-14     	; 0x53f8 <sin+0x10>
    5406:	9f 57       	subi	r25, 0x7F	; 127
    5408:	55 0b       	sbc	r21, r21
    540a:	87 ff       	sbrs	r24, 7
    540c:	46 d0       	rcall	.+140    	; 0x549a <__fp_norm2>
    540e:	00 24       	eor	r0, r0
    5410:	a0 e6       	ldi	r26, 0x60	; 96
    5412:	40 ea       	ldi	r20, 0xA0	; 160
    5414:	90 01       	movw	r18, r0
    5416:	80 58       	subi	r24, 0x80	; 128
    5418:	56 95       	lsr	r21
    541a:	97 95       	ror	r25
    541c:	28 f4       	brcc	.+10     	; 0x5428 <sqrt+0x2c>
    541e:	80 5c       	subi	r24, 0xC0	; 192
    5420:	66 0f       	add	r22, r22
    5422:	77 1f       	adc	r23, r23
    5424:	88 1f       	adc	r24, r24
    5426:	20 f0       	brcs	.+8      	; 0x5430 <sqrt+0x34>
    5428:	26 17       	cp	r18, r22
    542a:	37 07       	cpc	r19, r23
    542c:	48 07       	cpc	r20, r24
    542e:	30 f4       	brcc	.+12     	; 0x543c <sqrt+0x40>
    5430:	62 1b       	sub	r22, r18
    5432:	73 0b       	sbc	r23, r19
    5434:	84 0b       	sbc	r24, r20
    5436:	20 29       	or	r18, r0
    5438:	31 29       	or	r19, r1
    543a:	4a 2b       	or	r20, r26
    543c:	a6 95       	lsr	r26
    543e:	17 94       	ror	r1
    5440:	07 94       	ror	r0
    5442:	20 25       	eor	r18, r0
    5444:	31 25       	eor	r19, r1
    5446:	4a 27       	eor	r20, r26
    5448:	58 f7       	brcc	.-42     	; 0x5420 <sqrt+0x24>
    544a:	66 0f       	add	r22, r22
    544c:	77 1f       	adc	r23, r23
    544e:	88 1f       	adc	r24, r24
    5450:	20 f0       	brcs	.+8      	; 0x545a <sqrt+0x5e>
    5452:	26 17       	cp	r18, r22
    5454:	37 07       	cpc	r19, r23
    5456:	48 07       	cpc	r20, r24
    5458:	30 f4       	brcc	.+12     	; 0x5466 <sqrt+0x6a>
    545a:	62 0b       	sbc	r22, r18
    545c:	73 0b       	sbc	r23, r19
    545e:	84 0b       	sbc	r24, r20
    5460:	20 0d       	add	r18, r0
    5462:	31 1d       	adc	r19, r1
    5464:	41 1d       	adc	r20, r1
    5466:	a0 95       	com	r26
    5468:	81 f7       	brne	.-32     	; 0x544a <sqrt+0x4e>
    546a:	b9 01       	movw	r22, r18
    546c:	84 2f       	mov	r24, r20
    546e:	91 58       	subi	r25, 0x81	; 129
    5470:	88 0f       	add	r24, r24
    5472:	96 95       	lsr	r25
    5474:	87 95       	ror	r24
    5476:	08 95       	ret

00005478 <square>:
    5478:	9b 01       	movw	r18, r22
    547a:	ac 01       	movw	r20, r24
    547c:	52 cf       	rjmp	.-348    	; 0x5322 <__mulsf3>

0000547e <__fp_mpack>:
    547e:	9f 3f       	cpi	r25, 0xFF	; 255
    5480:	31 f0       	breq	.+12     	; 0x548e <__fp_mpack_finite+0xc>

00005482 <__fp_mpack_finite>:
    5482:	91 50       	subi	r25, 0x01	; 1
    5484:	20 f4       	brcc	.+8      	; 0x548e <__fp_mpack_finite+0xc>
    5486:	87 95       	ror	r24
    5488:	77 95       	ror	r23
    548a:	67 95       	ror	r22
    548c:	b7 95       	ror	r27
    548e:	88 0f       	add	r24, r24
    5490:	91 1d       	adc	r25, r1
    5492:	96 95       	lsr	r25
    5494:	87 95       	ror	r24
    5496:	97 f9       	bld	r25, 7
    5498:	08 95       	ret

0000549a <__fp_norm2>:
    549a:	91 50       	subi	r25, 0x01	; 1
    549c:	50 40       	sbci	r21, 0x00	; 0
    549e:	66 0f       	add	r22, r22
    54a0:	77 1f       	adc	r23, r23
    54a2:	88 1f       	adc	r24, r24
    54a4:	d2 f7       	brpl	.-12     	; 0x549a <__fp_norm2>
    54a6:	08 95       	ret

000054a8 <__fp_powsodd>:
    54a8:	9f 93       	push	r25
    54aa:	8f 93       	push	r24
    54ac:	7f 93       	push	r23
    54ae:	6f 93       	push	r22
    54b0:	ff 93       	push	r31
    54b2:	ef 93       	push	r30
    54b4:	9b 01       	movw	r18, r22
    54b6:	ac 01       	movw	r20, r24
    54b8:	34 df       	rcall	.-408    	; 0x5322 <__mulsf3>
    54ba:	ef 91       	pop	r30
    54bc:	ff 91       	pop	r31
    54be:	80 de       	rcall	.-768    	; 0x51c0 <__fp_powser>
    54c0:	2f 91       	pop	r18
    54c2:	3f 91       	pop	r19
    54c4:	4f 91       	pop	r20
    54c6:	5f 91       	pop	r21
    54c8:	2c cf       	rjmp	.-424    	; 0x5322 <__mulsf3>

000054ca <vfprintf>:
    54ca:	2f 92       	push	r2
    54cc:	3f 92       	push	r3
    54ce:	4f 92       	push	r4
    54d0:	5f 92       	push	r5
    54d2:	6f 92       	push	r6
    54d4:	7f 92       	push	r7
    54d6:	8f 92       	push	r8
    54d8:	9f 92       	push	r9
    54da:	af 92       	push	r10
    54dc:	bf 92       	push	r11
    54de:	cf 92       	push	r12
    54e0:	df 92       	push	r13
    54e2:	ef 92       	push	r14
    54e4:	ff 92       	push	r15
    54e6:	0f 93       	push	r16
    54e8:	1f 93       	push	r17
    54ea:	cf 93       	push	r28
    54ec:	df 93       	push	r29
    54ee:	cd b7       	in	r28, 0x3d	; 61
    54f0:	de b7       	in	r29, 0x3e	; 62
    54f2:	63 97       	sbiw	r28, 0x13	; 19
    54f4:	0f b6       	in	r0, 0x3f	; 63
    54f6:	f8 94       	cli
    54f8:	de bf       	out	0x3e, r29	; 62
    54fa:	0f be       	out	0x3f, r0	; 63
    54fc:	cd bf       	out	0x3d, r28	; 61
    54fe:	6c 01       	movw	r12, r24
    5500:	4b 01       	movw	r8, r22
    5502:	2a 01       	movw	r4, r20
    5504:	fc 01       	movw	r30, r24
    5506:	17 82       	std	Z+7, r1	; 0x07
    5508:	16 82       	std	Z+6, r1	; 0x06
    550a:	83 81       	ldd	r24, Z+3	; 0x03
    550c:	81 ff       	sbrs	r24, 1
    550e:	29 c3       	rjmp	.+1618   	; 0x5b62 <vfprintf+0x698>
    5510:	ae 01       	movw	r20, r28
    5512:	4f 5f       	subi	r20, 0xFF	; 255
    5514:	5f 4f       	sbci	r21, 0xFF	; 255
    5516:	3a 01       	movw	r6, r20
    5518:	f6 01       	movw	r30, r12
    551a:	93 81       	ldd	r25, Z+3	; 0x03
    551c:	f4 01       	movw	r30, r8
    551e:	93 fd       	sbrc	r25, 3
    5520:	85 91       	lpm	r24, Z+
    5522:	93 ff       	sbrs	r25, 3
    5524:	81 91       	ld	r24, Z+
    5526:	4f 01       	movw	r8, r30
    5528:	88 23       	and	r24, r24
    552a:	09 f4       	brne	.+2      	; 0x552e <vfprintf+0x64>
    552c:	16 c3       	rjmp	.+1580   	; 0x5b5a <vfprintf+0x690>
    552e:	85 32       	cpi	r24, 0x25	; 37
    5530:	39 f4       	brne	.+14     	; 0x5540 <vfprintf+0x76>
    5532:	93 fd       	sbrc	r25, 3
    5534:	85 91       	lpm	r24, Z+
    5536:	93 ff       	sbrs	r25, 3
    5538:	81 91       	ld	r24, Z+
    553a:	4f 01       	movw	r8, r30
    553c:	85 32       	cpi	r24, 0x25	; 37
    553e:	31 f4       	brne	.+12     	; 0x554c <vfprintf+0x82>
    5540:	b6 01       	movw	r22, r12
    5542:	90 e0       	ldi	r25, 0x00	; 0
    5544:	0b d5       	rcall	.+2582   	; 0x5f5c <fputc>
    5546:	52 01       	movw	r10, r4
    5548:	25 01       	movw	r4, r10
    554a:	e6 cf       	rjmp	.-52     	; 0x5518 <vfprintf+0x4e>
    554c:	10 e0       	ldi	r17, 0x00	; 0
    554e:	f1 2c       	mov	r15, r1
    5550:	20 e0       	ldi	r18, 0x00	; 0
    5552:	20 32       	cpi	r18, 0x20	; 32
    5554:	a0 f4       	brcc	.+40     	; 0x557e <vfprintf+0xb4>
    5556:	8b 32       	cpi	r24, 0x2B	; 43
    5558:	69 f0       	breq	.+26     	; 0x5574 <vfprintf+0xaa>
    555a:	30 f4       	brcc	.+12     	; 0x5568 <vfprintf+0x9e>
    555c:	80 32       	cpi	r24, 0x20	; 32
    555e:	59 f0       	breq	.+22     	; 0x5576 <vfprintf+0xac>
    5560:	83 32       	cpi	r24, 0x23	; 35
    5562:	69 f4       	brne	.+26     	; 0x557e <vfprintf+0xb4>
    5564:	20 61       	ori	r18, 0x10	; 16
    5566:	2c c0       	rjmp	.+88     	; 0x55c0 <vfprintf+0xf6>
    5568:	8d 32       	cpi	r24, 0x2D	; 45
    556a:	39 f0       	breq	.+14     	; 0x557a <vfprintf+0xb0>
    556c:	80 33       	cpi	r24, 0x30	; 48
    556e:	39 f4       	brne	.+14     	; 0x557e <vfprintf+0xb4>
    5570:	21 60       	ori	r18, 0x01	; 1
    5572:	26 c0       	rjmp	.+76     	; 0x55c0 <vfprintf+0xf6>
    5574:	22 60       	ori	r18, 0x02	; 2
    5576:	24 60       	ori	r18, 0x04	; 4
    5578:	23 c0       	rjmp	.+70     	; 0x55c0 <vfprintf+0xf6>
    557a:	28 60       	ori	r18, 0x08	; 8
    557c:	21 c0       	rjmp	.+66     	; 0x55c0 <vfprintf+0xf6>
    557e:	27 fd       	sbrc	r18, 7
    5580:	27 c0       	rjmp	.+78     	; 0x55d0 <vfprintf+0x106>
    5582:	30 ed       	ldi	r19, 0xD0	; 208
    5584:	38 0f       	add	r19, r24
    5586:	3a 30       	cpi	r19, 0x0A	; 10
    5588:	78 f4       	brcc	.+30     	; 0x55a8 <vfprintf+0xde>
    558a:	26 ff       	sbrs	r18, 6
    558c:	06 c0       	rjmp	.+12     	; 0x559a <vfprintf+0xd0>
    558e:	fa e0       	ldi	r31, 0x0A	; 10
    5590:	1f 9f       	mul	r17, r31
    5592:	30 0d       	add	r19, r0
    5594:	11 24       	eor	r1, r1
    5596:	13 2f       	mov	r17, r19
    5598:	13 c0       	rjmp	.+38     	; 0x55c0 <vfprintf+0xf6>
    559a:	4a e0       	ldi	r20, 0x0A	; 10
    559c:	f4 9e       	mul	r15, r20
    559e:	30 0d       	add	r19, r0
    55a0:	11 24       	eor	r1, r1
    55a2:	f3 2e       	mov	r15, r19
    55a4:	20 62       	ori	r18, 0x20	; 32
    55a6:	0c c0       	rjmp	.+24     	; 0x55c0 <vfprintf+0xf6>
    55a8:	8e 32       	cpi	r24, 0x2E	; 46
    55aa:	21 f4       	brne	.+8      	; 0x55b4 <vfprintf+0xea>
    55ac:	26 fd       	sbrc	r18, 6
    55ae:	d5 c2       	rjmp	.+1450   	; 0x5b5a <vfprintf+0x690>
    55b0:	20 64       	ori	r18, 0x40	; 64
    55b2:	06 c0       	rjmp	.+12     	; 0x55c0 <vfprintf+0xf6>
    55b4:	8c 36       	cpi	r24, 0x6C	; 108
    55b6:	11 f4       	brne	.+4      	; 0x55bc <vfprintf+0xf2>
    55b8:	20 68       	ori	r18, 0x80	; 128
    55ba:	02 c0       	rjmp	.+4      	; 0x55c0 <vfprintf+0xf6>
    55bc:	88 36       	cpi	r24, 0x68	; 104
    55be:	41 f4       	brne	.+16     	; 0x55d0 <vfprintf+0x106>
    55c0:	f4 01       	movw	r30, r8
    55c2:	93 fd       	sbrc	r25, 3
    55c4:	85 91       	lpm	r24, Z+
    55c6:	93 ff       	sbrs	r25, 3
    55c8:	81 91       	ld	r24, Z+
    55ca:	4f 01       	movw	r8, r30
    55cc:	81 11       	cpse	r24, r1
    55ce:	c1 cf       	rjmp	.-126    	; 0x5552 <vfprintf+0x88>
    55d0:	9b eb       	ldi	r25, 0xBB	; 187
    55d2:	98 0f       	add	r25, r24
    55d4:	93 30       	cpi	r25, 0x03	; 3
    55d6:	18 f4       	brcc	.+6      	; 0x55de <vfprintf+0x114>
    55d8:	20 61       	ori	r18, 0x10	; 16
    55da:	80 5e       	subi	r24, 0xE0	; 224
    55dc:	06 c0       	rjmp	.+12     	; 0x55ea <vfprintf+0x120>
    55de:	9b e9       	ldi	r25, 0x9B	; 155
    55e0:	98 0f       	add	r25, r24
    55e2:	93 30       	cpi	r25, 0x03	; 3
    55e4:	08 f0       	brcs	.+2      	; 0x55e8 <vfprintf+0x11e>
    55e6:	64 c1       	rjmp	.+712    	; 0x58b0 <vfprintf+0x3e6>
    55e8:	2f 7e       	andi	r18, 0xEF	; 239
    55ea:	26 ff       	sbrs	r18, 6
    55ec:	16 e0       	ldi	r17, 0x06	; 6
    55ee:	2f 73       	andi	r18, 0x3F	; 63
    55f0:	32 2e       	mov	r3, r18
    55f2:	85 36       	cpi	r24, 0x65	; 101
    55f4:	19 f4       	brne	.+6      	; 0x55fc <vfprintf+0x132>
    55f6:	20 64       	ori	r18, 0x40	; 64
    55f8:	32 2e       	mov	r3, r18
    55fa:	08 c0       	rjmp	.+16     	; 0x560c <vfprintf+0x142>
    55fc:	86 36       	cpi	r24, 0x66	; 102
    55fe:	21 f4       	brne	.+8      	; 0x5608 <vfprintf+0x13e>
    5600:	f2 2f       	mov	r31, r18
    5602:	f0 68       	ori	r31, 0x80	; 128
    5604:	3f 2e       	mov	r3, r31
    5606:	02 c0       	rjmp	.+4      	; 0x560c <vfprintf+0x142>
    5608:	11 11       	cpse	r17, r1
    560a:	11 50       	subi	r17, 0x01	; 1
    560c:	37 fe       	sbrs	r3, 7
    560e:	07 c0       	rjmp	.+14     	; 0x561e <vfprintf+0x154>
    5610:	1c 33       	cpi	r17, 0x3C	; 60
    5612:	50 f4       	brcc	.+20     	; 0x5628 <vfprintf+0x15e>
    5614:	ee 24       	eor	r14, r14
    5616:	e3 94       	inc	r14
    5618:	e1 0e       	add	r14, r17
    561a:	27 e0       	ldi	r18, 0x07	; 7
    561c:	0b c0       	rjmp	.+22     	; 0x5634 <vfprintf+0x16a>
    561e:	18 30       	cpi	r17, 0x08	; 8
    5620:	38 f0       	brcs	.+14     	; 0x5630 <vfprintf+0x166>
    5622:	27 e0       	ldi	r18, 0x07	; 7
    5624:	17 e0       	ldi	r17, 0x07	; 7
    5626:	05 c0       	rjmp	.+10     	; 0x5632 <vfprintf+0x168>
    5628:	27 e0       	ldi	r18, 0x07	; 7
    562a:	4c e3       	ldi	r20, 0x3C	; 60
    562c:	e4 2e       	mov	r14, r20
    562e:	02 c0       	rjmp	.+4      	; 0x5634 <vfprintf+0x16a>
    5630:	21 2f       	mov	r18, r17
    5632:	e1 2c       	mov	r14, r1
    5634:	52 01       	movw	r10, r4
    5636:	44 e0       	ldi	r20, 0x04	; 4
    5638:	a4 0e       	add	r10, r20
    563a:	b1 1c       	adc	r11, r1
    563c:	f2 01       	movw	r30, r4
    563e:	60 81       	ld	r22, Z
    5640:	71 81       	ldd	r23, Z+1	; 0x01
    5642:	82 81       	ldd	r24, Z+2	; 0x02
    5644:	93 81       	ldd	r25, Z+3	; 0x03
    5646:	0e 2d       	mov	r16, r14
    5648:	a3 01       	movw	r20, r6
    564a:	22 d3       	rcall	.+1604   	; 0x5c90 <__ftoa_engine>
    564c:	2c 01       	movw	r4, r24
    564e:	09 81       	ldd	r16, Y+1	; 0x01
    5650:	00 ff       	sbrs	r16, 0
    5652:	02 c0       	rjmp	.+4      	; 0x5658 <vfprintf+0x18e>
    5654:	03 ff       	sbrs	r16, 3
    5656:	07 c0       	rjmp	.+14     	; 0x5666 <vfprintf+0x19c>
    5658:	31 fc       	sbrc	r3, 1
    565a:	08 c0       	rjmp	.+16     	; 0x566c <vfprintf+0x1a2>
    565c:	32 fe       	sbrs	r3, 2
    565e:	09 c0       	rjmp	.+18     	; 0x5672 <vfprintf+0x1a8>
    5660:	30 e2       	ldi	r19, 0x20	; 32
    5662:	23 2e       	mov	r2, r19
    5664:	07 c0       	rjmp	.+14     	; 0x5674 <vfprintf+0x1aa>
    5666:	2d e2       	ldi	r18, 0x2D	; 45
    5668:	22 2e       	mov	r2, r18
    566a:	04 c0       	rjmp	.+8      	; 0x5674 <vfprintf+0x1aa>
    566c:	9b e2       	ldi	r25, 0x2B	; 43
    566e:	29 2e       	mov	r2, r25
    5670:	01 c0       	rjmp	.+2      	; 0x5674 <vfprintf+0x1aa>
    5672:	21 2c       	mov	r2, r1
    5674:	80 2f       	mov	r24, r16
    5676:	8c 70       	andi	r24, 0x0C	; 12
    5678:	19 f0       	breq	.+6      	; 0x5680 <vfprintf+0x1b6>
    567a:	21 10       	cpse	r2, r1
    567c:	51 c2       	rjmp	.+1186   	; 0x5b20 <vfprintf+0x656>
    567e:	8d c2       	rjmp	.+1306   	; 0x5b9a <vfprintf+0x6d0>
    5680:	37 fe       	sbrs	r3, 7
    5682:	0f c0       	rjmp	.+30     	; 0x56a2 <vfprintf+0x1d8>
    5684:	e4 0c       	add	r14, r4
    5686:	04 ff       	sbrs	r16, 4
    5688:	04 c0       	rjmp	.+8      	; 0x5692 <vfprintf+0x1c8>
    568a:	8a 81       	ldd	r24, Y+2	; 0x02
    568c:	81 33       	cpi	r24, 0x31	; 49
    568e:	09 f4       	brne	.+2      	; 0x5692 <vfprintf+0x1c8>
    5690:	ea 94       	dec	r14
    5692:	1e 14       	cp	r1, r14
    5694:	74 f5       	brge	.+92     	; 0x56f2 <vfprintf+0x228>
    5696:	f8 e0       	ldi	r31, 0x08	; 8
    5698:	fe 15       	cp	r31, r14
    569a:	78 f5       	brcc	.+94     	; 0x56fa <vfprintf+0x230>
    569c:	88 e0       	ldi	r24, 0x08	; 8
    569e:	e8 2e       	mov	r14, r24
    56a0:	2c c0       	rjmp	.+88     	; 0x56fa <vfprintf+0x230>
    56a2:	36 fc       	sbrc	r3, 6
    56a4:	2a c0       	rjmp	.+84     	; 0x56fa <vfprintf+0x230>
    56a6:	81 2f       	mov	r24, r17
    56a8:	90 e0       	ldi	r25, 0x00	; 0
    56aa:	84 15       	cp	r24, r4
    56ac:	95 05       	cpc	r25, r5
    56ae:	9c f0       	brlt	.+38     	; 0x56d6 <vfprintf+0x20c>
    56b0:	2c ef       	ldi	r18, 0xFC	; 252
    56b2:	42 16       	cp	r4, r18
    56b4:	2f ef       	ldi	r18, 0xFF	; 255
    56b6:	52 06       	cpc	r5, r18
    56b8:	74 f0       	brlt	.+28     	; 0x56d6 <vfprintf+0x20c>
    56ba:	43 2d       	mov	r20, r3
    56bc:	40 68       	ori	r20, 0x80	; 128
    56be:	34 2e       	mov	r3, r20
    56c0:	0a c0       	rjmp	.+20     	; 0x56d6 <vfprintf+0x20c>
    56c2:	e2 e0       	ldi	r30, 0x02	; 2
    56c4:	f0 e0       	ldi	r31, 0x00	; 0
    56c6:	ec 0f       	add	r30, r28
    56c8:	fd 1f       	adc	r31, r29
    56ca:	e1 0f       	add	r30, r17
    56cc:	f1 1d       	adc	r31, r1
    56ce:	80 81       	ld	r24, Z
    56d0:	80 33       	cpi	r24, 0x30	; 48
    56d2:	19 f4       	brne	.+6      	; 0x56da <vfprintf+0x210>
    56d4:	11 50       	subi	r17, 0x01	; 1
    56d6:	11 11       	cpse	r17, r1
    56d8:	f4 cf       	rjmp	.-24     	; 0x56c2 <vfprintf+0x1f8>
    56da:	37 fe       	sbrs	r3, 7
    56dc:	0e c0       	rjmp	.+28     	; 0x56fa <vfprintf+0x230>
    56de:	ee 24       	eor	r14, r14
    56e0:	e3 94       	inc	r14
    56e2:	e1 0e       	add	r14, r17
    56e4:	81 2f       	mov	r24, r17
    56e6:	90 e0       	ldi	r25, 0x00	; 0
    56e8:	48 16       	cp	r4, r24
    56ea:	59 06       	cpc	r5, r25
    56ec:	2c f4       	brge	.+10     	; 0x56f8 <vfprintf+0x22e>
    56ee:	14 19       	sub	r17, r4
    56f0:	04 c0       	rjmp	.+8      	; 0x56fa <vfprintf+0x230>
    56f2:	ee 24       	eor	r14, r14
    56f4:	e3 94       	inc	r14
    56f6:	01 c0       	rjmp	.+2      	; 0x56fa <vfprintf+0x230>
    56f8:	10 e0       	ldi	r17, 0x00	; 0
    56fa:	37 fe       	sbrs	r3, 7
    56fc:	06 c0       	rjmp	.+12     	; 0x570a <vfprintf+0x240>
    56fe:	14 14       	cp	r1, r4
    5700:	15 04       	cpc	r1, r5
    5702:	34 f4       	brge	.+12     	; 0x5710 <vfprintf+0x246>
    5704:	c2 01       	movw	r24, r4
    5706:	01 96       	adiw	r24, 0x01	; 1
    5708:	05 c0       	rjmp	.+10     	; 0x5714 <vfprintf+0x24a>
    570a:	85 e0       	ldi	r24, 0x05	; 5
    570c:	90 e0       	ldi	r25, 0x00	; 0
    570e:	02 c0       	rjmp	.+4      	; 0x5714 <vfprintf+0x24a>
    5710:	81 e0       	ldi	r24, 0x01	; 1
    5712:	90 e0       	ldi	r25, 0x00	; 0
    5714:	21 10       	cpse	r2, r1
    5716:	01 96       	adiw	r24, 0x01	; 1
    5718:	11 23       	and	r17, r17
    571a:	31 f0       	breq	.+12     	; 0x5728 <vfprintf+0x25e>
    571c:	21 2f       	mov	r18, r17
    571e:	30 e0       	ldi	r19, 0x00	; 0
    5720:	2f 5f       	subi	r18, 0xFF	; 255
    5722:	3f 4f       	sbci	r19, 0xFF	; 255
    5724:	82 0f       	add	r24, r18
    5726:	93 1f       	adc	r25, r19
    5728:	2f 2d       	mov	r18, r15
    572a:	30 e0       	ldi	r19, 0x00	; 0
    572c:	82 17       	cp	r24, r18
    572e:	93 07       	cpc	r25, r19
    5730:	14 f4       	brge	.+4      	; 0x5736 <vfprintf+0x26c>
    5732:	f8 1a       	sub	r15, r24
    5734:	01 c0       	rjmp	.+2      	; 0x5738 <vfprintf+0x26e>
    5736:	f1 2c       	mov	r15, r1
    5738:	83 2d       	mov	r24, r3
    573a:	89 70       	andi	r24, 0x09	; 9
    573c:	41 f4       	brne	.+16     	; 0x574e <vfprintf+0x284>
    573e:	ff 20       	and	r15, r15
    5740:	31 f0       	breq	.+12     	; 0x574e <vfprintf+0x284>
    5742:	b6 01       	movw	r22, r12
    5744:	80 e2       	ldi	r24, 0x20	; 32
    5746:	90 e0       	ldi	r25, 0x00	; 0
    5748:	09 d4       	rcall	.+2066   	; 0x5f5c <fputc>
    574a:	fa 94       	dec	r15
    574c:	f8 cf       	rjmp	.-16     	; 0x573e <vfprintf+0x274>
    574e:	22 20       	and	r2, r2
    5750:	21 f0       	breq	.+8      	; 0x575a <vfprintf+0x290>
    5752:	b6 01       	movw	r22, r12
    5754:	82 2d       	mov	r24, r2
    5756:	90 e0       	ldi	r25, 0x00	; 0
    5758:	01 d4       	rcall	.+2050   	; 0x5f5c <fputc>
    575a:	33 fc       	sbrc	r3, 3
    575c:	08 c0       	rjmp	.+16     	; 0x576e <vfprintf+0x2a4>
    575e:	ff 20       	and	r15, r15
    5760:	31 f0       	breq	.+12     	; 0x576e <vfprintf+0x2a4>
    5762:	b6 01       	movw	r22, r12
    5764:	80 e3       	ldi	r24, 0x30	; 48
    5766:	90 e0       	ldi	r25, 0x00	; 0
    5768:	f9 d3       	rcall	.+2034   	; 0x5f5c <fputc>
    576a:	fa 94       	dec	r15
    576c:	f8 cf       	rjmp	.-16     	; 0x575e <vfprintf+0x294>
    576e:	37 fe       	sbrs	r3, 7
    5770:	58 c0       	rjmp	.+176    	; 0x5822 <vfprintf+0x358>
    5772:	94 2d       	mov	r25, r4
    5774:	85 2d       	mov	r24, r5
    5776:	57 fe       	sbrs	r5, 7
    5778:	02 c0       	rjmp	.+4      	; 0x577e <vfprintf+0x2b4>
    577a:	90 e0       	ldi	r25, 0x00	; 0
    577c:	80 e0       	ldi	r24, 0x00	; 0
    577e:	29 2e       	mov	r2, r25
    5780:	38 2e       	mov	r3, r24
    5782:	20 e0       	ldi	r18, 0x00	; 0
    5784:	30 e0       	ldi	r19, 0x00	; 0
    5786:	a2 01       	movw	r20, r4
    5788:	4e 19       	sub	r20, r14
    578a:	51 09       	sbc	r21, r1
    578c:	5d 87       	std	Y+13, r21	; 0x0d
    578e:	4c 87       	std	Y+12, r20	; 0x0c
    5790:	a2 01       	movw	r20, r4
    5792:	42 19       	sub	r20, r2
    5794:	53 09       	sbc	r21, r3
    5796:	5f 87       	std	Y+15, r21	; 0x0f
    5798:	4e 87       	std	Y+14, r20	; 0x0e
    579a:	61 2f       	mov	r22, r17
    579c:	70 e0       	ldi	r23, 0x00	; 0
    579e:	44 27       	eor	r20, r20
    57a0:	55 27       	eor	r21, r21
    57a2:	46 1b       	sub	r20, r22
    57a4:	57 0b       	sbc	r21, r23
    57a6:	59 8b       	std	Y+17, r21	; 0x11
    57a8:	48 8b       	std	Y+16, r20	; 0x10
    57aa:	5f ef       	ldi	r21, 0xFF	; 255
    57ac:	25 16       	cp	r2, r21
    57ae:	35 06       	cpc	r3, r21
    57b0:	41 f4       	brne	.+16     	; 0x57c2 <vfprintf+0x2f8>
    57b2:	b6 01       	movw	r22, r12
    57b4:	8e e2       	ldi	r24, 0x2E	; 46
    57b6:	90 e0       	ldi	r25, 0x00	; 0
    57b8:	2a 8b       	std	Y+18, r18	; 0x12
    57ba:	3b 8b       	std	Y+19, r19	; 0x13
    57bc:	cf d3       	rcall	.+1950   	; 0x5f5c <fputc>
    57be:	3b 89       	ldd	r19, Y+19	; 0x13
    57c0:	2a 89       	ldd	r18, Y+18	; 0x12
    57c2:	42 14       	cp	r4, r2
    57c4:	53 04       	cpc	r5, r3
    57c6:	6c f0       	brlt	.+26     	; 0x57e2 <vfprintf+0x318>
    57c8:	4c 85       	ldd	r20, Y+12	; 0x0c
    57ca:	5d 85       	ldd	r21, Y+13	; 0x0d
    57cc:	42 15       	cp	r20, r2
    57ce:	53 05       	cpc	r21, r3
    57d0:	44 f4       	brge	.+16     	; 0x57e2 <vfprintf+0x318>
    57d2:	ee 85       	ldd	r30, Y+14	; 0x0e
    57d4:	ff 85       	ldd	r31, Y+15	; 0x0f
    57d6:	e2 0f       	add	r30, r18
    57d8:	f3 1f       	adc	r31, r19
    57da:	e6 0d       	add	r30, r6
    57dc:	f7 1d       	adc	r31, r7
    57de:	81 81       	ldd	r24, Z+1	; 0x01
    57e0:	01 c0       	rjmp	.+2      	; 0x57e4 <vfprintf+0x31a>
    57e2:	80 e3       	ldi	r24, 0x30	; 48
    57e4:	51 e0       	ldi	r21, 0x01	; 1
    57e6:	25 1a       	sub	r2, r21
    57e8:	31 08       	sbc	r3, r1
    57ea:	2f 5f       	subi	r18, 0xFF	; 255
    57ec:	3f 4f       	sbci	r19, 0xFF	; 255
    57ee:	48 89       	ldd	r20, Y+16	; 0x10
    57f0:	59 89       	ldd	r21, Y+17	; 0x11
    57f2:	24 16       	cp	r2, r20
    57f4:	35 06       	cpc	r3, r21
    57f6:	44 f0       	brlt	.+16     	; 0x5808 <vfprintf+0x33e>
    57f8:	b6 01       	movw	r22, r12
    57fa:	90 e0       	ldi	r25, 0x00	; 0
    57fc:	2a 8b       	std	Y+18, r18	; 0x12
    57fe:	3b 8b       	std	Y+19, r19	; 0x13
    5800:	ad d3       	rcall	.+1882   	; 0x5f5c <fputc>
    5802:	2a 89       	ldd	r18, Y+18	; 0x12
    5804:	3b 89       	ldd	r19, Y+19	; 0x13
    5806:	d1 cf       	rjmp	.-94     	; 0x57aa <vfprintf+0x2e0>
    5808:	24 14       	cp	r2, r4
    580a:	35 04       	cpc	r3, r5
    580c:	39 f4       	brne	.+14     	; 0x581c <vfprintf+0x352>
    580e:	9a 81       	ldd	r25, Y+2	; 0x02
    5810:	96 33       	cpi	r25, 0x36	; 54
    5812:	18 f4       	brcc	.+6      	; 0x581a <vfprintf+0x350>
    5814:	95 33       	cpi	r25, 0x35	; 53
    5816:	11 f4       	brne	.+4      	; 0x581c <vfprintf+0x352>
    5818:	04 ff       	sbrs	r16, 4
    581a:	81 e3       	ldi	r24, 0x31	; 49
    581c:	b6 01       	movw	r22, r12
    581e:	90 e0       	ldi	r25, 0x00	; 0
    5820:	45 c0       	rjmp	.+138    	; 0x58ac <vfprintf+0x3e2>
    5822:	8a 81       	ldd	r24, Y+2	; 0x02
    5824:	81 33       	cpi	r24, 0x31	; 49
    5826:	09 f0       	breq	.+2      	; 0x582a <vfprintf+0x360>
    5828:	0f 7e       	andi	r16, 0xEF	; 239
    582a:	b6 01       	movw	r22, r12
    582c:	90 e0       	ldi	r25, 0x00	; 0
    582e:	96 d3       	rcall	.+1836   	; 0x5f5c <fputc>
    5830:	11 11       	cpse	r17, r1
    5832:	05 c0       	rjmp	.+10     	; 0x583e <vfprintf+0x374>
    5834:	34 fc       	sbrc	r3, 4
    5836:	16 c0       	rjmp	.+44     	; 0x5864 <vfprintf+0x39a>
    5838:	85 e6       	ldi	r24, 0x65	; 101
    583a:	90 e0       	ldi	r25, 0x00	; 0
    583c:	15 c0       	rjmp	.+42     	; 0x5868 <vfprintf+0x39e>
    583e:	b6 01       	movw	r22, r12
    5840:	8e e2       	ldi	r24, 0x2E	; 46
    5842:	90 e0       	ldi	r25, 0x00	; 0
    5844:	8b d3       	rcall	.+1814   	; 0x5f5c <fputc>
    5846:	82 e0       	ldi	r24, 0x02	; 2
    5848:	ee 24       	eor	r14, r14
    584a:	e3 94       	inc	r14
    584c:	e8 0e       	add	r14, r24
    584e:	f3 01       	movw	r30, r6
    5850:	e8 0f       	add	r30, r24
    5852:	f1 1d       	adc	r31, r1
    5854:	80 81       	ld	r24, Z
    5856:	b6 01       	movw	r22, r12
    5858:	90 e0       	ldi	r25, 0x00	; 0
    585a:	80 d3       	rcall	.+1792   	; 0x5f5c <fputc>
    585c:	11 50       	subi	r17, 0x01	; 1
    585e:	8e 2d       	mov	r24, r14
    5860:	99 f7       	brne	.-26     	; 0x5848 <vfprintf+0x37e>
    5862:	e8 cf       	rjmp	.-48     	; 0x5834 <vfprintf+0x36a>
    5864:	85 e4       	ldi	r24, 0x45	; 69
    5866:	90 e0       	ldi	r25, 0x00	; 0
    5868:	b6 01       	movw	r22, r12
    586a:	78 d3       	rcall	.+1776   	; 0x5f5c <fputc>
    586c:	57 fc       	sbrc	r5, 7
    586e:	05 c0       	rjmp	.+10     	; 0x587a <vfprintf+0x3b0>
    5870:	41 14       	cp	r4, r1
    5872:	51 04       	cpc	r5, r1
    5874:	39 f4       	brne	.+14     	; 0x5884 <vfprintf+0x3ba>
    5876:	04 ff       	sbrs	r16, 4
    5878:	05 c0       	rjmp	.+10     	; 0x5884 <vfprintf+0x3ba>
    587a:	51 94       	neg	r5
    587c:	41 94       	neg	r4
    587e:	51 08       	sbc	r5, r1
    5880:	8d e2       	ldi	r24, 0x2D	; 45
    5882:	01 c0       	rjmp	.+2      	; 0x5886 <vfprintf+0x3bc>
    5884:	8b e2       	ldi	r24, 0x2B	; 43
    5886:	b6 01       	movw	r22, r12
    5888:	90 e0       	ldi	r25, 0x00	; 0
    588a:	68 d3       	rcall	.+1744   	; 0x5f5c <fputc>
    588c:	80 e3       	ldi	r24, 0x30	; 48
    588e:	9a e0       	ldi	r25, 0x0A	; 10
    5890:	49 16       	cp	r4, r25
    5892:	51 04       	cpc	r5, r1
    5894:	2c f0       	brlt	.+10     	; 0x58a0 <vfprintf+0x3d6>
    5896:	8f 5f       	subi	r24, 0xFF	; 255
    5898:	5a e0       	ldi	r21, 0x0A	; 10
    589a:	45 1a       	sub	r4, r21
    589c:	51 08       	sbc	r5, r1
    589e:	f7 cf       	rjmp	.-18     	; 0x588e <vfprintf+0x3c4>
    58a0:	b6 01       	movw	r22, r12
    58a2:	90 e0       	ldi	r25, 0x00	; 0
    58a4:	5b d3       	rcall	.+1718   	; 0x5f5c <fputc>
    58a6:	b6 01       	movw	r22, r12
    58a8:	c2 01       	movw	r24, r4
    58aa:	c0 96       	adiw	r24, 0x30	; 48
    58ac:	57 d3       	rcall	.+1710   	; 0x5f5c <fputc>
    58ae:	4c c1       	rjmp	.+664    	; 0x5b48 <vfprintf+0x67e>
    58b0:	83 36       	cpi	r24, 0x63	; 99
    58b2:	31 f0       	breq	.+12     	; 0x58c0 <vfprintf+0x3f6>
    58b4:	83 37       	cpi	r24, 0x73	; 115
    58b6:	79 f0       	breq	.+30     	; 0x58d6 <vfprintf+0x40c>
    58b8:	83 35       	cpi	r24, 0x53	; 83
    58ba:	09 f0       	breq	.+2      	; 0x58be <vfprintf+0x3f4>
    58bc:	54 c0       	rjmp	.+168    	; 0x5966 <vfprintf+0x49c>
    58be:	20 c0       	rjmp	.+64     	; 0x5900 <vfprintf+0x436>
    58c0:	52 01       	movw	r10, r4
    58c2:	e2 e0       	ldi	r30, 0x02	; 2
    58c4:	ae 0e       	add	r10, r30
    58c6:	b1 1c       	adc	r11, r1
    58c8:	f2 01       	movw	r30, r4
    58ca:	80 81       	ld	r24, Z
    58cc:	89 83       	std	Y+1, r24	; 0x01
    58ce:	01 e0       	ldi	r16, 0x01	; 1
    58d0:	10 e0       	ldi	r17, 0x00	; 0
    58d2:	23 01       	movw	r4, r6
    58d4:	13 c0       	rjmp	.+38     	; 0x58fc <vfprintf+0x432>
    58d6:	52 01       	movw	r10, r4
    58d8:	f2 e0       	ldi	r31, 0x02	; 2
    58da:	af 0e       	add	r10, r31
    58dc:	b1 1c       	adc	r11, r1
    58de:	f2 01       	movw	r30, r4
    58e0:	40 80       	ld	r4, Z
    58e2:	51 80       	ldd	r5, Z+1	; 0x01
    58e4:	26 ff       	sbrs	r18, 6
    58e6:	03 c0       	rjmp	.+6      	; 0x58ee <vfprintf+0x424>
    58e8:	61 2f       	mov	r22, r17
    58ea:	70 e0       	ldi	r23, 0x00	; 0
    58ec:	02 c0       	rjmp	.+4      	; 0x58f2 <vfprintf+0x428>
    58ee:	6f ef       	ldi	r22, 0xFF	; 255
    58f0:	7f ef       	ldi	r23, 0xFF	; 255
    58f2:	c2 01       	movw	r24, r4
    58f4:	2a 8b       	std	Y+18, r18	; 0x12
    58f6:	bb d2       	rcall	.+1398   	; 0x5e6e <strnlen>
    58f8:	8c 01       	movw	r16, r24
    58fa:	2a 89       	ldd	r18, Y+18	; 0x12
    58fc:	2f 77       	andi	r18, 0x7F	; 127
    58fe:	14 c0       	rjmp	.+40     	; 0x5928 <vfprintf+0x45e>
    5900:	52 01       	movw	r10, r4
    5902:	f2 e0       	ldi	r31, 0x02	; 2
    5904:	af 0e       	add	r10, r31
    5906:	b1 1c       	adc	r11, r1
    5908:	f2 01       	movw	r30, r4
    590a:	40 80       	ld	r4, Z
    590c:	51 80       	ldd	r5, Z+1	; 0x01
    590e:	26 ff       	sbrs	r18, 6
    5910:	03 c0       	rjmp	.+6      	; 0x5918 <vfprintf+0x44e>
    5912:	61 2f       	mov	r22, r17
    5914:	70 e0       	ldi	r23, 0x00	; 0
    5916:	02 c0       	rjmp	.+4      	; 0x591c <vfprintf+0x452>
    5918:	6f ef       	ldi	r22, 0xFF	; 255
    591a:	7f ef       	ldi	r23, 0xFF	; 255
    591c:	c2 01       	movw	r24, r4
    591e:	2a 8b       	std	Y+18, r18	; 0x12
    5920:	8f d2       	rcall	.+1310   	; 0x5e40 <strnlen_P>
    5922:	8c 01       	movw	r16, r24
    5924:	2a 89       	ldd	r18, Y+18	; 0x12
    5926:	20 68       	ori	r18, 0x80	; 128
    5928:	32 2e       	mov	r3, r18
    592a:	23 fd       	sbrc	r18, 3
    592c:	18 c0       	rjmp	.+48     	; 0x595e <vfprintf+0x494>
    592e:	8f 2d       	mov	r24, r15
    5930:	90 e0       	ldi	r25, 0x00	; 0
    5932:	08 17       	cp	r16, r24
    5934:	19 07       	cpc	r17, r25
    5936:	98 f4       	brcc	.+38     	; 0x595e <vfprintf+0x494>
    5938:	b6 01       	movw	r22, r12
    593a:	80 e2       	ldi	r24, 0x20	; 32
    593c:	90 e0       	ldi	r25, 0x00	; 0
    593e:	0e d3       	rcall	.+1564   	; 0x5f5c <fputc>
    5940:	fa 94       	dec	r15
    5942:	f5 cf       	rjmp	.-22     	; 0x592e <vfprintf+0x464>
    5944:	f2 01       	movw	r30, r4
    5946:	37 fc       	sbrc	r3, 7
    5948:	85 91       	lpm	r24, Z+
    594a:	37 fe       	sbrs	r3, 7
    594c:	81 91       	ld	r24, Z+
    594e:	2f 01       	movw	r4, r30
    5950:	b6 01       	movw	r22, r12
    5952:	90 e0       	ldi	r25, 0x00	; 0
    5954:	03 d3       	rcall	.+1542   	; 0x5f5c <fputc>
    5956:	f1 10       	cpse	r15, r1
    5958:	fa 94       	dec	r15
    595a:	01 50       	subi	r16, 0x01	; 1
    595c:	11 09       	sbc	r17, r1
    595e:	01 15       	cp	r16, r1
    5960:	11 05       	cpc	r17, r1
    5962:	81 f7       	brne	.-32     	; 0x5944 <vfprintf+0x47a>
    5964:	f1 c0       	rjmp	.+482    	; 0x5b48 <vfprintf+0x67e>
    5966:	84 36       	cpi	r24, 0x64	; 100
    5968:	11 f0       	breq	.+4      	; 0x596e <vfprintf+0x4a4>
    596a:	89 36       	cpi	r24, 0x69	; 105
    596c:	51 f5       	brne	.+84     	; 0x59c2 <vfprintf+0x4f8>
    596e:	52 01       	movw	r10, r4
    5970:	27 ff       	sbrs	r18, 7
    5972:	09 c0       	rjmp	.+18     	; 0x5986 <vfprintf+0x4bc>
    5974:	f4 e0       	ldi	r31, 0x04	; 4
    5976:	af 0e       	add	r10, r31
    5978:	b1 1c       	adc	r11, r1
    597a:	f2 01       	movw	r30, r4
    597c:	60 81       	ld	r22, Z
    597e:	71 81       	ldd	r23, Z+1	; 0x01
    5980:	82 81       	ldd	r24, Z+2	; 0x02
    5982:	93 81       	ldd	r25, Z+3	; 0x03
    5984:	0a c0       	rjmp	.+20     	; 0x599a <vfprintf+0x4d0>
    5986:	f2 e0       	ldi	r31, 0x02	; 2
    5988:	af 0e       	add	r10, r31
    598a:	b1 1c       	adc	r11, r1
    598c:	f2 01       	movw	r30, r4
    598e:	60 81       	ld	r22, Z
    5990:	71 81       	ldd	r23, Z+1	; 0x01
    5992:	07 2e       	mov	r0, r23
    5994:	00 0c       	add	r0, r0
    5996:	88 0b       	sbc	r24, r24
    5998:	99 0b       	sbc	r25, r25
    599a:	2f 76       	andi	r18, 0x6F	; 111
    599c:	32 2e       	mov	r3, r18
    599e:	97 ff       	sbrs	r25, 7
    59a0:	09 c0       	rjmp	.+18     	; 0x59b4 <vfprintf+0x4ea>
    59a2:	90 95       	com	r25
    59a4:	80 95       	com	r24
    59a6:	70 95       	com	r23
    59a8:	61 95       	neg	r22
    59aa:	7f 4f       	sbci	r23, 0xFF	; 255
    59ac:	8f 4f       	sbci	r24, 0xFF	; 255
    59ae:	9f 4f       	sbci	r25, 0xFF	; 255
    59b0:	20 68       	ori	r18, 0x80	; 128
    59b2:	32 2e       	mov	r3, r18
    59b4:	2a e0       	ldi	r18, 0x0A	; 10
    59b6:	30 e0       	ldi	r19, 0x00	; 0
    59b8:	a3 01       	movw	r20, r6
    59ba:	4b d3       	rcall	.+1686   	; 0x6052 <__ultoa_invert>
    59bc:	e8 2e       	mov	r14, r24
    59be:	e6 18       	sub	r14, r6
    59c0:	3e c0       	rjmp	.+124    	; 0x5a3e <vfprintf+0x574>
    59c2:	02 2f       	mov	r16, r18
    59c4:	85 37       	cpi	r24, 0x75	; 117
    59c6:	21 f4       	brne	.+8      	; 0x59d0 <vfprintf+0x506>
    59c8:	0f 7e       	andi	r16, 0xEF	; 239
    59ca:	2a e0       	ldi	r18, 0x0A	; 10
    59cc:	30 e0       	ldi	r19, 0x00	; 0
    59ce:	1d c0       	rjmp	.+58     	; 0x5a0a <vfprintf+0x540>
    59d0:	09 7f       	andi	r16, 0xF9	; 249
    59d2:	8f 36       	cpi	r24, 0x6F	; 111
    59d4:	91 f0       	breq	.+36     	; 0x59fa <vfprintf+0x530>
    59d6:	18 f4       	brcc	.+6      	; 0x59de <vfprintf+0x514>
    59d8:	88 35       	cpi	r24, 0x58	; 88
    59da:	59 f0       	breq	.+22     	; 0x59f2 <vfprintf+0x528>
    59dc:	be c0       	rjmp	.+380    	; 0x5b5a <vfprintf+0x690>
    59de:	80 37       	cpi	r24, 0x70	; 112
    59e0:	19 f0       	breq	.+6      	; 0x59e8 <vfprintf+0x51e>
    59e2:	88 37       	cpi	r24, 0x78	; 120
    59e4:	11 f0       	breq	.+4      	; 0x59ea <vfprintf+0x520>
    59e6:	b9 c0       	rjmp	.+370    	; 0x5b5a <vfprintf+0x690>
    59e8:	00 61       	ori	r16, 0x10	; 16
    59ea:	04 ff       	sbrs	r16, 4
    59ec:	09 c0       	rjmp	.+18     	; 0x5a00 <vfprintf+0x536>
    59ee:	04 60       	ori	r16, 0x04	; 4
    59f0:	07 c0       	rjmp	.+14     	; 0x5a00 <vfprintf+0x536>
    59f2:	24 ff       	sbrs	r18, 4
    59f4:	08 c0       	rjmp	.+16     	; 0x5a06 <vfprintf+0x53c>
    59f6:	06 60       	ori	r16, 0x06	; 6
    59f8:	06 c0       	rjmp	.+12     	; 0x5a06 <vfprintf+0x53c>
    59fa:	28 e0       	ldi	r18, 0x08	; 8
    59fc:	30 e0       	ldi	r19, 0x00	; 0
    59fe:	05 c0       	rjmp	.+10     	; 0x5a0a <vfprintf+0x540>
    5a00:	20 e1       	ldi	r18, 0x10	; 16
    5a02:	30 e0       	ldi	r19, 0x00	; 0
    5a04:	02 c0       	rjmp	.+4      	; 0x5a0a <vfprintf+0x540>
    5a06:	20 e1       	ldi	r18, 0x10	; 16
    5a08:	32 e0       	ldi	r19, 0x02	; 2
    5a0a:	52 01       	movw	r10, r4
    5a0c:	07 ff       	sbrs	r16, 7
    5a0e:	09 c0       	rjmp	.+18     	; 0x5a22 <vfprintf+0x558>
    5a10:	f4 e0       	ldi	r31, 0x04	; 4
    5a12:	af 0e       	add	r10, r31
    5a14:	b1 1c       	adc	r11, r1
    5a16:	f2 01       	movw	r30, r4
    5a18:	60 81       	ld	r22, Z
    5a1a:	71 81       	ldd	r23, Z+1	; 0x01
    5a1c:	82 81       	ldd	r24, Z+2	; 0x02
    5a1e:	93 81       	ldd	r25, Z+3	; 0x03
    5a20:	08 c0       	rjmp	.+16     	; 0x5a32 <vfprintf+0x568>
    5a22:	f2 e0       	ldi	r31, 0x02	; 2
    5a24:	af 0e       	add	r10, r31
    5a26:	b1 1c       	adc	r11, r1
    5a28:	f2 01       	movw	r30, r4
    5a2a:	60 81       	ld	r22, Z
    5a2c:	71 81       	ldd	r23, Z+1	; 0x01
    5a2e:	80 e0       	ldi	r24, 0x00	; 0
    5a30:	90 e0       	ldi	r25, 0x00	; 0
    5a32:	a3 01       	movw	r20, r6
    5a34:	0e d3       	rcall	.+1564   	; 0x6052 <__ultoa_invert>
    5a36:	e8 2e       	mov	r14, r24
    5a38:	e6 18       	sub	r14, r6
    5a3a:	0f 77       	andi	r16, 0x7F	; 127
    5a3c:	30 2e       	mov	r3, r16
    5a3e:	36 fe       	sbrs	r3, 6
    5a40:	0b c0       	rjmp	.+22     	; 0x5a58 <vfprintf+0x58e>
    5a42:	33 2d       	mov	r19, r3
    5a44:	3e 7f       	andi	r19, 0xFE	; 254
    5a46:	e1 16       	cp	r14, r17
    5a48:	50 f4       	brcc	.+20     	; 0x5a5e <vfprintf+0x594>
    5a4a:	34 fe       	sbrs	r3, 4
    5a4c:	0a c0       	rjmp	.+20     	; 0x5a62 <vfprintf+0x598>
    5a4e:	32 fc       	sbrc	r3, 2
    5a50:	08 c0       	rjmp	.+16     	; 0x5a62 <vfprintf+0x598>
    5a52:	33 2d       	mov	r19, r3
    5a54:	3e 7e       	andi	r19, 0xEE	; 238
    5a56:	05 c0       	rjmp	.+10     	; 0x5a62 <vfprintf+0x598>
    5a58:	0e 2d       	mov	r16, r14
    5a5a:	33 2d       	mov	r19, r3
    5a5c:	03 c0       	rjmp	.+6      	; 0x5a64 <vfprintf+0x59a>
    5a5e:	0e 2d       	mov	r16, r14
    5a60:	01 c0       	rjmp	.+2      	; 0x5a64 <vfprintf+0x59a>
    5a62:	01 2f       	mov	r16, r17
    5a64:	34 ff       	sbrs	r19, 4
    5a66:	0c c0       	rjmp	.+24     	; 0x5a80 <vfprintf+0x5b6>
    5a68:	fe 01       	movw	r30, r28
    5a6a:	ee 0d       	add	r30, r14
    5a6c:	f1 1d       	adc	r31, r1
    5a6e:	80 81       	ld	r24, Z
    5a70:	80 33       	cpi	r24, 0x30	; 48
    5a72:	11 f4       	brne	.+4      	; 0x5a78 <vfprintf+0x5ae>
    5a74:	39 7e       	andi	r19, 0xE9	; 233
    5a76:	08 c0       	rjmp	.+16     	; 0x5a88 <vfprintf+0x5be>
    5a78:	32 ff       	sbrs	r19, 2
    5a7a:	05 c0       	rjmp	.+10     	; 0x5a86 <vfprintf+0x5bc>
    5a7c:	0e 5f       	subi	r16, 0xFE	; 254
    5a7e:	04 c0       	rjmp	.+8      	; 0x5a88 <vfprintf+0x5be>
    5a80:	83 2f       	mov	r24, r19
    5a82:	86 78       	andi	r24, 0x86	; 134
    5a84:	09 f0       	breq	.+2      	; 0x5a88 <vfprintf+0x5be>
    5a86:	0f 5f       	subi	r16, 0xFF	; 255
    5a88:	33 fd       	sbrc	r19, 3
    5a8a:	12 c0       	rjmp	.+36     	; 0x5ab0 <vfprintf+0x5e6>
    5a8c:	30 ff       	sbrs	r19, 0
    5a8e:	06 c0       	rjmp	.+12     	; 0x5a9c <vfprintf+0x5d2>
    5a90:	1e 2d       	mov	r17, r14
    5a92:	0f 15       	cp	r16, r15
    5a94:	18 f4       	brcc	.+6      	; 0x5a9c <vfprintf+0x5d2>
    5a96:	1f 0d       	add	r17, r15
    5a98:	10 1b       	sub	r17, r16
    5a9a:	0f 2d       	mov	r16, r15
    5a9c:	0f 15       	cp	r16, r15
    5a9e:	60 f4       	brcc	.+24     	; 0x5ab8 <vfprintf+0x5ee>
    5aa0:	b6 01       	movw	r22, r12
    5aa2:	80 e2       	ldi	r24, 0x20	; 32
    5aa4:	90 e0       	ldi	r25, 0x00	; 0
    5aa6:	3b 8b       	std	Y+19, r19	; 0x13
    5aa8:	59 d2       	rcall	.+1202   	; 0x5f5c <fputc>
    5aaa:	0f 5f       	subi	r16, 0xFF	; 255
    5aac:	3b 89       	ldd	r19, Y+19	; 0x13
    5aae:	f6 cf       	rjmp	.-20     	; 0x5a9c <vfprintf+0x5d2>
    5ab0:	0f 15       	cp	r16, r15
    5ab2:	10 f4       	brcc	.+4      	; 0x5ab8 <vfprintf+0x5ee>
    5ab4:	f0 1a       	sub	r15, r16
    5ab6:	01 c0       	rjmp	.+2      	; 0x5aba <vfprintf+0x5f0>
    5ab8:	f1 2c       	mov	r15, r1
    5aba:	34 ff       	sbrs	r19, 4
    5abc:	11 c0       	rjmp	.+34     	; 0x5ae0 <vfprintf+0x616>
    5abe:	b6 01       	movw	r22, r12
    5ac0:	80 e3       	ldi	r24, 0x30	; 48
    5ac2:	90 e0       	ldi	r25, 0x00	; 0
    5ac4:	3b 8b       	std	Y+19, r19	; 0x13
    5ac6:	4a d2       	rcall	.+1172   	; 0x5f5c <fputc>
    5ac8:	3b 89       	ldd	r19, Y+19	; 0x13
    5aca:	32 ff       	sbrs	r19, 2
    5acc:	16 c0       	rjmp	.+44     	; 0x5afa <vfprintf+0x630>
    5ace:	31 fd       	sbrc	r19, 1
    5ad0:	03 c0       	rjmp	.+6      	; 0x5ad8 <vfprintf+0x60e>
    5ad2:	88 e7       	ldi	r24, 0x78	; 120
    5ad4:	90 e0       	ldi	r25, 0x00	; 0
    5ad6:	02 c0       	rjmp	.+4      	; 0x5adc <vfprintf+0x612>
    5ad8:	88 e5       	ldi	r24, 0x58	; 88
    5ada:	90 e0       	ldi	r25, 0x00	; 0
    5adc:	b6 01       	movw	r22, r12
    5ade:	0c c0       	rjmp	.+24     	; 0x5af8 <vfprintf+0x62e>
    5ae0:	83 2f       	mov	r24, r19
    5ae2:	86 78       	andi	r24, 0x86	; 134
    5ae4:	51 f0       	breq	.+20     	; 0x5afa <vfprintf+0x630>
    5ae6:	31 ff       	sbrs	r19, 1
    5ae8:	02 c0       	rjmp	.+4      	; 0x5aee <vfprintf+0x624>
    5aea:	8b e2       	ldi	r24, 0x2B	; 43
    5aec:	01 c0       	rjmp	.+2      	; 0x5af0 <vfprintf+0x626>
    5aee:	80 e2       	ldi	r24, 0x20	; 32
    5af0:	37 fd       	sbrc	r19, 7
    5af2:	8d e2       	ldi	r24, 0x2D	; 45
    5af4:	b6 01       	movw	r22, r12
    5af6:	90 e0       	ldi	r25, 0x00	; 0
    5af8:	31 d2       	rcall	.+1122   	; 0x5f5c <fputc>
    5afa:	e1 16       	cp	r14, r17
    5afc:	30 f4       	brcc	.+12     	; 0x5b0a <vfprintf+0x640>
    5afe:	b6 01       	movw	r22, r12
    5b00:	80 e3       	ldi	r24, 0x30	; 48
    5b02:	90 e0       	ldi	r25, 0x00	; 0
    5b04:	2b d2       	rcall	.+1110   	; 0x5f5c <fputc>
    5b06:	11 50       	subi	r17, 0x01	; 1
    5b08:	f8 cf       	rjmp	.-16     	; 0x5afa <vfprintf+0x630>
    5b0a:	ea 94       	dec	r14
    5b0c:	f3 01       	movw	r30, r6
    5b0e:	ee 0d       	add	r30, r14
    5b10:	f1 1d       	adc	r31, r1
    5b12:	80 81       	ld	r24, Z
    5b14:	b6 01       	movw	r22, r12
    5b16:	90 e0       	ldi	r25, 0x00	; 0
    5b18:	21 d2       	rcall	.+1090   	; 0x5f5c <fputc>
    5b1a:	e1 10       	cpse	r14, r1
    5b1c:	f6 cf       	rjmp	.-20     	; 0x5b0a <vfprintf+0x640>
    5b1e:	14 c0       	rjmp	.+40     	; 0x5b48 <vfprintf+0x67e>
    5b20:	f4 e0       	ldi	r31, 0x04	; 4
    5b22:	ff 15       	cp	r31, r15
    5b24:	48 f5       	brcc	.+82     	; 0x5b78 <vfprintf+0x6ae>
    5b26:	84 e0       	ldi	r24, 0x04	; 4
    5b28:	f8 1a       	sub	r15, r24
    5b2a:	33 fe       	sbrs	r3, 3
    5b2c:	1d c0       	rjmp	.+58     	; 0x5b68 <vfprintf+0x69e>
    5b2e:	21 10       	cpse	r2, r1
    5b30:	24 c0       	rjmp	.+72     	; 0x5b7a <vfprintf+0x6b0>
    5b32:	03 ff       	sbrs	r16, 3
    5b34:	27 c0       	rjmp	.+78     	; 0x5b84 <vfprintf+0x6ba>
    5b36:	00 e4       	ldi	r16, 0x40	; 64
    5b38:	11 e0       	ldi	r17, 0x01	; 1
    5b3a:	f3 2d       	mov	r31, r3
    5b3c:	f0 71       	andi	r31, 0x10	; 16
    5b3e:	3f 2e       	mov	r3, r31
    5b40:	f8 01       	movw	r30, r16
    5b42:	84 91       	lpm	r24, Z
    5b44:	81 11       	cpse	r24, r1
    5b46:	21 c0       	rjmp	.+66     	; 0x5b8a <vfprintf+0x6c0>
    5b48:	ff 20       	and	r15, r15
    5b4a:	09 f4       	brne	.+2      	; 0x5b4e <vfprintf+0x684>
    5b4c:	fd cc       	rjmp	.-1542   	; 0x5548 <vfprintf+0x7e>
    5b4e:	b6 01       	movw	r22, r12
    5b50:	80 e2       	ldi	r24, 0x20	; 32
    5b52:	90 e0       	ldi	r25, 0x00	; 0
    5b54:	03 d2       	rcall	.+1030   	; 0x5f5c <fputc>
    5b56:	fa 94       	dec	r15
    5b58:	f7 cf       	rjmp	.-18     	; 0x5b48 <vfprintf+0x67e>
    5b5a:	f6 01       	movw	r30, r12
    5b5c:	86 81       	ldd	r24, Z+6	; 0x06
    5b5e:	97 81       	ldd	r25, Z+7	; 0x07
    5b60:	23 c0       	rjmp	.+70     	; 0x5ba8 <vfprintf+0x6de>
    5b62:	8f ef       	ldi	r24, 0xFF	; 255
    5b64:	9f ef       	ldi	r25, 0xFF	; 255
    5b66:	20 c0       	rjmp	.+64     	; 0x5ba8 <vfprintf+0x6de>
    5b68:	b6 01       	movw	r22, r12
    5b6a:	80 e2       	ldi	r24, 0x20	; 32
    5b6c:	90 e0       	ldi	r25, 0x00	; 0
    5b6e:	f6 d1       	rcall	.+1004   	; 0x5f5c <fputc>
    5b70:	fa 94       	dec	r15
    5b72:	f1 10       	cpse	r15, r1
    5b74:	f9 cf       	rjmp	.-14     	; 0x5b68 <vfprintf+0x69e>
    5b76:	db cf       	rjmp	.-74     	; 0x5b2e <vfprintf+0x664>
    5b78:	f1 2c       	mov	r15, r1
    5b7a:	b6 01       	movw	r22, r12
    5b7c:	82 2d       	mov	r24, r2
    5b7e:	90 e0       	ldi	r25, 0x00	; 0
    5b80:	ed d1       	rcall	.+986    	; 0x5f5c <fputc>
    5b82:	d7 cf       	rjmp	.-82     	; 0x5b32 <vfprintf+0x668>
    5b84:	04 e4       	ldi	r16, 0x44	; 68
    5b86:	11 e0       	ldi	r17, 0x01	; 1
    5b88:	d8 cf       	rjmp	.-80     	; 0x5b3a <vfprintf+0x670>
    5b8a:	31 10       	cpse	r3, r1
    5b8c:	80 52       	subi	r24, 0x20	; 32
    5b8e:	b6 01       	movw	r22, r12
    5b90:	90 e0       	ldi	r25, 0x00	; 0
    5b92:	e4 d1       	rcall	.+968    	; 0x5f5c <fputc>
    5b94:	0f 5f       	subi	r16, 0xFF	; 255
    5b96:	1f 4f       	sbci	r17, 0xFF	; 255
    5b98:	d3 cf       	rjmp	.-90     	; 0x5b40 <vfprintf+0x676>
    5b9a:	23 e0       	ldi	r18, 0x03	; 3
    5b9c:	2f 15       	cp	r18, r15
    5b9e:	10 f4       	brcc	.+4      	; 0x5ba4 <vfprintf+0x6da>
    5ba0:	83 e0       	ldi	r24, 0x03	; 3
    5ba2:	c2 cf       	rjmp	.-124    	; 0x5b28 <vfprintf+0x65e>
    5ba4:	f1 2c       	mov	r15, r1
    5ba6:	c5 cf       	rjmp	.-118    	; 0x5b32 <vfprintf+0x668>
    5ba8:	63 96       	adiw	r28, 0x13	; 19
    5baa:	0f b6       	in	r0, 0x3f	; 63
    5bac:	f8 94       	cli
    5bae:	de bf       	out	0x3e, r29	; 62
    5bb0:	0f be       	out	0x3f, r0	; 63
    5bb2:	cd bf       	out	0x3d, r28	; 61
    5bb4:	df 91       	pop	r29
    5bb6:	cf 91       	pop	r28
    5bb8:	1f 91       	pop	r17
    5bba:	0f 91       	pop	r16
    5bbc:	ff 90       	pop	r15
    5bbe:	ef 90       	pop	r14
    5bc0:	df 90       	pop	r13
    5bc2:	cf 90       	pop	r12
    5bc4:	bf 90       	pop	r11
    5bc6:	af 90       	pop	r10
    5bc8:	9f 90       	pop	r9
    5bca:	8f 90       	pop	r8
    5bcc:	7f 90       	pop	r7
    5bce:	6f 90       	pop	r6
    5bd0:	5f 90       	pop	r5
    5bd2:	4f 90       	pop	r4
    5bd4:	3f 90       	pop	r3
    5bd6:	2f 90       	pop	r2
    5bd8:	08 95       	ret

00005bda <__divmodhi4>:
    5bda:	97 fb       	bst	r25, 7
    5bdc:	07 2e       	mov	r0, r23
    5bde:	16 f4       	brtc	.+4      	; 0x5be4 <__divmodhi4+0xa>
    5be0:	00 94       	com	r0
    5be2:	06 d0       	rcall	.+12     	; 0x5bf0 <__divmodhi4_neg1>
    5be4:	77 fd       	sbrc	r23, 7
    5be6:	08 d0       	rcall	.+16     	; 0x5bf8 <__divmodhi4_neg2>
    5be8:	22 d0       	rcall	.+68     	; 0x5c2e <__udivmodhi4>
    5bea:	07 fc       	sbrc	r0, 7
    5bec:	05 d0       	rcall	.+10     	; 0x5bf8 <__divmodhi4_neg2>
    5bee:	3e f4       	brtc	.+14     	; 0x5bfe <__divmodhi4_exit>

00005bf0 <__divmodhi4_neg1>:
    5bf0:	90 95       	com	r25
    5bf2:	81 95       	neg	r24
    5bf4:	9f 4f       	sbci	r25, 0xFF	; 255
    5bf6:	08 95       	ret

00005bf8 <__divmodhi4_neg2>:
    5bf8:	70 95       	com	r23
    5bfa:	61 95       	neg	r22
    5bfc:	7f 4f       	sbci	r23, 0xFF	; 255

00005bfe <__divmodhi4_exit>:
    5bfe:	08 95       	ret

00005c00 <__tablejump2__>:
    5c00:	ee 0f       	add	r30, r30
    5c02:	ff 1f       	adc	r31, r31
    5c04:	88 1f       	adc	r24, r24
    5c06:	8b bf       	out	0x3b, r24	; 59
    5c08:	07 90       	elpm	r0, Z+
    5c0a:	f6 91       	elpm	r31, Z
    5c0c:	e0 2d       	mov	r30, r0
    5c0e:	19 94       	eijmp

00005c10 <__umulhisi3>:
    5c10:	a2 9f       	mul	r26, r18
    5c12:	b0 01       	movw	r22, r0
    5c14:	b3 9f       	mul	r27, r19
    5c16:	c0 01       	movw	r24, r0
    5c18:	a3 9f       	mul	r26, r19
    5c1a:	70 0d       	add	r23, r0
    5c1c:	81 1d       	adc	r24, r1
    5c1e:	11 24       	eor	r1, r1
    5c20:	91 1d       	adc	r25, r1
    5c22:	b2 9f       	mul	r27, r18
    5c24:	70 0d       	add	r23, r0
    5c26:	81 1d       	adc	r24, r1
    5c28:	11 24       	eor	r1, r1
    5c2a:	91 1d       	adc	r25, r1
    5c2c:	08 95       	ret

00005c2e <__udivmodhi4>:
    5c2e:	aa 1b       	sub	r26, r26
    5c30:	bb 1b       	sub	r27, r27
    5c32:	51 e1       	ldi	r21, 0x11	; 17
    5c34:	07 c0       	rjmp	.+14     	; 0x5c44 <__udivmodhi4_ep>

00005c36 <__udivmodhi4_loop>:
    5c36:	aa 1f       	adc	r26, r26
    5c38:	bb 1f       	adc	r27, r27
    5c3a:	a6 17       	cp	r26, r22
    5c3c:	b7 07       	cpc	r27, r23
    5c3e:	10 f0       	brcs	.+4      	; 0x5c44 <__udivmodhi4_ep>
    5c40:	a6 1b       	sub	r26, r22
    5c42:	b7 0b       	sbc	r27, r23

00005c44 <__udivmodhi4_ep>:
    5c44:	88 1f       	adc	r24, r24
    5c46:	99 1f       	adc	r25, r25
    5c48:	5a 95       	dec	r21
    5c4a:	a9 f7       	brne	.-22     	; 0x5c36 <__udivmodhi4_loop>
    5c4c:	80 95       	com	r24
    5c4e:	90 95       	com	r25
    5c50:	bc 01       	movw	r22, r24
    5c52:	cd 01       	movw	r24, r26
    5c54:	08 95       	ret

00005c56 <atoi>:
    5c56:	fc 01       	movw	r30, r24
    5c58:	88 27       	eor	r24, r24
    5c5a:	99 27       	eor	r25, r25
    5c5c:	e8 94       	clt
    5c5e:	21 91       	ld	r18, Z+
    5c60:	20 32       	cpi	r18, 0x20	; 32
    5c62:	e9 f3       	breq	.-6      	; 0x5c5e <atoi+0x8>
    5c64:	29 30       	cpi	r18, 0x09	; 9
    5c66:	10 f0       	brcs	.+4      	; 0x5c6c <atoi+0x16>
    5c68:	2e 30       	cpi	r18, 0x0E	; 14
    5c6a:	c8 f3       	brcs	.-14     	; 0x5c5e <atoi+0x8>
    5c6c:	2b 32       	cpi	r18, 0x2B	; 43
    5c6e:	39 f0       	breq	.+14     	; 0x5c7e <atoi+0x28>
    5c70:	2d 32       	cpi	r18, 0x2D	; 45
    5c72:	31 f4       	brne	.+12     	; 0x5c80 <atoi+0x2a>
    5c74:	68 94       	set
    5c76:	03 c0       	rjmp	.+6      	; 0x5c7e <atoi+0x28>
    5c78:	50 d1       	rcall	.+672    	; 0x5f1a <__mulhi_const_10>
    5c7a:	82 0f       	add	r24, r18
    5c7c:	91 1d       	adc	r25, r1
    5c7e:	21 91       	ld	r18, Z+
    5c80:	20 53       	subi	r18, 0x30	; 48
    5c82:	2a 30       	cpi	r18, 0x0A	; 10
    5c84:	c8 f3       	brcs	.-14     	; 0x5c78 <atoi+0x22>
    5c86:	1e f4       	brtc	.+6      	; 0x5c8e <atoi+0x38>
    5c88:	90 95       	com	r25
    5c8a:	81 95       	neg	r24
    5c8c:	9f 4f       	sbci	r25, 0xFF	; 255
    5c8e:	08 95       	ret

00005c90 <__ftoa_engine>:
    5c90:	28 30       	cpi	r18, 0x08	; 8
    5c92:	08 f0       	brcs	.+2      	; 0x5c96 <__ftoa_engine+0x6>
    5c94:	27 e0       	ldi	r18, 0x07	; 7
    5c96:	33 27       	eor	r19, r19
    5c98:	da 01       	movw	r26, r20
    5c9a:	99 0f       	add	r25, r25
    5c9c:	31 1d       	adc	r19, r1
    5c9e:	87 fd       	sbrc	r24, 7
    5ca0:	91 60       	ori	r25, 0x01	; 1
    5ca2:	00 96       	adiw	r24, 0x00	; 0
    5ca4:	61 05       	cpc	r22, r1
    5ca6:	71 05       	cpc	r23, r1
    5ca8:	39 f4       	brne	.+14     	; 0x5cb8 <__ftoa_engine+0x28>
    5caa:	32 60       	ori	r19, 0x02	; 2
    5cac:	2e 5f       	subi	r18, 0xFE	; 254
    5cae:	3d 93       	st	X+, r19
    5cb0:	30 e3       	ldi	r19, 0x30	; 48
    5cb2:	2a 95       	dec	r18
    5cb4:	e1 f7       	brne	.-8      	; 0x5cae <__ftoa_engine+0x1e>
    5cb6:	08 95       	ret
    5cb8:	9f 3f       	cpi	r25, 0xFF	; 255
    5cba:	30 f0       	brcs	.+12     	; 0x5cc8 <__ftoa_engine+0x38>
    5cbc:	80 38       	cpi	r24, 0x80	; 128
    5cbe:	71 05       	cpc	r23, r1
    5cc0:	61 05       	cpc	r22, r1
    5cc2:	09 f0       	breq	.+2      	; 0x5cc6 <__ftoa_engine+0x36>
    5cc4:	3c 5f       	subi	r19, 0xFC	; 252
    5cc6:	3c 5f       	subi	r19, 0xFC	; 252
    5cc8:	3d 93       	st	X+, r19
    5cca:	91 30       	cpi	r25, 0x01	; 1
    5ccc:	08 f0       	brcs	.+2      	; 0x5cd0 <__ftoa_engine+0x40>
    5cce:	80 68       	ori	r24, 0x80	; 128
    5cd0:	91 1d       	adc	r25, r1
    5cd2:	df 93       	push	r29
    5cd4:	cf 93       	push	r28
    5cd6:	1f 93       	push	r17
    5cd8:	0f 93       	push	r16
    5cda:	ff 92       	push	r15
    5cdc:	ef 92       	push	r14
    5cde:	19 2f       	mov	r17, r25
    5ce0:	98 7f       	andi	r25, 0xF8	; 248
    5ce2:	96 95       	lsr	r25
    5ce4:	e9 2f       	mov	r30, r25
    5ce6:	96 95       	lsr	r25
    5ce8:	96 95       	lsr	r25
    5cea:	e9 0f       	add	r30, r25
    5cec:	ff 27       	eor	r31, r31
    5cee:	ee 55       	subi	r30, 0x5E	; 94
    5cf0:	fe 4f       	sbci	r31, 0xFE	; 254
    5cf2:	99 27       	eor	r25, r25
    5cf4:	33 27       	eor	r19, r19
    5cf6:	ee 24       	eor	r14, r14
    5cf8:	ff 24       	eor	r15, r15
    5cfa:	a7 01       	movw	r20, r14
    5cfc:	e7 01       	movw	r28, r14
    5cfe:	05 90       	lpm	r0, Z+
    5d00:	08 94       	sec
    5d02:	07 94       	ror	r0
    5d04:	28 f4       	brcc	.+10     	; 0x5d10 <__ftoa_engine+0x80>
    5d06:	36 0f       	add	r19, r22
    5d08:	e7 1e       	adc	r14, r23
    5d0a:	f8 1e       	adc	r15, r24
    5d0c:	49 1f       	adc	r20, r25
    5d0e:	51 1d       	adc	r21, r1
    5d10:	66 0f       	add	r22, r22
    5d12:	77 1f       	adc	r23, r23
    5d14:	88 1f       	adc	r24, r24
    5d16:	99 1f       	adc	r25, r25
    5d18:	06 94       	lsr	r0
    5d1a:	a1 f7       	brne	.-24     	; 0x5d04 <__ftoa_engine+0x74>
    5d1c:	05 90       	lpm	r0, Z+
    5d1e:	07 94       	ror	r0
    5d20:	28 f4       	brcc	.+10     	; 0x5d2c <__ftoa_engine+0x9c>
    5d22:	e7 0e       	add	r14, r23
    5d24:	f8 1e       	adc	r15, r24
    5d26:	49 1f       	adc	r20, r25
    5d28:	56 1f       	adc	r21, r22
    5d2a:	c1 1d       	adc	r28, r1
    5d2c:	77 0f       	add	r23, r23
    5d2e:	88 1f       	adc	r24, r24
    5d30:	99 1f       	adc	r25, r25
    5d32:	66 1f       	adc	r22, r22
    5d34:	06 94       	lsr	r0
    5d36:	a1 f7       	brne	.-24     	; 0x5d20 <__ftoa_engine+0x90>
    5d38:	05 90       	lpm	r0, Z+
    5d3a:	07 94       	ror	r0
    5d3c:	28 f4       	brcc	.+10     	; 0x5d48 <__ftoa_engine+0xb8>
    5d3e:	f8 0e       	add	r15, r24
    5d40:	49 1f       	adc	r20, r25
    5d42:	56 1f       	adc	r21, r22
    5d44:	c7 1f       	adc	r28, r23
    5d46:	d1 1d       	adc	r29, r1
    5d48:	88 0f       	add	r24, r24
    5d4a:	99 1f       	adc	r25, r25
    5d4c:	66 1f       	adc	r22, r22
    5d4e:	77 1f       	adc	r23, r23
    5d50:	06 94       	lsr	r0
    5d52:	a1 f7       	brne	.-24     	; 0x5d3c <__ftoa_engine+0xac>
    5d54:	05 90       	lpm	r0, Z+
    5d56:	07 94       	ror	r0
    5d58:	20 f4       	brcc	.+8      	; 0x5d62 <__ftoa_engine+0xd2>
    5d5a:	49 0f       	add	r20, r25
    5d5c:	56 1f       	adc	r21, r22
    5d5e:	c7 1f       	adc	r28, r23
    5d60:	d8 1f       	adc	r29, r24
    5d62:	99 0f       	add	r25, r25
    5d64:	66 1f       	adc	r22, r22
    5d66:	77 1f       	adc	r23, r23
    5d68:	88 1f       	adc	r24, r24
    5d6a:	06 94       	lsr	r0
    5d6c:	a9 f7       	brne	.-22     	; 0x5d58 <__ftoa_engine+0xc8>
    5d6e:	84 91       	lpm	r24, Z
    5d70:	10 95       	com	r17
    5d72:	17 70       	andi	r17, 0x07	; 7
    5d74:	41 f0       	breq	.+16     	; 0x5d86 <__ftoa_engine+0xf6>
    5d76:	d6 95       	lsr	r29
    5d78:	c7 95       	ror	r28
    5d7a:	57 95       	ror	r21
    5d7c:	47 95       	ror	r20
    5d7e:	f7 94       	ror	r15
    5d80:	e7 94       	ror	r14
    5d82:	1a 95       	dec	r17
    5d84:	c1 f7       	brne	.-16     	; 0x5d76 <__ftoa_engine+0xe6>
    5d86:	e8 e4       	ldi	r30, 0x48	; 72
    5d88:	f1 e0       	ldi	r31, 0x01	; 1
    5d8a:	68 94       	set
    5d8c:	15 90       	lpm	r1, Z+
    5d8e:	15 91       	lpm	r17, Z+
    5d90:	35 91       	lpm	r19, Z+
    5d92:	65 91       	lpm	r22, Z+
    5d94:	95 91       	lpm	r25, Z+
    5d96:	05 90       	lpm	r0, Z+
    5d98:	7f e2       	ldi	r23, 0x2F	; 47
    5d9a:	73 95       	inc	r23
    5d9c:	e1 18       	sub	r14, r1
    5d9e:	f1 0a       	sbc	r15, r17
    5da0:	43 0b       	sbc	r20, r19
    5da2:	56 0b       	sbc	r21, r22
    5da4:	c9 0b       	sbc	r28, r25
    5da6:	d0 09       	sbc	r29, r0
    5da8:	c0 f7       	brcc	.-16     	; 0x5d9a <__ftoa_engine+0x10a>
    5daa:	e1 0c       	add	r14, r1
    5dac:	f1 1e       	adc	r15, r17
    5dae:	43 1f       	adc	r20, r19
    5db0:	56 1f       	adc	r21, r22
    5db2:	c9 1f       	adc	r28, r25
    5db4:	d0 1d       	adc	r29, r0
    5db6:	7e f4       	brtc	.+30     	; 0x5dd6 <__ftoa_engine+0x146>
    5db8:	70 33       	cpi	r23, 0x30	; 48
    5dba:	11 f4       	brne	.+4      	; 0x5dc0 <__ftoa_engine+0x130>
    5dbc:	8a 95       	dec	r24
    5dbe:	e6 cf       	rjmp	.-52     	; 0x5d8c <__ftoa_engine+0xfc>
    5dc0:	e8 94       	clt
    5dc2:	01 50       	subi	r16, 0x01	; 1
    5dc4:	30 f0       	brcs	.+12     	; 0x5dd2 <__ftoa_engine+0x142>
    5dc6:	08 0f       	add	r16, r24
    5dc8:	0a f4       	brpl	.+2      	; 0x5dcc <__ftoa_engine+0x13c>
    5dca:	00 27       	eor	r16, r16
    5dcc:	02 17       	cp	r16, r18
    5dce:	08 f4       	brcc	.+2      	; 0x5dd2 <__ftoa_engine+0x142>
    5dd0:	20 2f       	mov	r18, r16
    5dd2:	23 95       	inc	r18
    5dd4:	02 2f       	mov	r16, r18
    5dd6:	7a 33       	cpi	r23, 0x3A	; 58
    5dd8:	28 f0       	brcs	.+10     	; 0x5de4 <__ftoa_engine+0x154>
    5dda:	79 e3       	ldi	r23, 0x39	; 57
    5ddc:	7d 93       	st	X+, r23
    5dde:	2a 95       	dec	r18
    5de0:	e9 f7       	brne	.-6      	; 0x5ddc <__ftoa_engine+0x14c>
    5de2:	10 c0       	rjmp	.+32     	; 0x5e04 <__ftoa_engine+0x174>
    5de4:	7d 93       	st	X+, r23
    5de6:	2a 95       	dec	r18
    5de8:	89 f6       	brne	.-94     	; 0x5d8c <__ftoa_engine+0xfc>
    5dea:	06 94       	lsr	r0
    5dec:	97 95       	ror	r25
    5dee:	67 95       	ror	r22
    5df0:	37 95       	ror	r19
    5df2:	17 95       	ror	r17
    5df4:	17 94       	ror	r1
    5df6:	e1 18       	sub	r14, r1
    5df8:	f1 0a       	sbc	r15, r17
    5dfa:	43 0b       	sbc	r20, r19
    5dfc:	56 0b       	sbc	r21, r22
    5dfe:	c9 0b       	sbc	r28, r25
    5e00:	d0 09       	sbc	r29, r0
    5e02:	98 f0       	brcs	.+38     	; 0x5e2a <__ftoa_engine+0x19a>
    5e04:	23 95       	inc	r18
    5e06:	7e 91       	ld	r23, -X
    5e08:	73 95       	inc	r23
    5e0a:	7a 33       	cpi	r23, 0x3A	; 58
    5e0c:	08 f0       	brcs	.+2      	; 0x5e10 <__ftoa_engine+0x180>
    5e0e:	70 e3       	ldi	r23, 0x30	; 48
    5e10:	7c 93       	st	X, r23
    5e12:	20 13       	cpse	r18, r16
    5e14:	b8 f7       	brcc	.-18     	; 0x5e04 <__ftoa_engine+0x174>
    5e16:	7e 91       	ld	r23, -X
    5e18:	70 61       	ori	r23, 0x10	; 16
    5e1a:	7d 93       	st	X+, r23
    5e1c:	30 f0       	brcs	.+12     	; 0x5e2a <__ftoa_engine+0x19a>
    5e1e:	83 95       	inc	r24
    5e20:	71 e3       	ldi	r23, 0x31	; 49
    5e22:	7d 93       	st	X+, r23
    5e24:	70 e3       	ldi	r23, 0x30	; 48
    5e26:	2a 95       	dec	r18
    5e28:	e1 f7       	brne	.-8      	; 0x5e22 <__ftoa_engine+0x192>
    5e2a:	11 24       	eor	r1, r1
    5e2c:	ef 90       	pop	r14
    5e2e:	ff 90       	pop	r15
    5e30:	0f 91       	pop	r16
    5e32:	1f 91       	pop	r17
    5e34:	cf 91       	pop	r28
    5e36:	df 91       	pop	r29
    5e38:	99 27       	eor	r25, r25
    5e3a:	87 fd       	sbrc	r24, 7
    5e3c:	90 95       	com	r25
    5e3e:	08 95       	ret

00005e40 <strnlen_P>:
    5e40:	fc 01       	movw	r30, r24
    5e42:	05 90       	lpm	r0, Z+
    5e44:	61 50       	subi	r22, 0x01	; 1
    5e46:	70 40       	sbci	r23, 0x00	; 0
    5e48:	01 10       	cpse	r0, r1
    5e4a:	d8 f7       	brcc	.-10     	; 0x5e42 <strnlen_P+0x2>
    5e4c:	80 95       	com	r24
    5e4e:	90 95       	com	r25
    5e50:	8e 0f       	add	r24, r30
    5e52:	9f 1f       	adc	r25, r31
    5e54:	08 95       	ret

00005e56 <strtok>:
    5e56:	4c e4       	ldi	r20, 0x4C	; 76
    5e58:	58 e0       	ldi	r21, 0x08	; 8
    5e5a:	2e c0       	rjmp	.+92     	; 0x5eb8 <strtok_r>

00005e5c <memcpy>:
    5e5c:	fb 01       	movw	r30, r22
    5e5e:	dc 01       	movw	r26, r24
    5e60:	02 c0       	rjmp	.+4      	; 0x5e66 <memcpy+0xa>
    5e62:	01 90       	ld	r0, Z+
    5e64:	0d 92       	st	X+, r0
    5e66:	41 50       	subi	r20, 0x01	; 1
    5e68:	50 40       	sbci	r21, 0x00	; 0
    5e6a:	d8 f7       	brcc	.-10     	; 0x5e62 <memcpy+0x6>
    5e6c:	08 95       	ret

00005e6e <strnlen>:
    5e6e:	fc 01       	movw	r30, r24
    5e70:	61 50       	subi	r22, 0x01	; 1
    5e72:	70 40       	sbci	r23, 0x00	; 0
    5e74:	01 90       	ld	r0, Z+
    5e76:	01 10       	cpse	r0, r1
    5e78:	d8 f7       	brcc	.-10     	; 0x5e70 <strnlen+0x2>
    5e7a:	80 95       	com	r24
    5e7c:	90 95       	com	r25
    5e7e:	8e 0f       	add	r24, r30
    5e80:	9f 1f       	adc	r25, r31
    5e82:	08 95       	ret

00005e84 <strstr>:
    5e84:	fb 01       	movw	r30, r22
    5e86:	51 91       	ld	r21, Z+
    5e88:	55 23       	and	r21, r21
    5e8a:	a9 f0       	breq	.+42     	; 0x5eb6 <strstr+0x32>
    5e8c:	bf 01       	movw	r22, r30
    5e8e:	dc 01       	movw	r26, r24
    5e90:	4d 91       	ld	r20, X+
    5e92:	45 17       	cp	r20, r21
    5e94:	41 11       	cpse	r20, r1
    5e96:	e1 f7       	brne	.-8      	; 0x5e90 <strstr+0xc>
    5e98:	59 f4       	brne	.+22     	; 0x5eb0 <strstr+0x2c>
    5e9a:	cd 01       	movw	r24, r26
    5e9c:	01 90       	ld	r0, Z+
    5e9e:	00 20       	and	r0, r0
    5ea0:	49 f0       	breq	.+18     	; 0x5eb4 <strstr+0x30>
    5ea2:	4d 91       	ld	r20, X+
    5ea4:	40 15       	cp	r20, r0
    5ea6:	41 11       	cpse	r20, r1
    5ea8:	c9 f3       	breq	.-14     	; 0x5e9c <strstr+0x18>
    5eaa:	fb 01       	movw	r30, r22
    5eac:	41 11       	cpse	r20, r1
    5eae:	ef cf       	rjmp	.-34     	; 0x5e8e <strstr+0xa>
    5eb0:	81 e0       	ldi	r24, 0x01	; 1
    5eb2:	90 e0       	ldi	r25, 0x00	; 0
    5eb4:	01 97       	sbiw	r24, 0x01	; 1
    5eb6:	08 95       	ret

00005eb8 <strtok_r>:
    5eb8:	fa 01       	movw	r30, r20
    5eba:	a1 91       	ld	r26, Z+
    5ebc:	b0 81       	ld	r27, Z
    5ebe:	00 97       	sbiw	r24, 0x00	; 0
    5ec0:	19 f4       	brne	.+6      	; 0x5ec8 <strtok_r+0x10>
    5ec2:	10 97       	sbiw	r26, 0x00	; 0
    5ec4:	e1 f0       	breq	.+56     	; 0x5efe <strtok_r+0x46>
    5ec6:	cd 01       	movw	r24, r26
    5ec8:	dc 01       	movw	r26, r24
    5eca:	cd 01       	movw	r24, r26
    5ecc:	0d 90       	ld	r0, X+
    5ece:	00 20       	and	r0, r0
    5ed0:	11 f4       	brne	.+4      	; 0x5ed6 <strtok_r+0x1e>
    5ed2:	c0 01       	movw	r24, r0
    5ed4:	13 c0       	rjmp	.+38     	; 0x5efc <strtok_r+0x44>
    5ed6:	fb 01       	movw	r30, r22
    5ed8:	21 91       	ld	r18, Z+
    5eda:	22 23       	and	r18, r18
    5edc:	19 f0       	breq	.+6      	; 0x5ee4 <strtok_r+0x2c>
    5ede:	20 15       	cp	r18, r0
    5ee0:	d9 f7       	brne	.-10     	; 0x5ed8 <strtok_r+0x20>
    5ee2:	f3 cf       	rjmp	.-26     	; 0x5eca <strtok_r+0x12>
    5ee4:	fb 01       	movw	r30, r22
    5ee6:	21 91       	ld	r18, Z+
    5ee8:	20 15       	cp	r18, r0
    5eea:	19 f4       	brne	.+6      	; 0x5ef2 <strtok_r+0x3a>
    5eec:	1e 92       	st	-X, r1
    5eee:	11 96       	adiw	r26, 0x01	; 1
    5ef0:	06 c0       	rjmp	.+12     	; 0x5efe <strtok_r+0x46>
    5ef2:	22 23       	and	r18, r18
    5ef4:	c1 f7       	brne	.-16     	; 0x5ee6 <strtok_r+0x2e>
    5ef6:	0d 90       	ld	r0, X+
    5ef8:	00 20       	and	r0, r0
    5efa:	a1 f7       	brne	.-24     	; 0x5ee4 <strtok_r+0x2c>
    5efc:	d0 01       	movw	r26, r0
    5efe:	fa 01       	movw	r30, r20
    5f00:	a1 93       	st	Z+, r26
    5f02:	b0 83       	st	Z, r27
    5f04:	08 95       	ret

00005f06 <__itoa_ncheck>:
    5f06:	bb 27       	eor	r27, r27
    5f08:	4a 30       	cpi	r20, 0x0A	; 10
    5f0a:	31 f4       	brne	.+12     	; 0x5f18 <__itoa_ncheck+0x12>
    5f0c:	99 23       	and	r25, r25
    5f0e:	22 f4       	brpl	.+8      	; 0x5f18 <__itoa_ncheck+0x12>
    5f10:	bd e2       	ldi	r27, 0x2D	; 45
    5f12:	90 95       	com	r25
    5f14:	81 95       	neg	r24
    5f16:	9f 4f       	sbci	r25, 0xFF	; 255
    5f18:	09 c0       	rjmp	.+18     	; 0x5f2c <__utoa_common>

00005f1a <__mulhi_const_10>:
    5f1a:	7a e0       	ldi	r23, 0x0A	; 10
    5f1c:	97 9f       	mul	r25, r23
    5f1e:	90 2d       	mov	r25, r0
    5f20:	87 9f       	mul	r24, r23
    5f22:	80 2d       	mov	r24, r0
    5f24:	91 0d       	add	r25, r1
    5f26:	11 24       	eor	r1, r1
    5f28:	08 95       	ret

00005f2a <__utoa_ncheck>:
    5f2a:	bb 27       	eor	r27, r27

00005f2c <__utoa_common>:
    5f2c:	fb 01       	movw	r30, r22
    5f2e:	55 27       	eor	r21, r21
    5f30:	aa 27       	eor	r26, r26
    5f32:	88 0f       	add	r24, r24
    5f34:	99 1f       	adc	r25, r25
    5f36:	aa 1f       	adc	r26, r26
    5f38:	a4 17       	cp	r26, r20
    5f3a:	10 f0       	brcs	.+4      	; 0x5f40 <__utoa_common+0x14>
    5f3c:	a4 1b       	sub	r26, r20
    5f3e:	83 95       	inc	r24
    5f40:	50 51       	subi	r21, 0x10	; 16
    5f42:	b9 f7       	brne	.-18     	; 0x5f32 <__utoa_common+0x6>
    5f44:	a0 5d       	subi	r26, 0xD0	; 208
    5f46:	aa 33       	cpi	r26, 0x3A	; 58
    5f48:	08 f0       	brcs	.+2      	; 0x5f4c <__utoa_common+0x20>
    5f4a:	a9 5d       	subi	r26, 0xD9	; 217
    5f4c:	a1 93       	st	Z+, r26
    5f4e:	00 97       	sbiw	r24, 0x00	; 0
    5f50:	79 f7       	brne	.-34     	; 0x5f30 <__utoa_common+0x4>
    5f52:	b1 11       	cpse	r27, r1
    5f54:	b1 93       	st	Z+, r27
    5f56:	11 92       	st	Z+, r1
    5f58:	cb 01       	movw	r24, r22
    5f5a:	d9 c0       	rjmp	.+434    	; 0x610e <strrev>

00005f5c <fputc>:
    5f5c:	0f 93       	push	r16
    5f5e:	1f 93       	push	r17
    5f60:	cf 93       	push	r28
    5f62:	df 93       	push	r29
    5f64:	fb 01       	movw	r30, r22
    5f66:	23 81       	ldd	r18, Z+3	; 0x03
    5f68:	21 fd       	sbrc	r18, 1
    5f6a:	03 c0       	rjmp	.+6      	; 0x5f72 <fputc+0x16>
    5f6c:	8f ef       	ldi	r24, 0xFF	; 255
    5f6e:	9f ef       	ldi	r25, 0xFF	; 255
    5f70:	28 c0       	rjmp	.+80     	; 0x5fc2 <fputc+0x66>
    5f72:	22 ff       	sbrs	r18, 2
    5f74:	16 c0       	rjmp	.+44     	; 0x5fa2 <fputc+0x46>
    5f76:	46 81       	ldd	r20, Z+6	; 0x06
    5f78:	57 81       	ldd	r21, Z+7	; 0x07
    5f7a:	24 81       	ldd	r18, Z+4	; 0x04
    5f7c:	35 81       	ldd	r19, Z+5	; 0x05
    5f7e:	42 17       	cp	r20, r18
    5f80:	53 07       	cpc	r21, r19
    5f82:	44 f4       	brge	.+16     	; 0x5f94 <fputc+0x38>
    5f84:	a0 81       	ld	r26, Z
    5f86:	b1 81       	ldd	r27, Z+1	; 0x01
    5f88:	9d 01       	movw	r18, r26
    5f8a:	2f 5f       	subi	r18, 0xFF	; 255
    5f8c:	3f 4f       	sbci	r19, 0xFF	; 255
    5f8e:	31 83       	std	Z+1, r19	; 0x01
    5f90:	20 83       	st	Z, r18
    5f92:	8c 93       	st	X, r24
    5f94:	26 81       	ldd	r18, Z+6	; 0x06
    5f96:	37 81       	ldd	r19, Z+7	; 0x07
    5f98:	2f 5f       	subi	r18, 0xFF	; 255
    5f9a:	3f 4f       	sbci	r19, 0xFF	; 255
    5f9c:	37 83       	std	Z+7, r19	; 0x07
    5f9e:	26 83       	std	Z+6, r18	; 0x06
    5fa0:	10 c0       	rjmp	.+32     	; 0x5fc2 <fputc+0x66>
    5fa2:	eb 01       	movw	r28, r22
    5fa4:	09 2f       	mov	r16, r25
    5fa6:	18 2f       	mov	r17, r24
    5fa8:	00 84       	ldd	r0, Z+8	; 0x08
    5faa:	f1 85       	ldd	r31, Z+9	; 0x09
    5fac:	e0 2d       	mov	r30, r0
    5fae:	19 95       	eicall
    5fb0:	89 2b       	or	r24, r25
    5fb2:	e1 f6       	brne	.-72     	; 0x5f6c <fputc+0x10>
    5fb4:	8e 81       	ldd	r24, Y+6	; 0x06
    5fb6:	9f 81       	ldd	r25, Y+7	; 0x07
    5fb8:	01 96       	adiw	r24, 0x01	; 1
    5fba:	9f 83       	std	Y+7, r25	; 0x07
    5fbc:	8e 83       	std	Y+6, r24	; 0x06
    5fbe:	81 2f       	mov	r24, r17
    5fc0:	90 2f       	mov	r25, r16
    5fc2:	df 91       	pop	r29
    5fc4:	cf 91       	pop	r28
    5fc6:	1f 91       	pop	r17
    5fc8:	0f 91       	pop	r16
    5fca:	08 95       	ret

00005fcc <printf>:
    5fcc:	cf 93       	push	r28
    5fce:	df 93       	push	r29
    5fd0:	cd b7       	in	r28, 0x3d	; 61
    5fd2:	de b7       	in	r29, 0x3e	; 62
    5fd4:	ae 01       	movw	r20, r28
    5fd6:	4a 5f       	subi	r20, 0xFA	; 250
    5fd8:	5f 4f       	sbci	r21, 0xFF	; 255
    5fda:	fa 01       	movw	r30, r20
    5fdc:	61 91       	ld	r22, Z+
    5fde:	71 91       	ld	r23, Z+
    5fe0:	af 01       	movw	r20, r30
    5fe2:	80 91 3c 1b 	lds	r24, 0x1B3C	; 0x801b3c <__iob+0x2>
    5fe6:	90 91 3d 1b 	lds	r25, 0x1B3D	; 0x801b3d <__iob+0x3>
    5fea:	6f da       	rcall	.-2850   	; 0x54ca <vfprintf>
    5fec:	df 91       	pop	r29
    5fee:	cf 91       	pop	r28
    5ff0:	08 95       	ret

00005ff2 <puts>:
    5ff2:	0f 93       	push	r16
    5ff4:	1f 93       	push	r17
    5ff6:	cf 93       	push	r28
    5ff8:	df 93       	push	r29
    5ffa:	e0 91 3c 1b 	lds	r30, 0x1B3C	; 0x801b3c <__iob+0x2>
    5ffe:	f0 91 3d 1b 	lds	r31, 0x1B3D	; 0x801b3d <__iob+0x3>
    6002:	23 81       	ldd	r18, Z+3	; 0x03
    6004:	21 ff       	sbrs	r18, 1
    6006:	1b c0       	rjmp	.+54     	; 0x603e <puts+0x4c>
    6008:	8c 01       	movw	r16, r24
    600a:	d0 e0       	ldi	r29, 0x00	; 0
    600c:	c0 e0       	ldi	r28, 0x00	; 0
    600e:	f8 01       	movw	r30, r16
    6010:	81 91       	ld	r24, Z+
    6012:	8f 01       	movw	r16, r30
    6014:	60 91 3c 1b 	lds	r22, 0x1B3C	; 0x801b3c <__iob+0x2>
    6018:	70 91 3d 1b 	lds	r23, 0x1B3D	; 0x801b3d <__iob+0x3>
    601c:	db 01       	movw	r26, r22
    601e:	18 96       	adiw	r26, 0x08	; 8
    6020:	ed 91       	ld	r30, X+
    6022:	fc 91       	ld	r31, X
    6024:	19 97       	sbiw	r26, 0x09	; 9
    6026:	88 23       	and	r24, r24
    6028:	31 f0       	breq	.+12     	; 0x6036 <puts+0x44>
    602a:	19 95       	eicall
    602c:	89 2b       	or	r24, r25
    602e:	79 f3       	breq	.-34     	; 0x600e <puts+0x1c>
    6030:	df ef       	ldi	r29, 0xFF	; 255
    6032:	cf ef       	ldi	r28, 0xFF	; 255
    6034:	ec cf       	rjmp	.-40     	; 0x600e <puts+0x1c>
    6036:	8a e0       	ldi	r24, 0x0A	; 10
    6038:	19 95       	eicall
    603a:	89 2b       	or	r24, r25
    603c:	19 f0       	breq	.+6      	; 0x6044 <puts+0x52>
    603e:	8f ef       	ldi	r24, 0xFF	; 255
    6040:	9f ef       	ldi	r25, 0xFF	; 255
    6042:	02 c0       	rjmp	.+4      	; 0x6048 <puts+0x56>
    6044:	8d 2f       	mov	r24, r29
    6046:	9c 2f       	mov	r25, r28
    6048:	df 91       	pop	r29
    604a:	cf 91       	pop	r28
    604c:	1f 91       	pop	r17
    604e:	0f 91       	pop	r16
    6050:	08 95       	ret

00006052 <__ultoa_invert>:
    6052:	fa 01       	movw	r30, r20
    6054:	aa 27       	eor	r26, r26
    6056:	28 30       	cpi	r18, 0x08	; 8
    6058:	51 f1       	breq	.+84     	; 0x60ae <__ultoa_invert+0x5c>
    605a:	20 31       	cpi	r18, 0x10	; 16
    605c:	81 f1       	breq	.+96     	; 0x60be <__ultoa_invert+0x6c>
    605e:	e8 94       	clt
    6060:	6f 93       	push	r22
    6062:	6e 7f       	andi	r22, 0xFE	; 254
    6064:	6e 5f       	subi	r22, 0xFE	; 254
    6066:	7f 4f       	sbci	r23, 0xFF	; 255
    6068:	8f 4f       	sbci	r24, 0xFF	; 255
    606a:	9f 4f       	sbci	r25, 0xFF	; 255
    606c:	af 4f       	sbci	r26, 0xFF	; 255
    606e:	b1 e0       	ldi	r27, 0x01	; 1
    6070:	3e d0       	rcall	.+124    	; 0x60ee <__ultoa_invert+0x9c>
    6072:	b4 e0       	ldi	r27, 0x04	; 4
    6074:	3c d0       	rcall	.+120    	; 0x60ee <__ultoa_invert+0x9c>
    6076:	67 0f       	add	r22, r23
    6078:	78 1f       	adc	r23, r24
    607a:	89 1f       	adc	r24, r25
    607c:	9a 1f       	adc	r25, r26
    607e:	a1 1d       	adc	r26, r1
    6080:	68 0f       	add	r22, r24
    6082:	79 1f       	adc	r23, r25
    6084:	8a 1f       	adc	r24, r26
    6086:	91 1d       	adc	r25, r1
    6088:	a1 1d       	adc	r26, r1
    608a:	6a 0f       	add	r22, r26
    608c:	71 1d       	adc	r23, r1
    608e:	81 1d       	adc	r24, r1
    6090:	91 1d       	adc	r25, r1
    6092:	a1 1d       	adc	r26, r1
    6094:	20 d0       	rcall	.+64     	; 0x60d6 <__ultoa_invert+0x84>
    6096:	09 f4       	brne	.+2      	; 0x609a <__ultoa_invert+0x48>
    6098:	68 94       	set
    609a:	3f 91       	pop	r19
    609c:	2a e0       	ldi	r18, 0x0A	; 10
    609e:	26 9f       	mul	r18, r22
    60a0:	11 24       	eor	r1, r1
    60a2:	30 19       	sub	r19, r0
    60a4:	30 5d       	subi	r19, 0xD0	; 208
    60a6:	31 93       	st	Z+, r19
    60a8:	de f6       	brtc	.-74     	; 0x6060 <__ultoa_invert+0xe>
    60aa:	cf 01       	movw	r24, r30
    60ac:	08 95       	ret
    60ae:	46 2f       	mov	r20, r22
    60b0:	47 70       	andi	r20, 0x07	; 7
    60b2:	40 5d       	subi	r20, 0xD0	; 208
    60b4:	41 93       	st	Z+, r20
    60b6:	b3 e0       	ldi	r27, 0x03	; 3
    60b8:	0f d0       	rcall	.+30     	; 0x60d8 <__ultoa_invert+0x86>
    60ba:	c9 f7       	brne	.-14     	; 0x60ae <__ultoa_invert+0x5c>
    60bc:	f6 cf       	rjmp	.-20     	; 0x60aa <__ultoa_invert+0x58>
    60be:	46 2f       	mov	r20, r22
    60c0:	4f 70       	andi	r20, 0x0F	; 15
    60c2:	40 5d       	subi	r20, 0xD0	; 208
    60c4:	4a 33       	cpi	r20, 0x3A	; 58
    60c6:	18 f0       	brcs	.+6      	; 0x60ce <__ultoa_invert+0x7c>
    60c8:	49 5d       	subi	r20, 0xD9	; 217
    60ca:	31 fd       	sbrc	r19, 1
    60cc:	40 52       	subi	r20, 0x20	; 32
    60ce:	41 93       	st	Z+, r20
    60d0:	02 d0       	rcall	.+4      	; 0x60d6 <__ultoa_invert+0x84>
    60d2:	a9 f7       	brne	.-22     	; 0x60be <__ultoa_invert+0x6c>
    60d4:	ea cf       	rjmp	.-44     	; 0x60aa <__ultoa_invert+0x58>
    60d6:	b4 e0       	ldi	r27, 0x04	; 4
    60d8:	a6 95       	lsr	r26
    60da:	97 95       	ror	r25
    60dc:	87 95       	ror	r24
    60de:	77 95       	ror	r23
    60e0:	67 95       	ror	r22
    60e2:	ba 95       	dec	r27
    60e4:	c9 f7       	brne	.-14     	; 0x60d8 <__ultoa_invert+0x86>
    60e6:	00 97       	sbiw	r24, 0x00	; 0
    60e8:	61 05       	cpc	r22, r1
    60ea:	71 05       	cpc	r23, r1
    60ec:	08 95       	ret
    60ee:	9b 01       	movw	r18, r22
    60f0:	ac 01       	movw	r20, r24
    60f2:	0a 2e       	mov	r0, r26
    60f4:	06 94       	lsr	r0
    60f6:	57 95       	ror	r21
    60f8:	47 95       	ror	r20
    60fa:	37 95       	ror	r19
    60fc:	27 95       	ror	r18
    60fe:	ba 95       	dec	r27
    6100:	c9 f7       	brne	.-14     	; 0x60f4 <__ultoa_invert+0xa2>
    6102:	62 0f       	add	r22, r18
    6104:	73 1f       	adc	r23, r19
    6106:	84 1f       	adc	r24, r20
    6108:	95 1f       	adc	r25, r21
    610a:	a0 1d       	adc	r26, r0
    610c:	08 95       	ret

0000610e <strrev>:
    610e:	dc 01       	movw	r26, r24
    6110:	fc 01       	movw	r30, r24
    6112:	67 2f       	mov	r22, r23
    6114:	71 91       	ld	r23, Z+
    6116:	77 23       	and	r23, r23
    6118:	e1 f7       	brne	.-8      	; 0x6112 <strrev+0x4>
    611a:	32 97       	sbiw	r30, 0x02	; 2
    611c:	04 c0       	rjmp	.+8      	; 0x6126 <strrev+0x18>
    611e:	7c 91       	ld	r23, X
    6120:	6d 93       	st	X+, r22
    6122:	70 83       	st	Z, r23
    6124:	62 91       	ld	r22, -Z
    6126:	ae 17       	cp	r26, r30
    6128:	bf 07       	cpc	r27, r31
    612a:	c8 f3       	brcs	.-14     	; 0x611e <strrev+0x10>
    612c:	08 95       	ret

0000612e <_exit>:
    612e:	f8 94       	cli

00006130 <__stop_program>:
    6130:	ff cf       	rjmp	.-2      	; 0x6130 <__stop_program>
